/* Automatically generated file. Don't edit! */
#include "refalrts.h"


extern enum r05_fnresult r05c_Mu(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Br(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Card(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Cp(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Dg(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Dgall(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Divmod(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Explode(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_First(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Get(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Implode(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Last(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Lenw(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Lower(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Numb(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Open(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Print(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Prout(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Put(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Putout(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Rp(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Step(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Symb(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Time(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Upper(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Sysfun(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Freeze(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Freezer(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Dn(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Up(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Ev_met(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Residue(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Close(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetCurrentDirectory(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_RemoveFile(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Implode_Ext(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Explode_Ext(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TimeElapsed(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Compare(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_DeSysfun(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_XMLParse(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Random(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_RandomDigit(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Write(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_special(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_regular(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ListOfBuiltin(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_SizeOf(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetPID(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_int4fab_1(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetPPID(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Success(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Fails(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_True(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_False(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Add(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Sub(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Mul(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Div(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Mod(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_WriteLine(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_FWriteLine(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ReadLine(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_FReadLine(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_FOpen(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_FClose(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Arg(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ExistFile(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetEnv(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Exit(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_System(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_IntFromStr(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_StrFromInt(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Chr(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Ord(struct r05_node *arg_begin, struct r05_node *arg_end);

#line 2 "..\\lib/Library.ref"
#include <stdio.h>
#include <string.h>
#include <vector>
#include <ctype.h>
#include <stdlib.h>
#line 88 "..\\lib/Library.cpp"
enum r05_fnresult r05c_Mu(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Br(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Card(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Cp(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Dg(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Dgall(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Divmod(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Explode(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 49 "..\\lib/Library.ref"
  struct r05_node *callable = arg_begin->next;
  struct r05_node *ident = callable->next;

  if (
     ident == arg_end
     || R05_DATATAG_FUNCTION != ident->tag
     || ident->next != arg_end
  ) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  r05_reset_allocator();
  r05_alloc_string(ident->info.function.name);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
#line 150 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_First(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Get(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Implode(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Last(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Lenw(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Lower(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Numb(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Open(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Print(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Prout(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Put(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Putout(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Rp(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Step(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Symb(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Time(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Upper(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Sysfun(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Freeze(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Freezer(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Dn(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Up(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Ev_met(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Residue(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Close(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GetCurrentDirectory(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_RemoveFile(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Implode_Ext(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Explode_Ext(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TimeElapsed(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Compare(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 196 "..\\lib/Library.ref"
  struct r05_node *func_name, *sX, *sY;

  func_name = arg_begin->next;
  sX = func_name->next;
  if (sX->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  sY = sX->next;
  if (sY->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  if (sY->next != arg_end) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  sX->info.char_ =
    sX->info.number < sY->info.number ? '-' :
    sX->info.number > sY->info.number ? '+' :
    '0';
  sX->tag = R05_DATATAG_CHAR;

  r05_splice_to_freelist(arg_begin, func_name);
  r05_splice_to_freelist(sY, arg_end);

  return R05_SUCCESS;
#line 363 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_DeSysfun(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_XMLParse(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Random(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_RandomDigit(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Write(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_special(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_regular(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_ListOfBuiltin(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[122] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* */
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_number(1UL);
    r05_alloc_function(r05c_Mu, "Mu");
    r05_alloc_function(r05c_special, "special");
    r05_alloc_close_bracket(n[1]);
    r05_alloc_open_bracket(n[2]);
    r05_alloc_number(2UL);
    r05_alloc_function(r05c_Add, "Add");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_bracket(n[4]);
    r05_alloc_number(3UL);
    r05_alloc_function(r05c_Arg, "Arg");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_bracket(n[6]);
    r05_alloc_number(4UL);
    r05_alloc_function(r05c_Br, "Br");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[7]);
    r05_alloc_open_bracket(n[8]);
    r05_alloc_number(5UL);
    r05_alloc_function(r05c_Card, "Card");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[9]);
    r05_alloc_open_bracket(n[10]);
    r05_alloc_number(6UL);
    r05_alloc_function(r05c_Chr, "Chr");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[11]);
    r05_alloc_open_bracket(n[12]);
    r05_alloc_number(7UL);
    r05_alloc_function(r05c_Cp, "Cp");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[13]);
    r05_alloc_open_bracket(n[14]);
    r05_alloc_number(8UL);
    r05_alloc_function(r05c_Dg, "Dg");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[15]);
    r05_alloc_open_bracket(n[16]);
    r05_alloc_number(9UL);
    r05_alloc_function(r05c_Dgall, "Dgall");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[17]);
    r05_alloc_open_bracket(n[18]);
    r05_alloc_number(10UL);
    r05_alloc_function(r05c_Div, "Div");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[19]);
    r05_alloc_open_bracket(n[20]);
    r05_alloc_number(11UL);
    r05_alloc_function(r05c_Divmod, "Divmod");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[21]);
    r05_alloc_open_bracket(n[22]);
    r05_alloc_number(12UL);
    r05_alloc_function(r05c_Explode, "Explode");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[23]);
    r05_alloc_open_bracket(n[24]);
    r05_alloc_number(13UL);
    r05_alloc_function(r05c_First, "First");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[25]);
    r05_alloc_open_bracket(n[26]);
    r05_alloc_number(14UL);
    r05_alloc_function(r05c_Get, "Get");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[27]);
    r05_alloc_open_bracket(n[28]);
    r05_alloc_number(15UL);
    r05_alloc_function(r05c_Implode, "Implode");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[29]);
    r05_alloc_open_bracket(n[30]);
    r05_alloc_number(16UL);
    r05_alloc_function(r05c_Last, "Last");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[31]);
    r05_alloc_open_bracket(n[32]);
    r05_alloc_number(17UL);
    r05_alloc_function(r05c_Lenw, "Lenw");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[33]);
    r05_alloc_open_bracket(n[34]);
    r05_alloc_number(18UL);
    r05_alloc_function(r05c_Lower, "Lower");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[35]);
    r05_alloc_open_bracket(n[36]);
    r05_alloc_number(19UL);
    r05_alloc_function(r05c_Mod, "Mod");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[37]);
    r05_alloc_open_bracket(n[38]);
    r05_alloc_number(20UL);
    r05_alloc_function(r05c_Mul, "Mul");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[39]);
    r05_alloc_open_bracket(n[40]);
    r05_alloc_number(21UL);
    r05_alloc_function(r05c_Numb, "Numb");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[41]);
    r05_alloc_open_bracket(n[42]);
    r05_alloc_number(22UL);
    r05_alloc_function(r05c_Open, "Open");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[43]);
    r05_alloc_open_bracket(n[44]);
    r05_alloc_number(23UL);
    r05_alloc_function(r05c_Ord, "Ord");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[45]);
    r05_alloc_open_bracket(n[46]);
    r05_alloc_number(24UL);
    r05_alloc_function(r05c_Print, "Print");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[47]);
    r05_alloc_open_bracket(n[48]);
    r05_alloc_number(25UL);
    r05_alloc_function(r05c_Prout, "Prout");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[49]);
    r05_alloc_open_bracket(n[50]);
    r05_alloc_number(26UL);
    r05_alloc_function(r05c_Put, "Put");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[51]);
    r05_alloc_open_bracket(n[52]);
    r05_alloc_number(27UL);
    r05_alloc_function(r05c_Putout, "Putout");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[53]);
    r05_alloc_open_bracket(n[54]);
    r05_alloc_number(28UL);
    r05_alloc_function(r05c_Rp, "Rp");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[55]);
    r05_alloc_open_bracket(n[56]);
    r05_alloc_number(29UL);
    r05_alloc_function(r05c_Step, "Step");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[57]);
    r05_alloc_open_bracket(n[58]);
    r05_alloc_number(30UL);
    r05_alloc_function(r05c_Sub, "Sub");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[59]);
    r05_alloc_open_bracket(n[60]);
    r05_alloc_number(31UL);
    r05_alloc_function(r05c_Symb, "Symb");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[61]);
    r05_alloc_open_bracket(n[62]);
    r05_alloc_number(32UL);
    r05_alloc_function(r05c_Time, "Time");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[63]);
    r05_alloc_open_bracket(n[64]);
    r05_alloc_number(34UL);
    r05_alloc_function(r05c_Upper, "Upper");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[65]);
    r05_alloc_open_bracket(n[66]);
    r05_alloc_number(35UL);
    r05_alloc_function(r05c_Sysfun, "Sysfun");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[67]);
    r05_alloc_open_bracket(n[68]);
    r05_alloc_number(45UL);
    r05_alloc_function(r05c_Freeze, "Freeze");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[69]);
    r05_alloc_open_bracket(n[70]);
    r05_alloc_number(46UL);
    r05_alloc_function(r05c_Freezer, "Freezer");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[71]);
    r05_alloc_open_bracket(n[72]);
    r05_alloc_number(47UL);
    r05_alloc_function(r05c_Dn, "Dn");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[73]);
    r05_alloc_open_bracket(n[74]);
    r05_alloc_number(48UL);
    r05_alloc_function(r05c_Up, "Up");
    r05_alloc_function(r05c_special, "special");
    r05_alloc_close_bracket(n[75]);
    r05_alloc_open_bracket(n[76]);
    r05_alloc_number(49UL);
    r05_alloc_function(r05c_Ev_met, "Ev_met");
    r05_alloc_function(r05c_special, "special");
    r05_alloc_close_bracket(n[77]);
    r05_alloc_open_bracket(n[78]);
    r05_alloc_number(50UL);
    r05_alloc_function(r05c_Residue, "Residue");
    r05_alloc_function(r05c_special, "special");
    r05_alloc_close_bracket(n[79]);
    r05_alloc_open_bracket(n[80]);
    r05_alloc_number(51UL);
    r05_alloc_function(r05c_GetEnv, "GetEnv");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[81]);
    r05_alloc_open_bracket(n[82]);
    r05_alloc_number(52UL);
    r05_alloc_function(r05c_System, "System");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[83]);
    r05_alloc_open_bracket(n[84]);
    r05_alloc_number(53UL);
    r05_alloc_function(r05c_Exit, "Exit");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[85]);
    r05_alloc_open_bracket(n[86]);
    r05_alloc_number(54UL);
    r05_alloc_function(r05c_Close, "Close");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[87]);
    r05_alloc_open_bracket(n[88]);
    r05_alloc_number(55UL);
    r05_alloc_function(r05c_ExistFile, "ExistFile");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[89]);
    r05_alloc_open_bracket(n[90]);
    r05_alloc_number(56UL);
    r05_alloc_function(r05c_GetCurrentDirectory, "GetCurrentDirectory");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[91]);
    r05_alloc_open_bracket(n[92]);
    r05_alloc_number(57UL);
    r05_alloc_function(r05c_RemoveFile, "RemoveFile");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[93]);
    r05_alloc_open_bracket(n[94]);
    r05_alloc_number(58UL);
    r05_alloc_function(r05c_Implode_Ext, "Implode_Ext");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[95]);
    r05_alloc_open_bracket(n[96]);
    r05_alloc_number(59UL);
    r05_alloc_function(r05c_Explode_Ext, "Explode_Ext");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[97]);
    r05_alloc_open_bracket(n[98]);
    r05_alloc_number(60UL);
    r05_alloc_function(r05c_TimeElapsed, "TimeElapsed");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[99]);
    r05_alloc_open_bracket(n[100]);
    r05_alloc_number(61UL);
    r05_alloc_function(r05c_Compare, "Compare");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[101]);
    r05_alloc_open_bracket(n[102]);
    r05_alloc_number(62UL);
    r05_alloc_function(r05c_DeSysfun, "DeSysfun");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[103]);
    r05_alloc_open_bracket(n[104]);
    r05_alloc_number(63UL);
    r05_alloc_function(r05c_XMLParse, "XMLParse");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[105]);
    r05_alloc_open_bracket(n[106]);
    r05_alloc_number(64UL);
    r05_alloc_function(r05c_Random, "Random");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[107]);
    r05_alloc_open_bracket(n[108]);
    r05_alloc_number(65UL);
    r05_alloc_function(r05c_RandomDigit, "RandomDigit");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[109]);
    r05_alloc_open_bracket(n[110]);
    r05_alloc_number(66UL);
    r05_alloc_function(r05c_Write, "Write");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[111]);
    r05_alloc_open_bracket(n[112]);
    r05_alloc_number(67UL);
    r05_alloc_function(r05c_ListOfBuiltin, "ListOfBuiltin");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[113]);
    r05_alloc_open_bracket(n[114]);
    r05_alloc_number(68UL);
    r05_alloc_function(r05c_SizeOf, "SizeOf");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[115]);
    r05_alloc_open_bracket(n[116]);
    r05_alloc_number(69UL);
    r05_alloc_function(r05c_GetPID, "GetPID");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[117]);
    r05_alloc_open_bracket(n[118]);
    r05_alloc_number(70UL);
    r05_alloc_function(r05c_int4fab_1, "int4fab_1");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[119]);
    r05_alloc_open_bracket(n[120]);
    r05_alloc_number(71UL);
    r05_alloc_function(r05c_GetPPID, "GetPPID");
    r05_alloc_function(r05c_regular, "regular");
    r05_alloc_close_bracket(n[121]);
    r05_link_brackets(n[120], n[121]);
    r05_link_brackets(n[118], n[119]);
    r05_link_brackets(n[116], n[117]);
    r05_link_brackets(n[114], n[115]);
    r05_link_brackets(n[112], n[113]);
    r05_link_brackets(n[110], n[111]);
    r05_link_brackets(n[108], n[109]);
    r05_link_brackets(n[106], n[107]);
    r05_link_brackets(n[104], n[105]);
    r05_link_brackets(n[102], n[103]);
    r05_link_brackets(n[100], n[101]);
    r05_link_brackets(n[98], n[99]);
    r05_link_brackets(n[96], n[97]);
    r05_link_brackets(n[94], n[95]);
    r05_link_brackets(n[92], n[93]);
    r05_link_brackets(n[90], n[91]);
    r05_link_brackets(n[88], n[89]);
    r05_link_brackets(n[86], n[87]);
    r05_link_brackets(n[84], n[85]);
    r05_link_brackets(n[82], n[83]);
    r05_link_brackets(n[80], n[81]);
    r05_link_brackets(n[78], n[79]);
    r05_link_brackets(n[76], n[77]);
    r05_link_brackets(n[74], n[75]);
    r05_link_brackets(n[72], n[73]);
    r05_link_brackets(n[70], n[71]);
    r05_link_brackets(n[68], n[69]);
    r05_link_brackets(n[66], n[67]);
    r05_link_brackets(n[64], n[65]);
    r05_link_brackets(n[62], n[63]);
    r05_link_brackets(n[60], n[61]);
    r05_link_brackets(n[58], n[59]);
    r05_link_brackets(n[56], n[57]);
    r05_link_brackets(n[54], n[55]);
    r05_link_brackets(n[52], n[53]);
    r05_link_brackets(n[50], n[51]);
    r05_link_brackets(n[48], n[49]);
    r05_link_brackets(n[46], n[47]);
    r05_link_brackets(n[44], n[45]);
    r05_link_brackets(n[42], n[43]);
    r05_link_brackets(n[40], n[41]);
    r05_link_brackets(n[38], n[39]);
    r05_link_brackets(n[36], n[37]);
    r05_link_brackets(n[34], n[35]);
    r05_link_brackets(n[32], n[33]);
    r05_link_brackets(n[30], n[31]);
    r05_link_brackets(n[28], n[29]);
    r05_link_brackets(n[26], n[27]);
    r05_link_brackets(n[24], n[25]);
    r05_link_brackets(n[22], n[23]);
    r05_link_brackets(n[20], n[21]);
    r05_link_brackets(n[18], n[19]);
    r05_link_brackets(n[16], n[17]);
    r05_link_brackets(n[14], n[15]);
    r05_link_brackets(n[12], n[13]);
    r05_link_brackets(n[10], n[11]);
    r05_link_brackets(n[8], n[9]);
    r05_link_brackets(n[6], n[7]);
    r05_link_brackets(n[4], n[5]);
    r05_link_brackets(n[2], n[3]);
    r05_link_brackets(n[0], n[1]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_SizeOf(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GetPID(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_int4fab_1(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GetPPID(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Success(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Fails(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_True(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_False(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

#line 346 "..\\lib/Library.ref"

#define ARITHM_OP(op, check) \
  struct r05_node *func_name = arg_begin->next; \
  \
  struct r05_node *sX = func_name->next; \
  if (sX->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  struct r05_node *sY = sX->next; \
  if (sY->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  if (sY->next != arg_end) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  check \
  \
  sX->info.number = sX->info.number op sY->info.number; \
  \
  refalrts::splice_to_freelist(arg_begin, func_name); \
  refalrts::splice_to_freelist(sY, arg_end); \
  \
  return R05_SUCCESS;

#define NO_CHECK
#define CHECK_ZERODIV \
  if (sY->info.number == 0) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  }

#line 880 "..\\lib/Library.cpp"
enum r05_fnresult r05c_Add(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 384 "..\\lib/Library.ref"
  ARITHM_OP(+, NO_CHECK)
#line 884 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_Sub(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 390 "..\\lib/Library.ref"
  ARITHM_OP(-, NO_CHECK)
#line 891 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_Mul(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 396 "..\\lib/Library.ref"
  ARITHM_OP(*, NO_CHECK)
#line 898 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_Div(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 402 "..\\lib/Library.ref"
  ARITHM_OP(/, CHECK_ZERODIV);
#line 905 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_Mod(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 408 "..\\lib/Library.ref"
  ARITHM_OP(%, CHECK_ZERODIV);
#line 912 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

#line 417 "..\\lib/Library.ref"
enum r05_fnresult write_to_stream(
  FILE *out, struct r05_node *str_begin, struct r05_node *str_end
) {
  if (ferror(out)) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  int printf_res;

  for (
    struct r05_node *p = str_begin;
    ! r05_empty_seq(p, str_end);
    r05_move_left(&p, &str_end)
  ) {
    switch(p->tag) {
      case R05_DATATAG_CHAR: {
        printf_res = fprintf(out, "%c", p->info.char_);
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_NUMBER: {
        printf_res = fprintf(out, "%lu ", p->info.number);
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_FUNCTION: {
        if (p->info.function.name[0] != '\0') {
          printf_res = fprintf(out, "%s ", p->info.function.name);
        } else {
          printf_res = fprintf(out, "&%p ", p->info.function.ptr);
        }

        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_OPEN_BRACKET: {
        printf_res = fprintf(out, "(");
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_CLOSE_BRACKET: {
        printf_res = fprintf(out, ")");
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_FILE: {
        printf_res = fprintf(out, "*%p", p->info.file);
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      default:
        r05_switch_default_violation(p->tag);
    }
  }

  printf_res = fprintf(out, "\n");
  if (printf_res < 0) {
    return R05_RECOGNITION_IMPOSSIBLE;
  } else {
    return R05_SUCCESS;
  }
}
#line 1003 "..\\lib/Library.cpp"
enum r05_fnresult r05c_WriteLine(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 508 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eLine_b_1;
    struct r05_node *eLine_e_1;
    eLine_b_1 = bb_0;
    eLine_e_1 = be_0;

    enum r05_fnresult fnres = write_to_stream(stdout, eLine_b_1, eLine_e_1);

    if (fnres != R05_SUCCESS)
      return fnres;

    r05_reset_allocator();
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return fnres;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1027 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_FWriteLine(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 534 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sFileHandle_1;
    struct r05_node *eLine_b_1;
    struct r05_node *eLine_e_1;
    // s.FileHandle e.Line
    if (! r05_svar_left(&sFileHandle_1, &bb_0, &be_0))
      break;
    if (sFileHandle_1->tag != R05_DATATAG_FILE)
      break;
    eLine_b_1 = bb_0;
    eLine_e_1 = be_0;

    enum r05_fnresult write_result =
      write_to_stream(
        static_cast<FILE*>(sFileHandle_1->info.file), eLine_b_1, eLine_e_1
      );

    if (write_result != R05_SUCCESS)
      return write_result;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;
    refalrts::splice_stvar(res, sFileHandle_1);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1065 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

#line 570 "..\\lib/Library.ref"
enum r05_fnresult read_from_stream(
  FILE *input, struct r05_node *&begin, struct r05_node *&end
) {
  struct r05_node *before_begin = r05_insert_pos()->prev;
  struct r05_node *cur_char_node = 0;

  int cur_char;

  for ( ; ; ) {
    cur_char = getc(input);
    if (EOF == cur_char) {
      refalrts::alloc_number(cur_char_node, 0UL);
      break;
    } else if ('\n' == cur_char) {
      break;
    } else {
      /*
        Пользуемся тем фактом, что в данной реализации размещёные в свободной
        памяти узлы располагаются в последовательных адресах, которые будут
        начинаться с before_begin->next.
      */
      refalrts::alloc_char(cur_char_node, static_cast<char>(cur_char));
    }
  }

  if (cur_char_node != 0) {
    begin = before_begin->next;
    end = cur_char_node;
  } else {
    begin = 0;
    end = 0;
  }

  return R05_SUCCESS;
}
#line 1105 "..\\lib/Library.cpp"
enum r05_fnresult r05c_ReadLine(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 609 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    if (! r05_empty_seq(bb_0, be_0))
      break;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *str_begin, *str_end;

    enum r05_fnresult fn_result = read_from_stream(stdin, str_begin, str_end);

    if (fn_result != R05_SUCCESS)
      return fn_result;

    refalrts::splice_evar(res, str_begin, str_end);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1132 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_FReadLine(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 638 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sFileHandle_1;
    // s.FileHandle
    if (! r05_svar_left(&sFileHandle_1, &bb_0, &be_0))
      break;
    if (sFileHandle_1->tag != R05_DATATAG_FILE)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *str_begin, *str_end;

    enum r05_fnresult fn_result =
      read_from_stream(
        static_cast<FILE*>(sFileHandle_1->info.file), str_begin, str_end
      );

    if (fn_result != R05_SUCCESS)
      return fn_result;

    res = refalrts::splice_evar(res, str_begin, str_end);
    refalrts::splice_stvar(res, sFileHandle_1);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1172 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

#line 677 "..\\lib/Library.ref"
namespace {

enum r05_fnresult string_from_seq(
  std::vector<char>& string, struct r05_node *begin, struct r05_node *end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  for ( ; ; ) {
    unsigned read = r05_read_chars(buffer, cBufLen, &begin, &end);

    if (read == 0) {
      break;
    }

    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);

    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь r05_empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (r05_empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return R05_SUCCESS;
  } else {
    // здесь begin->tag != cDataChar
    return R05_RECOGNITION_IMPOSSIBLE;
  }
}

} // unnamed namespace
#line 1218 "..\\lib/Library.cpp"
enum r05_fnresult r05c_FOpen(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 723 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eFileName_b_1;
    struct r05_node *eFileName_e_1;

    const char *mode;

    if (r05_char_left('r', &bb_0, &be_0)) {
      mode = "r";
    } else if (r05_char_left('w', &bb_0, &be_0)) {
      mode = "w";
    } else {
      break;
    }

    eFileName_b_1 = bb_0;
    eFileName_e_1 = be_0;

    std::vector<char> filename;

    enum r05_fnresult fname_read =
      string_from_seq(filename, eFileName_b_1, eFileName_e_1);

    if (R05_SUCCESS != fname_read)
      return fname_read;

    if (filename.empty())
      return R05_RECOGNITION_IMPOSSIBLE;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *file_ptr = r05_alloc_node(R05_DATATAG_FILE);

    file_ptr->tag = R05_DATATAG_FILE;

    if (FILE *f = fopen(&filename[0], mode)) {
      file_ptr->info.file = f;
    } else {
      return R05_RECOGNITION_IMPOSSIBLE;
    }

    refalrts::splice_elem(res, file_ptr);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1272 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_FClose(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 779 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sFileHandle_1;
    // s.FileHandle
    if (! r05_svar_left(&sFileHandle_1, &bb_0, &be_0))
      break;
    if (sFileHandle_1->tag != R05_DATATAG_FILE)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    int fclose_res = fclose(static_cast<FILE*>(sFileHandle_1->info.file));

    if (EOF == fclose_res) {
      return R05_RECOGNITION_IMPOSSIBLE;
    } else {
      /* Ничего не делаем */;
    }

    r05_reset_allocator();
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1306 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

#line 812 "..\\lib/Library.ref"
/*
  Глобальные переменные, хранящие параметры вызова
  (устанавливаются в refalrts.cpp).
*/

extern char **g_argv;
extern int g_argc;
#line 1318 "..\\lib/Library.cpp"
enum r05_fnresult r05c_Arg(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 824 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sParamNumber_1;
    // s.ParamNumber
    if (! r05_svar_left(&sParamNumber_1, &bb_0, &be_0))
      break;
    if (sParamNumber_1->tag != R05_DATATAG_NUMBER)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    r05_reset_allocator();

    int arg_number = sParamNumber_1->info.number;

    struct r05_node *res_begin = 0;
    struct r05_node *res_end = 0;

    if (arg_number < g_argc) {
      refalrts::alloc_string(res_begin, res_end, g_argv[arg_number]);
      refalrts::splice_evar(arg_begin, res_begin, res_end);
    }

    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1352 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_ExistFile(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 860 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eFileName_b_1;
    struct r05_node *eFileName_e_1;
    // e.FileName
    eFileName_b_1 = bb_0;
    eFileName_e_1 = be_0;

    std::vector<char> fname;

    enum r05_fnresult fname_res =
      string_from_seq(fname, eFileName_b_1, eFileName_e_1);

    if (fname_res != R05_SUCCESS)
      return fname_res;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *ans = 0;
    if (FILE *f = fopen(&fname[0], "r")) {
      // Файл существует
      fclose(f);

      refalrts::alloc_name(ans, r05c_True, "True");
    } else {
      // Файл по-видимому не существует
      refalrts::alloc_name(ans, r05c_False, "False");
    }

    refalrts::splice_elem(res, ans);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1397 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_GetEnv(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 904 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    struct r05_node *eEnvName_b_1;
    struct r05_node *eEnvName_e_1;
    // e.EnvName
    eEnvName_b_1 = bb_0;
    eEnvName_e_1 = be_0;

    std::vector<char> envname;

    enum r05_fnresult envname_res =
      string_from_seq(envname, eEnvName_b_1, eEnvName_e_1);

    if (envname_res != R05_SUCCESS)
      return envname_res;

    r05_reset_allocator();

    const char *envres = getenv(& envname[0]);

    if (envres != 0) {
      struct r05_node *env_begin;
      struct r05_node *env_end;

      refalrts::alloc_string(env_begin, env_end, envres);

      refalrts::splice_evar(arg_begin, env_begin, env_end);

      //struct r05_node *char_pos;
      //
      //for (const char *env = envres; *env != '\0'; ++ env) {
      //  refalrts::alloc_char(char_pos, *env);
      //  refalrts::splice_elem(res, char_pos);
      //}
    }

    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1446 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_Exit(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 952 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sCode_1;
    // s.Code
    if (! r05_svar_left(&sCode_1, &bb_0, &be_0))
      break;
    if (sCode_1->tag != R05_DATATAG_NUMBER)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::set_return_code(sCode_1->info.number);

    r05_reset_allocator();
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_EXIT;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1474 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_System(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 979 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eCommand_b_1;
    struct r05_node *eCommand_e_1;
    // e.Command
    eCommand_b_1 = bb_0;
    eCommand_e_1 = be_0;

    std::vector<char> command;

    enum r05_fnresult read_res =
      string_from_seq(command, eCommand_b_1, eCommand_e_1);

    if (read_res != R05_SUCCESS)
      return read_res;

    fflush(stdout);
    fflush(stderr);

    system(&command[0]);

    r05_reset_allocator();
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1510 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_IntFromStr(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 1016 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eNumber_b_1;
    struct r05_node *eNumber_e_1;
    // e.NoNumber
    eNumber_b_1 = bb_0;
    eNumber_e_1 = be_0;

    bool start_is_digit =
      ! r05_empty_seq(eNumber_b_1, eNumber_e_1)
      && (R05_DATATAG_CHAR == eNumber_b_1->tag)
      && isdigit(eNumber_b_1->info.char_);

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    if (! start_is_digit) {
      struct r05_node *fail_pos = 0;
      refalrts::alloc_name(fail_pos, r05c_Fails, "Fails");

      res = refalrts::splice_evar(res, eNumber_b_1, eNumber_e_1);
      refalrts::splice_elem(res, fail_pos);
    } else {
      r05_number acc = 0;

      for ( ; ; ) {
        if (r05_empty_seq(eNumber_b_1, eNumber_e_1)) {
          break;
        } else if (eNumber_b_1->tag != R05_DATATAG_CHAR) {
          break;
        } else if (! isdigit(eNumber_b_1->info.char_)) {
          break;
        } else {
          (acc *= 10) += eNumber_b_1->info.char_ - '0';
        }

        r05_move_left(&eNumber_b_1, &eNumber_e_1);
      }

      struct r05_node *success_pos = 0;
      struct r05_node *number_pos = 0;

      refalrts::alloc_name(success_pos, r05c_Success, "Success");
      refalrts::alloc_number(number_pos, acc);

      res = refalrts::splice_evar(res, eNumber_b_1, eNumber_e_1);
      res = refalrts::splice_elem(res, number_pos);
      refalrts::splice_elem(res, success_pos);
    }

    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1574 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_StrFromInt(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 1079 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sNumber_1;
    // s.Number
    if (! r05_svar_left(&sNumber_1, &bb_0, &be_0))
      break;
    if (sNumber_1->tag != R05_DATATAG_NUMBER)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *char_pos = 0;
    if (r05_number num = sNumber_1->info.number) {
      // Длина десятичного числа = 0,3 * длина двоичного числа,
      // т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
      enum { cMaxNumberLen = 8 * sizeof(r05_number) * 3 / 10 + 2 };

      char buffer[cMaxNumberLen + 1] = { 0 };
      char *lim_digit = buffer + cMaxNumberLen;
      char *cur_digit = lim_digit;

      while (num != 0) {
        -- cur_digit;
        *cur_digit = static_cast<char>((num % 10) + '0');
        num /= 10;
      }

      struct r05_node *num_begin;
      struct r05_node *num_end;
      refalrts::alloc_chars(
        num_begin, num_end, cur_digit, unsigned(lim_digit - cur_digit)
      );

      refalrts::splice_evar(res, num_begin, num_end);
    } else {
      refalrts::alloc_char(char_pos, '0');
      refalrts::splice_elem(res, char_pos);
    }

    refalrts::splice_to_freelist(arg_begin, arg_end);

    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1631 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_Chr(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 1135 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sCode_1;
    // s.Code
    if (! r05_svar_left(&sCode_1, &bb_0, &be_0))
      break;
    if (sCode_1->tag != R05_DATATAG_NUMBER)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    char result = static_cast<char>(sCode_1->info.number);

    r05_reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    refalrts::alloc_char(n0, result);
    refalrts::splice_elem(res, n0);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1663 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}

enum r05_fnresult r05c_Ord(struct r05_node *arg_begin, struct r05_node *arg_end) {
#line 1166 "..\\lib/Library.ref"
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sChar_1;
    // s.Char
    if (! r05_svar_left(&sChar_1, &bb_0, &be_0))
      break;
    if (sChar_1->tag != R05_DATATAG_CHAR)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    r05_number result = static_cast<unsigned char>(sChar_1->info.char_);

    r05_reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    refalrts::alloc_number(n0, result);
    refalrts::splice_elem(res, n0);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
#line 1695 "..\\lib/Library.cpp"
  /* return R05_RECOGNITION_IMPOSSIBLE; */
}


/* End of file */
