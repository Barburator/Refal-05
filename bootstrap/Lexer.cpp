/* Automatically generated file. Don't edit! */
#include "refalrts.h"


extern enum r05_fnresult r05c_Mu(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Add(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Arg(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Br(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Card(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Chr(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Cp(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Dg(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Dgall(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Div(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Divmod(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Explode(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_First(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Get(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Implode(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Last(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Lenw(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Lower(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Mod(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Mul(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Numb(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Open(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Ord(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Print(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Prout(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Put(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Putout(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Rp(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Step(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Sub(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Symb(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Time(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Type(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Upper(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Sysfun(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Freeze(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Freezer(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Dn(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Up(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Ev_met(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Residue(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetEnv(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_System(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Exit(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Close(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ExistFile(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetCurrentDirectory(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_RemoveFile(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Implode_Ext(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Explode_Ext(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TimeElapsed(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Compare(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_DeSysfun(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_XMLParse(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Random(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_RandomDigit(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Write(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ListOfBuiltin(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_SizeOf(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetPID(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_int4fab_1(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GetPPID(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Map(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_LoadFile(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Inc(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Success(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Fails(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_EscapeChar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_lexer_FlatLine(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_LexFolding(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_SkipBOM(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkChar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkCloseCall(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkCloseBlock(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkCloseBracket(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkComma(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkDirective(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkEOF(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkError(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkName(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkNative(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkNumber(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkOpenCall(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkOpenBlock(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkOpenBracket(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkReplace(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkSemicolon(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkUnexpected(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkVariable(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_EEnum(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Entry(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Enum(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Extern(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_Inc2(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_Scan(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanPseudo(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanPseudo_SwDirective(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanPseudo_AddSemicolon(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanCComment(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanCCommentContent(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanNative(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanDirective(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_MakeDirective(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_Directive(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_MakeDirective_SwValid(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanChars(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanChars_Escape(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanChars_Escape_Hex(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanChars_Escape_Hex_SwHex(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_Escape(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanChars_Escape_SwValid(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanVariable(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_Punctuation(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_Scan_ByPunctuation(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_Scan_ByType(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_GlueUnexpecteds(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanName(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_ScanNumber(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_StrDirective(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkOpen(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_TkClose(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_StrFromToken(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_DigitFromChar(struct r05_node *arg_begin, struct r05_node *arg_end);

enum r05_fnresult r05c_lexer_FlatLine(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *eLine_b_1;
    struct r05_node *eLine_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* ( e.Line  ) */
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;
    eLine_b_1 = bb[1];
    eLine_e_1 = be[1];

    r05_reset_allocator();
    r05_alloc_insert_pos(n[0]);
    r05_alloc_char('\n');
    r05_splice_evar(n[0], eLine_b_1, eLine_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_LexFolding(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *eFileName_b_1;
    struct r05_node *eFileName_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* e.FileName */
    eFileName_b_1 = bb[0];
    eFileName_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_number(1UL);
    r05_alloc_number(1UL);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_SkipBOM, "SkipBOM");
    r05_alloc_open_call(n[2]);
    r05_alloc_function(r05c_Map, "Map");
    r05_alloc_function(r05c_lexer_FlatLine, "lexer_FlatLine");
    r05_alloc_open_call(n[3]);
    r05_alloc_function(r05c_LoadFile, "LoadFile");
    r05_alloc_insert_pos(n[4]);
    r05_alloc_close_call(n[5]);
    r05_alloc_close_call(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[0]);
    r05_push_stack(n[7]);
    r05_push_stack(n[1]);
    r05_push_stack(n[6]);
    r05_push_stack(n[2]);
    r05_push_stack(n[5]);
    r05_push_stack(n[3]);
    r05_splice_evar(n[4], eFileName_b_1, eFileName_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_SkipBOM(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *eContent_b_1;
    struct r05_node *eContent_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '\357\273\277' e.Content */
    if (! r05_char_left('\357', &bb[0], &be[0]))
      break;
    if (! r05_char_left('\273', &bb[0], &be[0]))
      break;
    if (! r05_char_left('\277', &bb[0], &be[0]))
      break;
    eContent_b_1 = bb[0];
    eContent_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_insert_pos(n[0]);
    r05_splice_evar(n[0], eContent_b_1, eContent_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *eContent_b_1;
    struct r05_node *eContent_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* e.Content */
    eContent_b_1 = bb[0];
    eContent_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_insert_pos(n[0]);
    r05_splice_evar(n[0], eContent_b_1, eContent_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkChar(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkCloseCall(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkCloseBlock(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkCloseBracket(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkComma(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkDirective(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkEOF(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkError(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkName(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkNative(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkNumber(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkOpenCall(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkOpenBlock(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkOpenBracket(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkReplace(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkSemicolon(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkUnexpected(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkVariable(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_EEnum(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Entry(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Enum(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_Extern(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_Inc2(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sNum_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[2] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Num */
    if (! r05_svar_left(&sNum_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Add, "Add");
    r05_alloc_number(2UL);
    r05_alloc_svar(sNum_1);
    r05_alloc_close_call(n[1]);
    r05_push_stack(n[1]);
    r05_push_stack(n[0]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_Scan(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ' ' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left(' ', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '\t' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('\t', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '\n' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('\n', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sRow_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_number(1UL);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *ePseudo_b_1;
    struct r05_node *ePseudo_e_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[12] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row 1 '*$' e.Pseudo '\n' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_number_left(1UL, &bb[0], &be[0]))
      break;
    if (! r05_char_left('*', &bb[0], &be[0]))
      break;
    if (! r05_char_left('$', &bb[0], &be[0]))
      break;
    ePseudo_b_1 = 0;
    ePseudo_e_1 = 0;
    r05_start_e_loop();
    do {
      bb[1] = bb[0];
      be[1] = be[0];
      if (! r05_char_left('\n', &bb[1], &be[1]))
        continue;
      eTail_b_1 = bb[1];
      eTail_e_1 = be[1];

      r05_reset_allocator();
      r05_alloc_open_call(n[0]);
      r05_alloc_function(r05c_ScanPseudo, "ScanPseudo");
      r05_alloc_svar(sRow_1);
      r05_alloc_number(3UL);
      r05_alloc_open_bracket(n[1]);
      r05_alloc_close_bracket(n[2]);
      r05_alloc_open_call(n[3]);
      r05_alloc_function(r05c_Type, "Type");
      r05_alloc_insert_pos(n[4]);
      r05_alloc_char('\n');
      r05_alloc_close_call(n[5]);
      r05_alloc_close_call(n[6]);
      r05_alloc_open_call(n[7]);
      r05_alloc_function(r05c_Scan, "Scan");
      r05_alloc_open_call(n[8]);
      r05_alloc_function(r05c_Inc, "Inc");
      r05_alloc_svar(sRow_1);
      r05_alloc_close_call(n[9]);
      r05_alloc_number(1UL);
      r05_alloc_insert_pos(n[10]);
      r05_alloc_close_call(n[11]);
      r05_push_stack(n[11]);
      r05_push_stack(n[7]);
      r05_push_stack(n[9]);
      r05_push_stack(n[8]);
      r05_push_stack(n[6]);
      r05_push_stack(n[0]);
      r05_push_stack(n[5]);
      r05_push_stack(n[3]);
      r05_link_brackets(n[1], n[2]);
      r05_splice_evar(n[4], ePseudo_b_1, ePseudo_e_1);
      r05_splice_evar(n[10], eTail_b_1, eTail_e_1);
      r05_splice_from_freelist(arg_begin);
      r05_splice_to_freelist(arg_begin, arg_end);
      return R05_SUCCESS;
    } while (r05_open_evar_advance(&ePseudo_b_1, &ePseudo_e_1, &bb[0], &be[0]));
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *eComment_b_1;
    struct r05_node *eComment_e_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row 1 '*' e.Comment '\n' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_number_left(1UL, &bb[0], &be[0]))
      break;
    if (! r05_char_left('*', &bb[0], &be[0]))
      break;
    eComment_b_1 = 0;
    eComment_e_1 = 0;
    r05_start_e_loop();
    do {
      bb[1] = bb[0];
      be[1] = be[0];
      if (! r05_char_left('\n', &bb[1], &be[1]))
        continue;
      eTail_b_1 = bb[1];
      eTail_e_1 = be[1];

      r05_reset_allocator();
      r05_alloc_open_call(n[0]);
      r05_alloc_function(r05c_Scan, "Scan");
      r05_alloc_open_call(n[1]);
      r05_alloc_function(r05c_Inc, "Inc");
      r05_alloc_svar(sRow_1);
      r05_alloc_close_call(n[2]);
      r05_alloc_number(1UL);
      r05_alloc_insert_pos(n[3]);
      r05_alloc_close_call(n[4]);
      r05_push_stack(n[4]);
      r05_push_stack(n[0]);
      r05_push_stack(n[2]);
      r05_push_stack(n[1]);
      r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
      r05_splice_from_freelist(arg_begin);
      r05_splice_to_freelist(arg_begin, arg_end);
      return R05_SUCCESS;
    } while (r05_open_evar_advance(&eComment_b_1, &eComment_e_1, &bb[0], &be[0]));
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '/' '*' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('/', &bb[0], &be[0]))
      break;
    if (! r05_char_left('*', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanCComment, "ScanCComment");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc2, "Inc2");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[7] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row 1 '%%\n' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_number_left(1UL, &bb[0], &be[0]))
      break;
    if (! r05_char_left('%', &bb[0], &be[0]))
      break;
    if (! r05_char_left('%', &bb[0], &be[0]))
      break;
    if (! r05_char_left('\n', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanNative, "ScanNative");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sRow_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_insert_pos(n[5]);
    r05_alloc_close_call(n[6]);
    r05_push_stack(n[6]);
    r05_push_stack(n[0]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[5], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '$' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('$', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanDirective, "ScanDirective");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[0]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '\'' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('\'', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanChars, "ScanChars");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col 'e.' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('e', &bb[0], &be[0]))
      break;
    if (! r05_char_left('.', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanVariable, "ScanVariable");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc2, "Inc2");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_char('e');
    r05_alloc_open_bracket(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[0]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col 's.' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('s', &bb[0], &be[0]))
      break;
    if (! r05_char_left('.', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanVariable, "ScanVariable");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc2, "Inc2");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_char('s');
    r05_alloc_open_bracket(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[0]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col 't.' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('t', &bb[0], &be[0]))
      break;
    if (! r05_char_left('.', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanVariable, "ScanVariable");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc2, "Inc2");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_char('t');
    r05_alloc_open_bracket(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[0]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sNext_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Next e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sNext_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan_ByPunctuation, "Scan_ByPunctuation");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Punctuation, "Punctuation");
    r05_alloc_svar(sNext_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[4] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkEOF, "TkEOF");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_close_bracket(n[3]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanPseudo(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eScanned_b_1;
    struct r05_node *eScanned_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sLetter_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Scanned  ) 'L' s.SubType s.Letter e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('L', &bb[0], &be[0]))
      break;
    eScanned_b_1 = bb[1];
    eScanned_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sLetter_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanPseudo, "ScanPseudo");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sLetter_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eScanned_b_1, eScanned_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eScanned_b_1;
    struct r05_node *eScanned_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Scanned  ) 'D' s.SubType s.Digit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('D', &bb[0], &be[0]))
      break;
    eScanned_b_1 = bb[1];
    eScanned_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanPseudo, "ScanPseudo");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sDigit_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eScanned_b_1, eScanned_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eScanned_b_1;
    struct r05_node *eScanned_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Scanned  ) s.Type s.SubType e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eScanned_b_1 = bb[1];
    eScanned_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanPseudo_SwDirective, "ScanPseudo_SwDirective");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_bracket(n[1]);
    r05_alloc_open_call(n[2]);
    r05_alloc_function(r05c_Directive, "Directive");
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_push_stack(n[7]);
    r05_push_stack(n[0]);
    r05_link_brackets(n[1], n[5]);
    r05_push_stack(n[4]);
    r05_push_stack(n[2]);
    r05_splice_evar(n[3], eScanned_b_1, eScanned_e_1);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanPseudo_SwDirective(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *sDirective_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( & Success s.Directive  ) e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Success, &bb[1], &be[1]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];
    if (! r05_svar_left(&sDirective_1, &bb[1], &be[1]))
      break;
    if (! r05_empty_seq(bb[1], be[1]))
      break;

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkDirective, "TkDirective");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_number(2UL);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_svar(sDirective_1);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_ScanPseudo_AddSemicolon, "ScanPseudo_AddSemicolon");
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[4]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( & Fails e.Directive  ) e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Fails, &bb[1], &be[1]))
      break;
    /* Unused closed variable e.Directive*/
    /* Unused closed variable e.Tail*/

    r05_reset_allocator();
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanPseudo_AddSemicolon(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *eTokens_b_1;
    struct r05_node *eTokens_e_1;
    struct r05_node *tSrcPos_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[4] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* e.Tokens ( & TkEOF t.SrcPos  ) */
    if (! r05_brackets_right(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_TkEOF, &bb[1], &be[1]))
      break;
    eTokens_b_1 = bb[0];
    eTokens_e_1 = be[0];
    if (! r05_tvar_left(&tSrcPos_1, &bb[1], &be[1]))
      break;
    if (! r05_empty_seq(bb[1], be[1]))
      break;

    r05_reset_allocator();
    r05_alloc_insert_pos(n[0]);
    r05_alloc_open_bracket(n[1]);
    r05_alloc_function(r05c_TkSemicolon, "TkSemicolon");
    r05_alloc_insert_pos(n[2]);
    r05_alloc_close_bracket(n[3]);
    r05_link_brackets(n[1], n[3]);
    r05_splice_evar(n[0], eTokens_b_1, eTokens_e_1);
    r05_splice_tvar(n[2], tSrcPos_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanCComment(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eComment_b_1;
    struct r05_node *eComment_e_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[6] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col e.Comment '*' '/' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    eComment_b_1 = 0;
    eComment_e_1 = 0;
    r05_start_e_loop();
    do {
      bb[1] = bb[0];
      be[1] = be[0];
      if (! r05_char_left('*', &bb[1], &be[1]))
        continue;
      if (! r05_char_left('/', &bb[1], &be[1]))
        continue;
      eTail_b_1 = bb[1];
      eTail_e_1 = be[1];

      r05_reset_allocator();
      r05_alloc_open_call(n[0]);
      r05_alloc_function(r05c_ScanCCommentContent, "ScanCCommentContent");
      r05_alloc_svar(sRow_1);
      r05_alloc_svar(sCol_1);
      r05_alloc_open_bracket(n[1]);
      r05_alloc_insert_pos(n[2]);
      r05_alloc_chars("*/", 2);
      r05_alloc_close_bracket(n[3]);
      r05_alloc_insert_pos(n[4]);
      r05_alloc_close_call(n[5]);
      r05_push_stack(n[5]);
      r05_push_stack(n[0]);
      r05_link_brackets(n[1], n[3]);
      r05_splice_evar(n[2], eComment_b_1, eComment_e_1);
      r05_splice_evar(n[4], eTail_b_1, eTail_e_1);
      r05_splice_from_freelist(arg_begin);
      r05_splice_to_freelist(arg_begin, arg_end);
      return R05_SUCCESS;
    } while (r05_open_evar_advance(&eComment_b_1, &eComment_e_1, &bb[0], &be[0]));
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eLine_b_1;
    struct r05_node *eLine_e_1;
    struct r05_node *eComment_b_1;
    struct r05_node *eComment_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col e.Line '\n' e.Comment */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    eLine_b_1 = 0;
    eLine_e_1 = 0;
    r05_start_e_loop();
    do {
      bb[1] = bb[0];
      be[1] = be[0];
      if (! r05_char_left('\n', &bb[1], &be[1]))
        continue;
      eComment_b_1 = bb[1];
      eComment_e_1 = be[1];

      r05_reset_allocator();
      r05_alloc_open_call(n[0]);
      r05_alloc_function(r05c_ScanCComment, "ScanCComment");
      r05_alloc_open_call(n[1]);
      r05_alloc_function(r05c_Inc, "Inc");
      r05_alloc_svar(sRow_1);
      r05_alloc_close_call(n[2]);
      r05_alloc_number(1UL);
      r05_alloc_insert_pos(n[3]);
      r05_alloc_close_call(n[4]);
      r05_push_stack(n[4]);
      r05_push_stack(n[0]);
      r05_push_stack(n[2]);
      r05_push_stack(n[1]);
      r05_splice_evar(n[3], eComment_b_1, eComment_e_1);
      r05_splice_from_freelist(arg_begin);
      r05_splice_to_freelist(arg_begin, arg_end);
      return R05_SUCCESS;
    } while (r05_open_evar_advance(&eLine_b_1, &eLine_e_1, &bb[0], &be[0]));
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkError, "TkError");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_chars("EOF in comment", 14);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_bracket(n[4]);
    r05_alloc_function(r05c_TkEOF, "TkEOF");
    r05_alloc_open_bracket(n[5]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[6]);
    r05_alloc_close_bracket(n[7]);
    r05_link_brackets(n[4], n[7]);
    r05_link_brackets(n[5], n[6]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanCCommentContent(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *eLine_b_1;
    struct r05_node *eLine_e_1;
    struct r05_node *eComment_b_1;
    struct r05_node *eComment_e_1;
    struct r05_node *bb[3] = { 0 };
    struct r05_node *be[3] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Line '\n' e.Comment  ) e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];
    eLine_b_1 = 0;
    eLine_e_1 = 0;
    r05_start_e_loop();
    do {
      bb[2] = bb[1];
      be[2] = be[1];
      if (! r05_char_left('\n', &bb[2], &be[2]))
        continue;
      eComment_b_1 = bb[2];
      eComment_e_1 = be[2];

      r05_reset_allocator();
      r05_alloc_open_call(n[0]);
      r05_alloc_function(r05c_ScanCCommentContent, "ScanCCommentContent");
      r05_alloc_open_call(n[1]);
      r05_alloc_function(r05c_Inc, "Inc");
      r05_alloc_svar(sRow_1);
      r05_alloc_close_call(n[2]);
      r05_alloc_number(1UL);
      r05_alloc_open_bracket(n[3]);
      r05_alloc_insert_pos(n[4]);
      r05_alloc_close_bracket(n[5]);
      r05_alloc_insert_pos(n[6]);
      r05_alloc_close_call(n[7]);
      r05_push_stack(n[7]);
      r05_push_stack(n[0]);
      r05_link_brackets(n[3], n[5]);
      r05_push_stack(n[2]);
      r05_push_stack(n[1]);
      r05_splice_evar(n[4], eComment_b_1, eComment_e_1);
      r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
      r05_splice_from_freelist(arg_begin);
      r05_splice_to_freelist(arg_begin, arg_end);
      return R05_SUCCESS;
    } while (r05_open_evar_advance(&eLine_b_1, &eLine_e_1, &bb[1], &be[1]));
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *sChar_1;
    struct r05_node *eComment_b_1;
    struct r05_node *eComment_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( s.Char e.Comment  ) e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];
    if (! r05_svar_left(&sChar_1, &bb[1], &be[1]))
      break;
    eComment_b_1 = bb[1];
    eComment_e_1 = be[1];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanCCommentContent, "ScanCCommentContent");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_push_stack(n[7]);
    r05_push_stack(n[0]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eComment_b_1, eComment_e_1);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[3] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col (  ) e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[1], be[1]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[1]);
    r05_alloc_close_call(n[2]);
    r05_push_stack(n[2]);
    r05_push_stack(n[0]);
    r05_splice_evar(n[1], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanNative(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sStartRow_1;
    struct r05_node *sRow_1;
    struct r05_node *eNative_b_1;
    struct r05_node *eNative_e_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.StartRow s.Row ( e.Native  ) '%%\n' e.Tail */
    if (! r05_svar_left(&sStartRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('%', &bb[0], &be[0]))
      break;
    if (! r05_char_left('%', &bb[0], &be[0]))
      break;
    if (! r05_char_left('\n', &bb[0], &be[0]))
      break;
    eNative_b_1 = bb[1];
    eNative_e_1 = be[1];
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkNative, "TkNative");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sStartRow_1);
    r05_alloc_number(1UL);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sRow_1);
    r05_alloc_close_call(n[7]);
    r05_alloc_number(1UL);
    r05_alloc_insert_pos(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[5]);
    r05_push_stack(n[7]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[0], n[4]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[3], eNative_b_1, eNative_e_1);
    r05_splice_evar(n[8], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sStartRow_1;
    struct r05_node *sRow_1;
    struct r05_node *eNative_b_1;
    struct r05_node *eNative_e_1;
    struct r05_node *eLine_b_1;
    struct r05_node *eLine_e_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[3] = { 0 };
    struct r05_node *be[3] = { 0 };
    struct r05_node *n[11] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.StartRow s.Row ( e.Native  ) e.Line '\n' e.Tail */
    if (! r05_svar_left(&sStartRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eNative_b_1 = bb[1];
    eNative_e_1 = be[1];
    eLine_b_1 = 0;
    eLine_e_1 = 0;
    r05_start_e_loop();
    do {
      bb[2] = bb[0];
      be[2] = be[0];
      if (! r05_char_left('\n', &bb[2], &be[2]))
        continue;
      eTail_b_1 = bb[2];
      eTail_e_1 = be[2];

      r05_reset_allocator();
      r05_alloc_open_call(n[0]);
      r05_alloc_function(r05c_ScanNative, "ScanNative");
      r05_alloc_svar(sStartRow_1);
      r05_alloc_open_call(n[1]);
      r05_alloc_function(r05c_Inc, "Inc");
      r05_alloc_svar(sRow_1);
      r05_alloc_close_call(n[2]);
      r05_alloc_open_bracket(n[3]);
      r05_alloc_insert_pos(n[4]);
      r05_alloc_open_bracket(n[5]);
      r05_alloc_insert_pos(n[6]);
      r05_alloc_close_bracket(n[7]);
      r05_alloc_close_bracket(n[8]);
      r05_alloc_insert_pos(n[9]);
      r05_alloc_close_call(n[10]);
      r05_push_stack(n[10]);
      r05_push_stack(n[0]);
      r05_link_brackets(n[3], n[8]);
      r05_link_brackets(n[5], n[7]);
      r05_push_stack(n[2]);
      r05_push_stack(n[1]);
      r05_splice_evar(n[4], eNative_b_1, eNative_e_1);
      r05_splice_evar(n[6], eLine_b_1, eLine_e_1);
      r05_splice_evar(n[9], eTail_b_1, eTail_e_1);
      r05_splice_from_freelist(arg_begin);
      r05_splice_to_freelist(arg_begin, arg_end);
      return R05_SUCCESS;
    } while (r05_open_evar_advance(&eLine_b_1, &eLine_e_1, &bb[0], &be[0]));
  } while (0);

  do {
    struct r05_node *eNative_b_1;
    struct r05_node *eNative_e_1;
    struct r05_node *sStartRow_1;
    struct r05_node *sRow_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[13] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.StartRow s.Row ( e.Native  ) */
    if (! r05_brackets_right(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eNative_b_1 = bb[1];
    eNative_e_1 = be[1];
    if (! r05_svar_left(&sStartRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkNative, "TkNative");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sStartRow_1);
    r05_alloc_number(1UL);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_bracket(n[5]);
    r05_alloc_function(r05c_TkError, "TkError");
    r05_alloc_open_bracket(n[6]);
    r05_alloc_svar(sRow_1);
    r05_alloc_number(1UL);
    r05_alloc_close_bracket(n[7]);
    r05_alloc_chars("unclosed native code", 20);
    r05_alloc_close_bracket(n[8]);
    r05_alloc_open_bracket(n[9]);
    r05_alloc_function(r05c_TkEOF, "TkEOF");
    r05_alloc_open_bracket(n[10]);
    r05_alloc_svar(sRow_1);
    r05_alloc_number(1UL);
    r05_alloc_close_bracket(n[11]);
    r05_alloc_close_bracket(n[12]);
    r05_link_brackets(n[9], n[12]);
    r05_link_brackets(n[10], n[11]);
    r05_link_brackets(n[5], n[8]);
    r05_link_brackets(n[6], n[7]);
    r05_link_brackets(n[0], n[4]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[3], eNative_b_1, eNative_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanDirective(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eScanned_b_1;
    struct r05_node *eScanned_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sLetter_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Scanned  ) 'L' s.SubType s.Letter e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('L', &bb[0], &be[0]))
      break;
    eScanned_b_1 = bb[1];
    eScanned_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sLetter_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanDirective, "ScanDirective");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sLetter_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eScanned_b_1, eScanned_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eScanned_b_1;
    struct r05_node *eScanned_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Scanned  ) 'D' s.SubType s.Digit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('D', &bb[0], &be[0]))
      break;
    eScanned_b_1 = bb[1];
    eScanned_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanDirective, "ScanDirective");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sDigit_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eScanned_b_1, eScanned_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eScanned_b_1;
    struct r05_node *eScanned_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[6] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Scanned  ) s.Type s.SubType e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eScanned_b_1 = bb[1];
    eScanned_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_MakeDirective, "MakeDirective");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[1]);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_call(n[3]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_close_call(n[5]);
    r05_push_stack(n[5]);
    r05_push_stack(n[3]);
    r05_push_stack(n[2]);
    r05_push_stack(n[0]);
    r05_splice_evar(n[1], eScanned_b_1, eScanned_e_1);
    r05_splice_evar(n[4], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_MakeDirective(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eDirective_b_1;
    struct r05_node *eDirective_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col e.Directive */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    eDirective_b_1 = bb[0];
    eDirective_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_MakeDirective_SwValid, "MakeDirective_SwValid");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Directive, "Directive");
    r05_alloc_insert_pos(n[2]);
    r05_alloc_close_call(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[3]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[2], eDirective_b_1, eDirective_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_Directive(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'ENUM' */
    if (! r05_char_left('E', &bb[0], &be[0]))
      break;
    if (! r05_char_left('N', &bb[0], &be[0]))
      break;
    if (! r05_char_left('U', &bb[0], &be[0]))
      break;
    if (! r05_char_left('M', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_Enum, "Enum");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'EENUM' */
    if (! r05_char_left('E', &bb[0], &be[0]))
      break;
    if (! r05_char_left('E', &bb[0], &be[0]))
      break;
    if (! r05_char_left('N', &bb[0], &be[0]))
      break;
    if (! r05_char_left('U', &bb[0], &be[0]))
      break;
    if (! r05_char_left('M', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_EEnum, "EEnum");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'ENTRY' */
    if (! r05_char_left('E', &bb[0], &be[0]))
      break;
    if (! r05_char_left('N', &bb[0], &be[0]))
      break;
    if (! r05_char_left('T', &bb[0], &be[0]))
      break;
    if (! r05_char_left('R', &bb[0], &be[0]))
      break;
    if (! r05_char_left('Y', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_Entry, "Entry");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'EXTERN' */
    if (! r05_char_left('E', &bb[0], &be[0]))
      break;
    if (! r05_char_left('X', &bb[0], &be[0]))
      break;
    if (! r05_char_left('T', &bb[0], &be[0]))
      break;
    if (! r05_char_left('E', &bb[0], &be[0]))
      break;
    if (! r05_char_left('R', &bb[0], &be[0]))
      break;
    if (! r05_char_left('N', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_Extern, "Extern");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *eOther_b_1;
    struct r05_node *eOther_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* e.Other */
    eOther_b_1 = bb[0];
    eOther_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_function(r05c_Fails, "Fails");
    r05_alloc_insert_pos(n[0]);
    r05_splice_evar(n[0], eOther_b_1, eOther_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_MakeDirective_SwValid(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sDirective_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[4] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col & Success s.Directive */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Success, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDirective_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkDirective, "TkDirective");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_svar(sDirective_1);
    r05_alloc_close_bracket(n[3]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eOther_b_1;
    struct r05_node *eOther_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col & Fails e.Other */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Fails, &bb[0], &be[0]))
      break;
    eOther_b_1 = bb[0];
    eOther_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkError, "TkError");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_chars("Unknown directive $", 19);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_link_brackets(n[0], n[4]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[3], eOther_b_1, eOther_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanChars(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '\'' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('\'', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[7] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '\n' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('\n', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkError, "TkError");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_chars("unclosed quote", 14);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_char('\n');
    r05_alloc_insert_pos(n[5]);
    r05_alloc_close_call(n[6]);
    r05_push_stack(n[6]);
    r05_push_stack(n[4]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[5], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col '\\' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('\\', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanChars_Escape, "ScanChars_Escape");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sOther_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Other e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sOther_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkChar, "TkChar");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_svar(sOther_1);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_ScanChars, "ScanChars");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[6]);
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[4]);
    r05_push_stack(n[6]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanChars_Escape(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[7] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col 'x' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('x', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanChars_Escape_Hex, "ScanChars_Escape_Hex");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_insert_pos(n[5]);
    r05_alloc_close_call(n[6]);
    r05_push_stack(n[6]);
    r05_push_stack(n[0]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[5], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sNext_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Next e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sNext_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanChars_Escape_SwValid, "ScanChars_Escape_SwValid");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Escape, "Escape");
    r05_alloc_svar(sNext_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[3], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanChars_Escape_Hex(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *sH1_1;
    struct r05_node *sH2_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[13] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( s.H1 s.H2  ) e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];
    if (! r05_svar_left(&sH1_1, &bb[1], &be[1]))
      break;
    if (! r05_svar_left(&sH2_1, &bb[1], &be[1]))
      break;
    if (! r05_empty_seq(bb[1], be[1]))
      break;

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkChar, "TkChar");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_open_call(n[3]);
    r05_alloc_function(r05c_Chr, "Chr");
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_Add, "Add");
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Mul, "Mul");
    r05_alloc_svar(sH1_1);
    r05_alloc_number(16UL);
    r05_alloc_close_call(n[6]);
    r05_alloc_svar(sH2_1);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_bracket(n[9]);
    r05_alloc_open_call(n[10]);
    r05_alloc_function(r05c_ScanChars, "ScanChars");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[11]);
    r05_alloc_close_call(n[12]);
    r05_push_stack(n[12]);
    r05_push_stack(n[10]);
    r05_link_brackets(n[0], n[9]);
    r05_push_stack(n[8]);
    r05_push_stack(n[3]);
    r05_push_stack(n[7]);
    r05_push_stack(n[4]);
    r05_push_stack(n[6]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[11], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eDigits_b_1;
    struct r05_node *eDigits_e_1;
    struct r05_node *sNext_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Digits  ) s.Next e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eDigits_b_1 = bb[1];
    eDigits_e_1 = be[1];
    if (! r05_svar_left(&sNext_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanChars_Escape_Hex_SwHex, "ScanChars_Escape_Hex_SwHex");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_bracket(n[1]);
    r05_alloc_insert_pos(n[2]);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_DigitFromChar, "DigitFromChar");
    r05_alloc_svar(sNext_1);
    r05_alloc_close_call(n[5]);
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_push_stack(n[7]);
    r05_push_stack(n[0]);
    r05_push_stack(n[5]);
    r05_push_stack(n[4]);
    r05_link_brackets(n[1], n[3]);
    r05_splice_evar(n[2], eDigits_b_1, eDigits_e_1);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanChars_Escape_Hex_SwHex(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sNoDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[7] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Digits  ) & Fails s.NoDigit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Fails, &bb[0], &be[0]))
      break;
    /* Unused closed variable e.Digits*/
    if (! r05_svar_left(&sNoDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkError, "TkError");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_chars("bad hex escape sequence \"\\x...\"", 31);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_ScanChars, "ScanChars");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_svar(sNoDigit_1);
    r05_alloc_insert_pos(n[5]);
    r05_alloc_close_call(n[6]);
    r05_push_stack(n[6]);
    r05_push_stack(n[4]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[5], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eDigits_b_1;
    struct r05_node *eDigits_e_1;
    struct r05_node *sDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col ( e.Digits  ) s.Digit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eDigits_b_1 = bb[1];
    eDigits_e_1 = be[1];
    if (! r05_svar_left(&sDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanChars_Escape_Hex, "ScanChars_Escape_Hex");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sDigit_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_push_stack(n[7]);
    r05_push_stack(n[0]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eDigits_b_1, eDigits_e_1);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_Escape(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'n' */
    if (! r05_char_left('n', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('\n');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 't' */
    if (! r05_char_left('t', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('\t');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'r' */
    if (! r05_char_left('r', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('\r');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '\\' */
    if (! r05_char_left('\\', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('\\');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '\'' */
    if (! r05_char_left('\'', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('\'');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '\"' */
    if (! r05_char_left('\"', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('\"');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '<' */
    if (! r05_char_left('<', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('<');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '>' */
    if (! r05_char_left('>', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('>');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '(' */
    if (! r05_char_left('(', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char('(');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* ')' */
    if (! r05_char_left(')', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_char(')');
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sOther_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Other */
    if (! r05_svar_left(&sOther_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Fails, "Fails");
    r05_alloc_svar(sOther_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanChars_Escape_SwValid(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sValue_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col & Success s.Value e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Success, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sValue_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkChar, "TkChar");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_svar(sValue_1);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_ScanChars, "ScanChars");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[6]);
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[4]);
    r05_push_stack(n[6]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sOther_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[7] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col & Fails s.Other e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Fails, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sOther_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkError, "TkError");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_chars("bad escape sequence \"\\", 22);
    r05_alloc_svar(sOther_1);
    r05_alloc_char('\"');
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_ScanChars, "ScanChars");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_svar(sOther_1);
    r05_alloc_insert_pos(n[5]);
    r05_alloc_close_call(n[6]);
    r05_push_stack(n[6]);
    r05_push_stack(n[4]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[5], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanVariable(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sMode_1;
    struct r05_node *eIndex_b_1;
    struct r05_node *eIndex_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sLetter_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Mode ( e.Index  ) 'L' s.SubType s.Letter e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sMode_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('L', &bb[0], &be[0]))
      break;
    eIndex_b_1 = bb[1];
    eIndex_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sLetter_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanVariable, "ScanVariable");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_svar(sMode_1);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sLetter_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eIndex_b_1, eIndex_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sMode_1;
    struct r05_node *eIndex_b_1;
    struct r05_node *eIndex_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Mode ( e.Index  ) 'D' s.SubType s.Digit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sMode_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('D', &bb[0], &be[0]))
      break;
    eIndex_b_1 = bb[1];
    eIndex_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanVariable, "ScanVariable");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_svar(sMode_1);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sDigit_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eIndex_b_1, eIndex_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sMode_1;
    struct r05_node *eIndex_b_1;
    struct r05_node *eIndex_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Mode ( e.Index  ) s.Type s.SubType '-' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sMode_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eIndex_b_1 = bb[1];
    eIndex_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('-', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanVariable, "ScanVariable");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_svar(sMode_1);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_char('_');
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eIndex_b_1, eIndex_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sMode_1;
    struct r05_node *eIndex_b_1;
    struct r05_node *eIndex_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Mode ( e.Index  ) s.Type s.SubType '_' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sMode_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eIndex_b_1 = bb[1];
    eIndex_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('_', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanVariable, "ScanVariable");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_svar(sMode_1);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_char('_');
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eIndex_b_1, eIndex_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sMode_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[7] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Mode (  ) s.Type s.SubType e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sMode_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[1], be[1]))
      break;
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkError, "TkError");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_chars("empty index in variable \"", 25);
    r05_alloc_svar(sMode_1);
    r05_alloc_chars(".\"", 2);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[5]);
    r05_alloc_close_call(n[6]);
    r05_push_stack(n[6]);
    r05_push_stack(n[4]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[5], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sMode_1;
    struct r05_node *eIndex_b_1;
    struct r05_node *eIndex_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Mode ( e.Index  ) s.Type s.SubType e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sMode_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eIndex_b_1 = bb[1];
    eIndex_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkVariable, "TkVariable");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_svar(sMode_1);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[0], n[4]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[3], eIndex_b_1, eIndex_e_1);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_Punctuation(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '(' */
    if (! r05_char_left('(', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkOpenBracket, "TkOpenBracket");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* ')' */
    if (! r05_char_left(')', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkCloseBracket, "TkCloseBracket");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* ',' */
    if (! r05_char_left(',', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkComma, "TkComma");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* ';' */
    if (! r05_char_left(';', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkSemicolon, "TkSemicolon");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '<' */
    if (! r05_char_left('<', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkOpenCall, "TkOpenCall");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '=' */
    if (! r05_char_left('=', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkReplace, "TkReplace");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '>' */
    if (! r05_char_left('>', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkCloseCall, "TkCloseCall");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '{' */
    if (! r05_char_left('{', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkOpenBlock, "TkOpenBlock");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '}' */
    if (! r05_char_left('}', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Success, "Success");
    r05_alloc_function(r05c_TkCloseBlock, "TkCloseBlock");
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sOther_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Other */
    if (! r05_svar_left(&sOther_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Fails, "Fails");
    r05_alloc_svar(sOther_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_Scan_ByPunctuation(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sToken_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col & Success s.Token e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Success, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sToken_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_svar(sToken_1);
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_open_call(n[4]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[6]);
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[4]);
    r05_push_stack(n[6]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[0], n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col & Fails e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_Fails, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Scan_ByType, "Scan_ByType");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[2]);
    r05_alloc_close_call(n[3]);
    r05_alloc_close_call(n[4]);
    r05_push_stack(n[4]);
    r05_push_stack(n[0]);
    r05_push_stack(n[3]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[2], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_Scan_ByType(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sSubType_1;
    struct r05_node *sLetter_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col 'L' s.SubType s.Letter e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('L', &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sLetter_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanName, "ScanName");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_svar(sLetter_1);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[0]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sSubType_1;
    struct r05_node *sDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[9] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col 'D' s.SubType s.Digit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('D', &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanNumber, "ScanNumber");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_svar(sDigit_1);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_alloc_close_call(n[8]);
    r05_push_stack(n[8]);
    r05_push_stack(n[0]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[3], n[4]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sCol_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *sUnexpected_1;
    struct r05_node *eText_b_1;
    struct r05_node *eText_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[11] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.Col s.Type s.SubType s.Unexpected e.Text */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sUnexpected_1, &bb[0], &be[0]))
      break;
    eText_b_1 = bb[0];
    eText_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_GlueUnexpecteds, "GlueUnexpecteds");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_function(r05c_TkUnexpected, "TkUnexpected");
    r05_alloc_open_bracket(n[2]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_svar(sUnexpected_1);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[7]);
    r05_alloc_insert_pos(n[8]);
    r05_alloc_close_call(n[9]);
    r05_alloc_close_call(n[10]);
    r05_push_stack(n[10]);
    r05_push_stack(n[0]);
    r05_push_stack(n[9]);
    r05_push_stack(n[5]);
    r05_push_stack(n[7]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[1], n[4]);
    r05_link_brackets(n[2], n[3]);
    r05_splice_evar(n[8], eText_b_1, eText_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_GlueUnexpecteds(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *eTokens_b_1;
    struct r05_node *eTokens_e_1;
    struct r05_node *tSrcPos1_1;
    struct r05_node *sUnexpected1_1;
    struct r05_node *tSrcPos2_1;
    struct r05_node *eUnexpected2_b_1;
    struct r05_node *eUnexpected2_e_1;
    struct r05_node *bb[3] = { 0 };
    struct r05_node *be[3] = { 0 };
    struct r05_node *n[5] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* ( & TkUnexpected t.SrcPos1 s.Unexpected1  ) ( & TkUnexpected t.SrcPos2 e.Unexpected2  ) e.Tokens */
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_TkUnexpected, &bb[1], &be[1]))
      break;
    if (! r05_brackets_left(&bb[2], &be[2], &bb[0], &be[0]))
      break;
    if (! r05_function_left(r05c_TkUnexpected, &bb[2], &be[2]))
      break;
    eTokens_b_1 = bb[0];
    eTokens_e_1 = be[0];
    if (! r05_tvar_left(&tSrcPos1_1, &bb[1], &be[1]))
      break;
    if (! r05_svar_left(&sUnexpected1_1, &bb[1], &be[1]))
      break;
    if (! r05_empty_seq(bb[1], be[1]))
      break;
    if (! r05_tvar_left(&tSrcPos2_1, &bb[2], &be[2]))
      break;
    eUnexpected2_b_1 = bb[2];
    eUnexpected2_e_1 = be[2];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkUnexpected, "TkUnexpected");
    r05_alloc_insert_pos(n[1]);
    r05_alloc_svar(sUnexpected1_1);
    r05_alloc_insert_pos(n[2]);
    r05_alloc_close_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_link_brackets(n[0], n[3]);
    r05_splice_tvar(n[1], tSrcPos1_1);
    r05_splice_evar(n[2], eUnexpected2_b_1, eUnexpected2_e_1);
    r05_splice_evar(n[4], eTokens_b_1, eTokens_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *tUnexpected_1;
    struct r05_node *eTokens_b_1;
    struct r05_node *eTokens_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* t.Unexpected e.Tokens */
    if (! r05_tvar_left(&tUnexpected_1, &bb[0], &be[0]))
      break;
    eTokens_b_1 = bb[0];
    eTokens_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_insert_pos(n[0]);
    r05_splice_tvar(n[0], tUnexpected_1);
    r05_splice_evar(n[0], eTokens_b_1, eTokens_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanName(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sStartCol_1;
    struct r05_node *sCol_1;
    struct r05_node *eName_b_1;
    struct r05_node *eName_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sLetter_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.StartCol s.Col ( e.Name  ) 'L' s.SubType s.Letter e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sStartCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('L', &bb[0], &be[0]))
      break;
    eName_b_1 = bb[1];
    eName_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sLetter_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanName, "ScanName");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sStartCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sLetter_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eName_b_1, eName_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sStartCol_1;
    struct r05_node *sCol_1;
    struct r05_node *eName_b_1;
    struct r05_node *eName_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.StartCol s.Col ( e.Name  ) 'D' s.SubType s.Digit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sStartCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('D', &bb[0], &be[0]))
      break;
    eName_b_1 = bb[1];
    eName_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanName, "ScanName");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sStartCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sDigit_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eName_b_1, eName_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sStartCol_1;
    struct r05_node *sCol_1;
    struct r05_node *eName_b_1;
    struct r05_node *eName_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.StartCol s.Col ( e.Name  ) s.Type s.SubType '-' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sStartCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eName_b_1 = bb[1];
    eName_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('-', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanName, "ScanName");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sStartCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_char('_');
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eName_b_1, eName_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sStartCol_1;
    struct r05_node *sCol_1;
    struct r05_node *eName_b_1;
    struct r05_node *eName_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.StartCol s.Col ( e.Name  ) s.Type s.SubType '_' e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sStartCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eName_b_1 = bb[1];
    eName_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_char_left('_', &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanName, "ScanName");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sStartCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_char('_');
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eName_b_1, eName_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sStartCol_1;
    struct r05_node *sCol_1;
    struct r05_node *eName_b_1;
    struct r05_node *eName_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[8] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.StartCol s.Col ( e.Name  ) s.Type s.SubType e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sStartCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eName_b_1 = bb[1];
    eName_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkName, "TkName");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sStartCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_insert_pos(n[3]);
    r05_alloc_close_bracket(n[4]);
    r05_alloc_open_call(n[5]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[6]);
    r05_alloc_close_call(n[7]);
    r05_push_stack(n[7]);
    r05_push_stack(n[5]);
    r05_link_brackets(n[0], n[4]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[3], eName_b_1, eName_e_1);
    r05_splice_evar(n[6], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_ScanNumber(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sRow_1;
    struct r05_node *sStartCol_1;
    struct r05_node *sCol_1;
    struct r05_node *eNumber_b_1;
    struct r05_node *eNumber_e_1;
    struct r05_node *sSubType_1;
    struct r05_node *sDigit_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.StartCol s.Col ( e.Number  ) 'D' s.SubType s.Digit e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sStartCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    if (! r05_char_left('D', &bb[0], &be[0]))
      break;
    eNumber_b_1 = bb[1];
    eNumber_e_1 = be[1];
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDigit_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_ScanNumber, "ScanNumber");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sStartCol_1);
    r05_alloc_open_call(n[1]);
    r05_alloc_function(r05c_Inc, "Inc");
    r05_alloc_svar(sCol_1);
    r05_alloc_close_call(n[2]);
    r05_alloc_open_bracket(n[3]);
    r05_alloc_insert_pos(n[4]);
    r05_alloc_svar(sDigit_1);
    r05_alloc_close_bracket(n[5]);
    r05_alloc_open_call(n[6]);
    r05_alloc_function(r05c_Type, "Type");
    r05_alloc_insert_pos(n[7]);
    r05_alloc_close_call(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[0]);
    r05_push_stack(n[8]);
    r05_push_stack(n[6]);
    r05_link_brackets(n[3], n[5]);
    r05_push_stack(n[2]);
    r05_push_stack(n[1]);
    r05_splice_evar(n[4], eNumber_b_1, eNumber_e_1);
    r05_splice_evar(n[7], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sRow_1;
    struct r05_node *sStartCol_1;
    struct r05_node *sCol_1;
    struct r05_node *eNumber_b_1;
    struct r05_node *eNumber_e_1;
    struct r05_node *sType_1;
    struct r05_node *sSubType_1;
    struct r05_node *eTail_b_1;
    struct r05_node *eTail_e_1;
    struct r05_node *bb[2] = { 0 };
    struct r05_node *be[2] = { 0 };
    struct r05_node *n[10] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Row s.StartCol s.Col ( e.Number  ) s.Type s.SubType e.Tail */
    if (! r05_svar_left(&sRow_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sStartCol_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCol_1, &bb[0], &be[0]))
      break;
    if (! r05_brackets_left(&bb[1], &be[1], &bb[0], &be[0]))
      break;
    eNumber_b_1 = bb[1];
    eNumber_e_1 = be[1];
    if (! r05_svar_left(&sType_1, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sSubType_1, &bb[0], &be[0]))
      break;
    eTail_b_1 = bb[0];
    eTail_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_open_bracket(n[0]);
    r05_alloc_function(r05c_TkNumber, "TkNumber");
    r05_alloc_open_bracket(n[1]);
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sStartCol_1);
    r05_alloc_close_bracket(n[2]);
    r05_alloc_open_call(n[3]);
    r05_alloc_function(r05c_Numb, "Numb");
    r05_alloc_insert_pos(n[4]);
    r05_alloc_close_call(n[5]);
    r05_alloc_close_bracket(n[6]);
    r05_alloc_open_call(n[7]);
    r05_alloc_function(r05c_Scan, "Scan");
    r05_alloc_svar(sRow_1);
    r05_alloc_svar(sCol_1);
    r05_alloc_insert_pos(n[8]);
    r05_alloc_close_call(n[9]);
    r05_push_stack(n[9]);
    r05_push_stack(n[7]);
    r05_link_brackets(n[0], n[6]);
    r05_push_stack(n[5]);
    r05_push_stack(n[3]);
    r05_link_brackets(n[1], n[2]);
    r05_splice_evar(n[4], eNumber_b_1, eNumber_e_1);
    r05_splice_evar(n[8], eTail_b_1, eTail_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_StrDirective(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & EEnum */
    if (! r05_function_left(r05c_EEnum, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("EENUM", 5);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & Entry */
    if (! r05_function_left(r05c_Entry, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("ENTRY", 5);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & Enum */
    if (! r05_function_left(r05c_Enum, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("ENUM", 4);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & Extern */
    if (! r05_function_left(r05c_Extern, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("EXTERN", 6);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkOpen(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_TkClose(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_StrFromToken(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *sChar_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[2] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkChar s.Char */
    if (! r05_function_left(r05c_TkChar, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sChar_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_char('\'');
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_EscapeChar, "EscapeChar");
    r05_alloc_svar(sChar_1);
    r05_alloc_close_call(n[1]);
    r05_alloc_char('\'');
    r05_push_stack(n[1]);
    r05_push_stack(n[0]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkCloseCall */
    if (! r05_function_left(r05c_TkCloseCall, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\">\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkCloseBlock */
    if (! r05_function_left(r05c_TkCloseBlock, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\"}\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkCloseBracket */
    if (! r05_function_left(r05c_TkCloseBracket, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\")\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkComma */
    if (! r05_function_left(r05c_TkComma, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\",\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sDirective_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[2] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkDirective s.Directive */
    if (! r05_function_left(r05c_TkDirective, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sDirective_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\"$", 2);
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_StrDirective, "StrDirective");
    r05_alloc_svar(sDirective_1);
    r05_alloc_close_call(n[1]);
    r05_alloc_char('\"');
    r05_push_stack(n[1]);
    r05_push_stack(n[0]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkEOF */
    if (! r05_function_left(r05c_TkEOF, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("end of file", 11);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *eMessage_b_1;
    struct r05_node *eMessage_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkError e.Message */
    if (! r05_function_left(r05c_TkError, &bb[0], &be[0]))
      break;
    eMessage_b_1 = bb[0];
    eMessage_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_chars("LEXER ERROR: ", 13);
    r05_alloc_insert_pos(n[0]);
    r05_splice_evar(n[0], eMessage_b_1, eMessage_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *eName_b_1;
    struct r05_node *eName_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkName e.Name */
    if (! r05_function_left(r05c_TkName, &bb[0], &be[0]))
      break;
    eName_b_1 = bb[0];
    eName_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_chars("Name ", 5);
    r05_alloc_insert_pos(n[0]);
    r05_splice_evar(n[0], eName_b_1, eName_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkNative e.Code */
    if (! r05_function_left(r05c_TkNative, &bb[0], &be[0]))
      break;
    /* Unused closed variable e.Code*/

    r05_reset_allocator();
    r05_alloc_chars("\"%%...%%\"", 9);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sNumber_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[2] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkNumber s.Number */
    if (! r05_function_left(r05c_TkNumber, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sNumber_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("Number ", 7);
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_Symb, "Symb");
    r05_alloc_svar(sNumber_1);
    r05_alloc_close_call(n[1]);
    r05_push_stack(n[1]);
    r05_push_stack(n[0]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkOpenCall */
    if (! r05_function_left(r05c_TkOpenCall, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\"<\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkOpenBlock */
    if (! r05_function_left(r05c_TkOpenBlock, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\"{\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkOpenBracket */
    if (! r05_function_left(r05c_TkOpenBracket, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\"(\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkReplace */
    if (! r05_function_left(r05c_TkReplace, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\"=\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkSemicolon */
    if (! r05_function_left(r05c_TkSemicolon, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_chars("\";\"", 3);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *eUnexpected_b_1;
    struct r05_node *eUnexpected_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkUnexpected e.Unexpected */
    if (! r05_function_left(r05c_TkUnexpected, &bb[0], &be[0]))
      break;
    eUnexpected_b_1 = bb[0];
    eUnexpected_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_chars("Unexpected characters <", 23);
    r05_alloc_insert_pos(n[0]);
    r05_alloc_char('>');
    r05_splice_evar(n[0], eUnexpected_b_1, eUnexpected_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sMode_1;
    struct r05_node *eIndex_b_1;
    struct r05_node *eIndex_e_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkVariable s.Mode e.Index */
    if (! r05_function_left(r05c_TkVariable, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sMode_1, &bb[0], &be[0]))
      break;
    eIndex_b_1 = bb[0];
    eIndex_e_1 = be[0];

    r05_reset_allocator();
    r05_alloc_svar(sMode_1);
    r05_alloc_char('.');
    r05_alloc_insert_pos(n[0]);
    r05_splice_evar(n[0], eIndex_b_1, eIndex_e_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sOpenBracket_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[2] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkOpen s.OpenBracket */
    if (! r05_function_left(r05c_TkOpen, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sOpenBracket_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_StrFromToken, "StrFromToken");
    r05_alloc_svar(sOpenBracket_1);
    r05_alloc_close_call(n[1]);
    r05_push_stack(n[1]);
    r05_push_stack(n[0]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sCloseBracket_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    struct r05_node *n[2] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* & TkClose s.CloseBracket */
    if (! r05_function_left(r05c_TkClose, &bb[0], &be[0]))
      break;
    if (! r05_svar_left(&sCloseBracket_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_open_call(n[0]);
    r05_alloc_function(r05c_StrFromToken, "StrFromToken");
    r05_alloc_svar(sCloseBracket_1);
    r05_alloc_close_call(n[1]);
    r05_push_stack(n[1]);
    r05_push_stack(n[0]);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_DigitFromChar(struct r05_node *arg_begin, struct r05_node *arg_end) {
  r05_this_is_generated_function();
  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '0' */
    if (! r05_char_left('0', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(0UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '1' */
    if (! r05_char_left('1', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(1UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '2' */
    if (! r05_char_left('2', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(2UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '3' */
    if (! r05_char_left('3', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(3UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '4' */
    if (! r05_char_left('4', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(4UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '5' */
    if (! r05_char_left('5', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(5UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '6' */
    if (! r05_char_left('6', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(6UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '7' */
    if (! r05_char_left('7', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(7UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '8' */
    if (! r05_char_left('8', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(8UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* '9' */
    if (! r05_char_left('9', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(9UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'A' */
    if (! r05_char_left('A', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(10UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'B' */
    if (! r05_char_left('B', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(11UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'C' */
    if (! r05_char_left('C', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(12UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'D' */
    if (! r05_char_left('D', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(13UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'E' */
    if (! r05_char_left('E', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(14UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'F' */
    if (! r05_char_left('F', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(15UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'a' */
    if (! r05_char_left('a', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(10UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'b' */
    if (! r05_char_left('b', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(11UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'c' */
    if (! r05_char_left('c', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(12UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'd' */
    if (! r05_char_left('d', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(13UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'e' */
    if (! r05_char_left('e', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(14UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* 'f' */
    if (! r05_char_left('f', &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_number(15UL);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  do {
    struct r05_node *sOther_1;
    struct r05_node *bb[1] = { 0 };
    struct r05_node *be[1] = { 0 };
    r05_start_sentence();
    r05_prepare_argument(&bb[0], &be[0], arg_begin, arg_end);
    /* s.Other */
    if (! r05_svar_left(&sOther_1, &bb[0], &be[0]))
      break;
    if (! r05_empty_seq(bb[0], be[0]))
      break;

    r05_reset_allocator();
    r05_alloc_function(r05c_Fails, "Fails");
    r05_alloc_svar(sOther_1);
    r05_splice_from_freelist(arg_begin);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}


/* End of file */
