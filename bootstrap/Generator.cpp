// Automatically generated file. Don't edit!
#include "refalrts.h"


extern enum r05_fnresult r05c_MapReduce(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Dec(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Inc(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Map(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_DelAccumulator(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_StrFromInt(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdComment(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdDeclareEVar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdDeclareVar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdSymbol(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Char(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Number(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_Name(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdBrackets(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdEmpty(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdVar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdRepeated(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdClosedE(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_AlgLeft(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdOpenedE_Start(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdOpenedE_End(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdSave(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdEmptyResult(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdCopyEVar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdCopyVar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdAllocateElem(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ElString(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdLinkBrackets(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdPushStack(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdInsertElem(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdInsertVar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdInsertString(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_CmdReturnResult(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_AlgRight(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ElSymbol(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ElOpenBracket(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ElCloseBracket(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ElOpenCall(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_ElCloseCall(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_EscapeChar(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GN_Local(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GN_Entry(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_FuncArguments(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_NakedArguments(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_TextFromMemoryClass(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_SwGenFnStart(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenFnStart(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenThisIsGeneratedFunction(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenFnEnd(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenFnEnd_Success(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenEnum(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenExtern(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenForward(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_GenCommonHeaders(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_GenCommonTailer(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenSentence(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_SkipIndentAccum(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_BracketsVar_B(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_BracketsVar_E(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_BracketsVars(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_BracketsVarsPtr(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_GenCommand(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_EscapeString(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintVar(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintEVar_B(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintEVar_E(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintEVars(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintMatchSymbol(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_SymbolFunc(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_SymbolTextRep(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintMatchBrackets(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_BreakerFromIndent(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintMatchEmpty(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_StrFromDirection(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_VarMatchFunction(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintMatchSTVar(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintMatchRepeated(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintMatch(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintElemVar(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintStringVar(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintAllocateElem(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_PrintAllocate_Aux(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_SwAllocator(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_SwInfo(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_BeginNative(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_EndNative(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenNative(struct r05_node *arg_begin, struct r05_node *arg_end);
extern enum r05_fnresult r05c_GenPostprocess(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_EnumerateLines(struct r05_node *arg_begin, struct r05_node *arg_end);
static enum r05_fnresult r05c_LineDirective(struct r05_node *arg_begin, struct r05_node *arg_end);

enum r05_fnresult r05c_GN_Local(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GN_Entry(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_FuncArguments(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    //
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "struct r05_node *arg_begin, struct r05_node *arg_end", 52) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_NakedArguments(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    //
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "struct r05_node *, struct r05_node *", 36) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_TextFromMemoryClass(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & GN_Local
    if( ! refalrts::function_left( r05c_GN_Local, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "static ", 7) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & GN_Entry
    if( ! refalrts::function_left( r05c_GN_Entry, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_SwGenFnStart(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sMemoryClass_1;
    static struct r05_node *sFnArguments_1;
    static struct r05_node *eName_b_1;
    static struct r05_node *eName_e_1;
    // s.MemoryClass s.FnArguments e.Name
    if( ! refalrts::svar_left( sMemoryClass_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sFnArguments_1, bb_0, be_0 ) )
      break;
    eName_b_1 = bb_0;
    eName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_TextFromMemoryClass, "TextFromMemoryClass" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_chars( n4, n5, "enum r05_fnresult r05c_", 23) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_char( n6, '(' ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_chars( n9, n10, ") {", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n0, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, n9, n10 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sFnArguments_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_evar( res, n4, n5 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sMemoryClass_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenFnStart(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sMemoryClass_1;
    static struct r05_node *eName_b_1;
    static struct r05_node *eName_e_1;
    // s.MemoryClass e.Name
    if( ! refalrts::svar_left( sMemoryClass_1, bb_0, be_0 ) )
      break;
    eName_b_1 = bb_0;
    eName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_SwGenFnStart, "SwGenFnStart" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_FuncArguments, "FuncArguments" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n3 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sMemoryClass_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenThisIsGeneratedFunction(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    //
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "  refalrts::this_is_generated_function();", 41) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenFnEnd(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    //
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "  return (enum r05_fnresult)(", 29) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_chars( n5, n6, "    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)", 48) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_chars( n9, n10, "  );", 4) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_open_bracket( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_char( n13, '}' ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_open_bracket( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_close_bracket( n16 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n15, n16 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::link_brackets( n12, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    refalrts::link_brackets( n8, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, n9, n10 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, n5, n6 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenFnEnd_Success(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    //
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "  //return R05_RECOGNITION_IMPOSSIBLE;", 38) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_char( n5, '}' ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenEnum(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sScopeClass_1;
    static struct r05_node *eName_b_1;
    static struct r05_node *eName_e_1;
    // s.ScopeClass e.Name
    if( ! refalrts::svar_left( sScopeClass_1, bb_0, be_0 ) )
      break;
    eName_b_1 = bb_0;
    eName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_SwGenFnStart, "SwGenFnStart" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_NakedArguments, "NakedArguments" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_name( n5, r05c_GenFnEnd, "GenFnEnd" ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sScopeClass_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenExtern(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eName_b_1;
    static struct r05_node *eName_e_1;
    // e.Name
    eName_b_1 = bb_0;
    eName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "extern enum r05_fnresult r05c_", 30) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_char( n3, '(' ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_name( n5, r05c_FuncArguments, "FuncArguments" ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_chars( n7, n8, ");", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n0, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, n7, n8 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenForward(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eName_b_1;
    static struct r05_node *eName_e_1;
    // e.Name
    eName_b_1 = bb_0;
    eName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "static enum r05_fnresult r05c_", 30) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_char( n3, '(' ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_name( n5, r05c_FuncArguments, "FuncArguments" ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_chars( n7, n8, ");", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n0, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, n7, n8 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_GenCommonHeaders(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    //
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "// Automatically generated file. Don\'t edit!", 44) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_chars( n5, n6, "#include \"refalrts.h\"", 21) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::link_brackets( n8, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, n5, n6 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_GenCommonTailer(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    //
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "//End of file", 13) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenSentence(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eAlgorithm_b_1;
    static struct r05_node *eAlgorithm_e_1;
    // e.Algorithm
    eAlgorithm_b_1 = bb_0;
    eAlgorithm_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "  do {", 6) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_chars( n5, n6, "    struct r05_node *", 21) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_name( n8, r05c_BracketsVar_B, "BracketsVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_number( n9, 0UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_chars( n11, n12, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_close_bracket( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_open_bracket( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_chars( n15, n16, "    struct r05_node *", 21) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_open_call( n17 ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_name( n18, r05c_BracketsVar_E, "BracketsVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_number( n19, 0UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_chars( n21, n22, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n23 = 0;
    if( ! refalrts::alloc_close_bracket( n23 ) )
      return R05_NO_MEMORY;
    struct r05_node *n24 = 0;
    if( ! refalrts::alloc_open_bracket( n24 ) )
      return R05_NO_MEMORY;
    struct r05_node *n25 = 0;
    struct r05_node *n26 = 0;
    if( ! refalrts::alloc_chars( n25, n26, "    r05_prepare_argument(", 25) )
      return R05_NO_MEMORY;
    struct r05_node *n27 = 0;
    if( ! refalrts::alloc_open_call( n27 ) )
      return R05_NO_MEMORY;
    struct r05_node *n28 = 0;
    if( ! refalrts::alloc_name( n28, r05c_BracketsVarsPtr, "BracketsVarsPtr" ) )
      return R05_NO_MEMORY;
    struct r05_node *n29 = 0;
    if( ! refalrts::alloc_number( n29, 0UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n30 = 0;
    if( ! refalrts::alloc_close_call( n30 ) )
      return R05_NO_MEMORY;
    struct r05_node *n31 = 0;
    struct r05_node *n32 = 0;
    if( ! refalrts::alloc_chars( n31, n32, ", arg_begin, arg_end);", 22) )
      return R05_NO_MEMORY;
    struct r05_node *n33 = 0;
    if( ! refalrts::alloc_close_bracket( n33 ) )
      return R05_NO_MEMORY;
    struct r05_node *n34 = 0;
    if( ! refalrts::alloc_open_bracket( n34 ) )
      return R05_NO_MEMORY;
    struct r05_node *n35 = 0;
    struct r05_node *n36 = 0;
    if( ! refalrts::alloc_chars( n35, n36, "    refalrts::start_sentence();", 31) )
      return R05_NO_MEMORY;
    struct r05_node *n37 = 0;
    if( ! refalrts::alloc_close_bracket( n37 ) )
      return R05_NO_MEMORY;
    struct r05_node *n38 = 0;
    if( ! refalrts::alloc_open_call( n38 ) )
      return R05_NO_MEMORY;
    struct r05_node *n39 = 0;
    if( ! refalrts::alloc_name( n39, r05c_SkipIndentAccum, "SkipIndentAccum" ) )
      return R05_NO_MEMORY;
    struct r05_node *n40 = 0;
    if( ! refalrts::alloc_open_call( n40 ) )
      return R05_NO_MEMORY;
    struct r05_node *n41 = 0;
    if( ! refalrts::alloc_name( n41, r05c_MapReduce, "MapReduce" ) )
      return R05_NO_MEMORY;
    struct r05_node *n42 = 0;
    if( ! refalrts::alloc_name( n42, r05c_GenCommand, "GenCommand" ) )
      return R05_NO_MEMORY;
    struct r05_node *n43 = 0;
    if( ! refalrts::alloc_open_bracket( n43 ) )
      return R05_NO_MEMORY;
    struct r05_node *n44 = 0;
    struct r05_node *n45 = 0;
    if( ! refalrts::alloc_chars( n44, n45, "    ", 4) )
      return R05_NO_MEMORY;
    struct r05_node *n46 = 0;
    if( ! refalrts::alloc_close_bracket( n46 ) )
      return R05_NO_MEMORY;
    struct r05_node *n47 = 0;
    if( ! refalrts::alloc_close_call( n47 ) )
      return R05_NO_MEMORY;
    struct r05_node *n48 = 0;
    if( ! refalrts::alloc_close_call( n48 ) )
      return R05_NO_MEMORY;
    struct r05_node *n49 = 0;
    if( ! refalrts::alloc_open_bracket( n49 ) )
      return R05_NO_MEMORY;
    struct r05_node *n50 = 0;
    struct r05_node *n51 = 0;
    if( ! refalrts::alloc_chars( n50, n51, "  } while ( 0 );", 16) )
      return R05_NO_MEMORY;
    struct r05_node *n52 = 0;
    if( ! refalrts::alloc_close_bracket( n52 ) )
      return R05_NO_MEMORY;
    struct r05_node *n53 = 0;
    if( ! refalrts::alloc_open_bracket( n53 ) )
      return R05_NO_MEMORY;
    struct r05_node *n54 = 0;
    if( ! refalrts::alloc_close_bracket( n54 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n53, n54 );
    res = refalrts::splice_elem( res, n54 );
    res = refalrts::splice_elem( res, n53 );
    refalrts::link_brackets( n49, n52 );
    res = refalrts::splice_elem( res, n52 );
    res = refalrts::splice_evar( res, n50, n51 );
    res = refalrts::splice_elem( res, n49 );
    refalrts::push_stack( n48 );
    refalrts::push_stack( n38 );
    res = refalrts::splice_elem( res, n48 );
    refalrts::push_stack( n47 );
    refalrts::push_stack( n40 );
    res = refalrts::splice_elem( res, n47 );
    res = refalrts::splice_evar( res, eAlgorithm_b_1, eAlgorithm_e_1 );
    refalrts::link_brackets( n43, n46 );
    res = refalrts::splice_elem( res, n46 );
    res = refalrts::splice_evar( res, n44, n45 );
    res = refalrts::splice_elem( res, n43 );
    res = refalrts::splice_elem( res, n42 );
    res = refalrts::splice_elem( res, n41 );
    res = refalrts::splice_elem( res, n40 );
    res = refalrts::splice_elem( res, n39 );
    res = refalrts::splice_elem( res, n38 );
    refalrts::link_brackets( n34, n37 );
    res = refalrts::splice_elem( res, n37 );
    res = refalrts::splice_evar( res, n35, n36 );
    res = refalrts::splice_elem( res, n34 );
    refalrts::link_brackets( n24, n33 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_evar( res, n31, n32 );
    refalrts::push_stack( n30 );
    refalrts::push_stack( n27 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_evar( res, n25, n26 );
    res = refalrts::splice_elem( res, n24 );
    refalrts::link_brackets( n14, n23 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, n21, n22 );
    refalrts::push_stack( n20 );
    refalrts::push_stack( n17 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, n15, n16 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::link_brackets( n4, n13 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, n11, n12 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, n5, n6 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_SkipIndentAccum(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eGenerated_b_1;
    static struct r05_node *eGenerated_e_1;
    // ( '    ' ) e.Generated
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::char_left( ' ', bb_1, be_1 ) )
      break;
    if( ! refalrts::char_left( ' ', bb_1, be_1 ) )
      break;
    if( ! refalrts::char_left( ' ', bb_1, be_1 ) )
      break;
    if( ! refalrts::char_left( ' ', bb_1, be_1 ) )
      break;
    if (! r05_empty_seq(bb_1, be_1))
      break;
    eGenerated_b_1 = bb_0;
    eGenerated_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    res = refalrts::splice_evar( res, eGenerated_b_1, eGenerated_e_1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_BracketsVar_B(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sBracketNumber_1;
    // s.BracketNumber
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "bb_", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_BracketsVar_E(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sBracketNumber_1;
    // s.BracketNumber
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "be_", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_BracketsVars(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sBracketNumber_2;
    // s.BracketNumber
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sBracketNumber_2, sBracketNumber_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_BracketsVar_B, "BracketsVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_BracketsVar_E, "BracketsVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sBracketNumber_2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_BracketsVarsPtr(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sBracketNumber_2;
    // s.BracketNumber
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sBracketNumber_2, sBracketNumber_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_char( n0, '&' ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_BracketsVar_B, "BracketsVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_chars( n4, n5, ", &", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_name( n7, r05c_BracketsVar_E, "BracketsVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sBracketNumber_2 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, n4, n5 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_GenCommand(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *eText_b_1;
    static struct r05_node *eText_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdComment e.Text )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdComment, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    eText_b_1 = bb_2;
    eText_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "//", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *eVarInfo_b_1;
    static struct r05_node *eVarInfo_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *eVarInfo_b_2;
    static struct r05_node *eVarInfo_e_2;
    // ( e.Indent ) ( & CmdDeclareEVar e.VarInfo )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdDeclareEVar, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    eVarInfo_b_1 = bb_2;
    eVarInfo_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eVarInfo_b_2, eVarInfo_e_2, eVarInfo_b_1, eVarInfo_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "static struct r05_node *", 24) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintEVar_B, "PrintEVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_char( n8, ';' ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_chars( n11, n12, "static struct r05_node *", 24) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_name( n14, r05c_PrintEVar_E, "PrintEVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_char( n16, ';' ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_close_bracket( n17 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n10, n17 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eVarInfo_b_2, eVarInfo_e_2 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, n11, n12 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::link_brackets( n2, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eVarInfo_b_1, eVarInfo_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *eVarInfo_b_1;
    static struct r05_node *eVarInfo_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdDeclareVar e.VarInfo )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdDeclareVar, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    eVarInfo_b_1 = bb_2;
    eVarInfo_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "static struct r05_node *", 24) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintVar, "PrintVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_char( n8, ';' ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eVarInfo_b_1, eVarInfo_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sType_1;
    static struct r05_node *eValue_b_1;
    static struct r05_node *eValue_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdSymbol s.Direction s.BracketNumber s.Type e.Value )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdSymbol, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sType_1, bb_2, be_2 ) )
      break;
    eValue_b_1 = bb_2;
    eValue_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_PrintMatchSymbol, "PrintMatchSymbol" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eValue_b_1, eValue_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n4, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sInnerBrackets_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *eIndent_b_4;
    static struct r05_node *eIndent_e_4;
    static struct r05_node *sInnerBrackets_2;
    static struct r05_node *sInnerBrackets_3;
    // ( e.Indent ) ( & CmdBrackets s.Direction s.BracketNumber s.InnerBrackets )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdBrackets, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sInnerBrackets_1, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_4, eIndent_e_4, eIndent_b_3, eIndent_e_3 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sInnerBrackets_2, sInnerBrackets_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sInnerBrackets_3, sInnerBrackets_2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "struct r05_node *", 17) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_BracketsVar_B, "BracketsVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_chars( n12, n13, "struct r05_node *", 17) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_name( n15, r05c_BracketsVar_E, "BracketsVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_chars( n17, n18, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_close_bracket( n19 ) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_open_call( n20 ) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    if( ! refalrts::alloc_name( n21, r05c_PrintMatchBrackets, "PrintMatchBrackets" ) )
      return R05_NO_MEMORY;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_open_bracket( n22 ) )
      return R05_NO_MEMORY;
    struct r05_node *n23 = 0;
    if( ! refalrts::alloc_close_bracket( n23 ) )
      return R05_NO_MEMORY;
    struct r05_node *n24 = 0;
    if( ! refalrts::alloc_close_call( n24 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n24 );
    refalrts::push_stack( n20 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_stvar( res, sInnerBrackets_3 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n22, n23 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, eIndent_b_4, eIndent_e_4 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    refalrts::link_brackets( n11, n19 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_evar( res, n17, n18 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_stvar( res, sInnerBrackets_2 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, n12, n13 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::link_brackets( n2, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sInnerBrackets_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdEmpty s.Direction s.BracketNumber )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdEmpty, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_PrintMatchEmpty, "PrintMatchEmpty" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    refalrts::link_brackets( n4, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eInfo_b_1;
    static struct r05_node *eInfo_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdVar s.Direction s.BracketNumber s.Mode e.Info )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdVar, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_2, be_2 ) )
      break;
    eInfo_b_1 = bb_2;
    eInfo_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_PrintMatchSTVar, "PrintMatchSTVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n4, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *eVarInfo_b_1;
    static struct r05_node *eVarInfo_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdRepeated s.Direction s.BracketNumber e.VarInfo )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdRepeated, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    eVarInfo_b_1 = bb_2;
    eVarInfo_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_PrintMatchRepeated, "PrintMatchRepeated" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eVarInfo_b_1, eVarInfo_e_1 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n4, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *eIndex_b_2;
    static struct r05_node *eIndex_e_2;
    static struct r05_node *sBracketNumber_2;
    // ( e.Indent ) ( & CmdClosedE & AlgLeft s.BracketNumber 'e e.Index )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdClosedE, bb_2, be_2 ) )
      break;
    if( ! refalrts::function_left( r05c_AlgLeft, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::char_left( 'e', bb_2, be_2 ) )
      break;
    eIndex_b_1 = bb_2;
    eIndex_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sBracketNumber_2, sBracketNumber_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_name( n4, r05c_PrintEVar_B, "PrintEVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_number( n5, 1UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_char( n6, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " = ", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_name( n11, r05c_BracketsVar_B, "BracketsVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_char( n13, ';' ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_open_bracket( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_name( n17, r05c_PrintEVar_E, "PrintEVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_number( n18, 1UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_char( n19, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_chars( n21, n22, " = ", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n23 = 0;
    if( ! refalrts::alloc_open_call( n23 ) )
      return R05_NO_MEMORY;
    struct r05_node *n24 = 0;
    if( ! refalrts::alloc_name( n24, r05c_BracketsVar_E, "BracketsVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n25 = 0;
    if( ! refalrts::alloc_close_call( n25 ) )
      return R05_NO_MEMORY;
    struct r05_node *n26 = 0;
    if( ! refalrts::alloc_char( n26, ';' ) )
      return R05_NO_MEMORY;
    struct r05_node *n27 = 0;
    if( ! refalrts::alloc_close_bracket( n27 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n15, n27 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    refalrts::push_stack( n25 );
    refalrts::push_stack( n23 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_stvar( res, sBracketNumber_2 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, n21, n22 );
    refalrts::push_stack( n20 );
    refalrts::push_stack( n16 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::link_brackets( n2, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *eIndent_b_4;
    static struct r05_node *eIndent_e_4;
    static struct r05_node *eIndent_b_5;
    static struct r05_node *eIndent_e_5;
    static struct r05_node *eIndex_b_2;
    static struct r05_node *eIndex_e_2;
    // ( e.Indent ) ( & CmdOpenedE_Start & AlgLeft s.BracketNumber 'e e.Index )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdOpenedE_Start, bb_2, be_2 ) )
      break;
    if( ! refalrts::function_left( r05c_AlgLeft, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::char_left( 'e', bb_2, be_2 ) )
      break;
    eIndex_b_1 = bb_2;
    eIndex_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_4, eIndent_e_4, eIndent_b_3, eIndent_e_3 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_5, eIndent_e_5, eIndent_b_4, eIndent_e_4 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "  ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintEVar_B, "PrintEVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_number( n7, 1UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_chars( n10, n11, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_name( n15, r05c_PrintEVar_E, "PrintEVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_number( n16, 1UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_char( n17, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_chars( n19, n20, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    if( ! refalrts::alloc_close_bracket( n21 ) )
      return R05_NO_MEMORY;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_open_bracket( n22 ) )
      return R05_NO_MEMORY;
    struct r05_node *n23 = 0;
    struct r05_node *n24 = 0;
    if( ! refalrts::alloc_chars( n23, n24, "refalrts::start_e_loop();", 25) )
      return R05_NO_MEMORY;
    struct r05_node *n25 = 0;
    if( ! refalrts::alloc_close_bracket( n25 ) )
      return R05_NO_MEMORY;
    struct r05_node *n26 = 0;
    if( ! refalrts::alloc_open_bracket( n26 ) )
      return R05_NO_MEMORY;
    struct r05_node *n27 = 0;
    struct r05_node *n28 = 0;
    if( ! refalrts::alloc_chars( n27, n28, "do {", 4) )
      return R05_NO_MEMORY;
    struct r05_node *n29 = 0;
    if( ! refalrts::alloc_close_bracket( n29 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n26, n29 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_evar( res, n27, n28 );
    res = refalrts::splice_evar( res, eIndent_b_5, eIndent_e_5 );
    res = refalrts::splice_elem( res, n26 );
    refalrts::link_brackets( n22, n25 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_evar( res, n23, n24 );
    res = refalrts::splice_evar( res, eIndent_b_4, eIndent_e_4 );
    res = refalrts::splice_elem( res, n22 );
    refalrts::link_brackets( n13, n21 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_evar( res, n19, n20 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::link_brackets( n4, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, n10, n11 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent '  ' ) ( & CmdOpenedE_End & AlgLeft s.BracketNumber 'e e.Index )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::char_right( ' ', bb_1, be_1 ) )
      break;
    if( ! refalrts::char_right( ' ', bb_1, be_1 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdOpenedE_End, bb_2, be_2 ) )
      break;
    if( ! refalrts::function_left( r05c_AlgLeft, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::char_left( 'e', bb_2, be_2 ) )
      break;
    eIndex_b_1 = bb_2;
    eIndex_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "} while ( refalrts::open_evar_advance( ", 39) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintEVars, "PrintEVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_number( n7, 1UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_chars( n10, n11, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_name( n13, r05c_BracketsVars, "BracketsVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_chars( n15, n16, " ) );", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_close_bracket( n17 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n17 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, n15, n16 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n12 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, n10, n11 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sOldBracketNumber_1;
    static struct r05_node *sNewBracketNumber_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *sNewBracketNumber_2;
    static struct r05_node *sOldBracketNumber_2;
    // ( e.Indent ) ( & CmdSave s.OldBracketNumber s.NewBracketNumber )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdSave, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sOldBracketNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sNewBracketNumber_1, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sNewBracketNumber_2, sNewBracketNumber_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sOldBracketNumber_2, sOldBracketNumber_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "struct r05_node *", 17) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_BracketsVar_B, "BracketsVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " = ", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_name( n11, r05c_BracketsVar_B, "BracketsVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_char( n13, ';' ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_open_bracket( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_chars( n16, n17, "struct r05_node *", 17) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_open_call( n18 ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_name( n19, r05c_BracketsVar_E, "BracketsVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_chars( n21, n22, " = ", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n23 = 0;
    if( ! refalrts::alloc_open_call( n23 ) )
      return R05_NO_MEMORY;
    struct r05_node *n24 = 0;
    if( ! refalrts::alloc_name( n24, r05c_BracketsVar_E, "BracketsVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n25 = 0;
    if( ! refalrts::alloc_close_call( n25 ) )
      return R05_NO_MEMORY;
    struct r05_node *n26 = 0;
    if( ! refalrts::alloc_char( n26, ';' ) )
      return R05_NO_MEMORY;
    struct r05_node *n27 = 0;
    if( ! refalrts::alloc_close_bracket( n27 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n15, n27 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    refalrts::push_stack( n25 );
    refalrts::push_stack( n23 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_stvar( res, sOldBracketNumber_2 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, n21, n22 );
    refalrts::push_stack( n20 );
    refalrts::push_stack( n18 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_stvar( res, sNewBracketNumber_2 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, n16, n17 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::link_brackets( n2, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_stvar( res, sOldBracketNumber_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sNewBracketNumber_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    // ( e.Indent ) ( & CmdEmptyResult )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdEmptyResult, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_chars( n5, n6, "refalrts::reset_allocator();", 28) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_chars( n9, n10, "struct r05_node *res = arg_begin;", 33) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n8, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, n9, n10 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, n5, n6 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::link_brackets( n2, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sUsings_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *sUsings_2;
    static struct r05_node *eIndex_b_2;
    static struct r05_node *eIndex_e_2;
    // ( e.Indent ) ( & CmdCopyEVar s.Usings 'e e.Index )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdCopyEVar, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sUsings_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::char_left( 'e', bb_2, be_2 ) )
      break;
    eIndex_b_1 = bb_2;
    eIndex_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sUsings_2, sUsings_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "if( ! refalrts::copy_evar( ", 27) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintEVars, "PrintEVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_char( n7, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_chars( n9, n10, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_name( n12, r05c_PrintEVars, "PrintEVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_name( n14, r05c_Dec, "Dec" ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_char( n16, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_close_call( n17 ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_chars( n18, n19, " ) )", 4) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_close_bracket( n20 ) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    if( ! refalrts::alloc_open_bracket( n21 ) )
      return R05_NO_MEMORY;
    struct r05_node *n22 = 0;
    struct r05_node *n23 = 0;
    if( ! refalrts::alloc_chars( n22, n23, "  return R05_NO_MEMORY;", 23) )
      return R05_NO_MEMORY;
    struct r05_node *n24 = 0;
    if( ! refalrts::alloc_close_bracket( n24 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n21, n24 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_evar( res, n22, n23 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n21 );
    refalrts::link_brackets( n2, n20 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, n18, n19 );
    refalrts::push_stack( n17 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n16 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_stvar( res, sUsings_2 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, n9, n10 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sUsings_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *sUsings_2;
    static struct r05_node *sMode_2;
    static struct r05_node *eIndex_b_2;
    static struct r05_node *eIndex_e_2;
    // ( e.Indent ) ( & CmdCopyVar s.Usings s.Mode e.Index )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdCopyVar, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sUsings_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_2, be_2 ) )
      break;
    eIndex_b_1 = bb_2;
    eIndex_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sUsings_2, sUsings_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sMode_2, sMode_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "if( ! refalrts::copy_stvar( ", 28) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintVar, "PrintVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_name( n11, r05c_PrintVar, "PrintVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_name( n13, r05c_Dec, "Dec" ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_chars( n16, n17, " ) )", 4) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_close_bracket( n18 ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_open_bracket( n19 ) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    struct r05_node *n21 = 0;
    if( ! refalrts::alloc_chars( n20, n21, "  return R05_NO_MEMORY;", 23) )
      return R05_NO_MEMORY;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n19, n22 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_evar( res, n20, n21 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::link_brackets( n2, n18 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, n16, n17 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_stvar( res, sMode_2 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n12 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_stvar( res, sUsings_2 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sStringNumber_1;
    static struct r05_node *sLen_1;
    static struct r05_node *eString_b_1;
    static struct r05_node *eString_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *eIndent_b_4;
    static struct r05_node *eIndent_e_4;
    static struct r05_node *eIndent_b_5;
    static struct r05_node *eIndent_e_5;
    static struct r05_node *sStringNumber_2;
    static struct r05_node *sStringNumber_3;
    // ( e.Indent ) ( & CmdAllocateElem s.StringNumber & ElString s.Len e.String )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdAllocateElem, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sStringNumber_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::function_left( r05c_ElString, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sLen_1, bb_2, be_2 ) )
      break;
    eString_b_1 = bb_2;
    eString_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_4, eIndent_e_4, eIndent_b_3, eIndent_e_3 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_5, eIndent_e_5, eIndent_b_4, eIndent_e_4 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sStringNumber_2, sStringNumber_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sStringNumber_3, sStringNumber_2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "struct r05_node *", 17) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_chars( n12, n13, "struct r05_node *", 17) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_name( n15, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_name( n17, r05c_Inc, "Inc" ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_close_call( n19 ) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    struct r05_node *n21 = 0;
    if( ! refalrts::alloc_chars( n20, n21, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return R05_NO_MEMORY;
    struct r05_node *n23 = 0;
    if( ! refalrts::alloc_open_bracket( n23 ) )
      return R05_NO_MEMORY;
    struct r05_node *n24 = 0;
    struct r05_node *n25 = 0;
    if( ! refalrts::alloc_chars( n24, n25, "if( ! refalrts::alloc_chars( ", 29) )
      return R05_NO_MEMORY;
    struct r05_node *n26 = 0;
    if( ! refalrts::alloc_open_call( n26 ) )
      return R05_NO_MEMORY;
    struct r05_node *n27 = 0;
    if( ! refalrts::alloc_name( n27, r05c_PrintStringVar, "PrintStringVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n28 = 0;
    if( ! refalrts::alloc_close_call( n28 ) )
      return R05_NO_MEMORY;
    struct r05_node *n29 = 0;
    struct r05_node *n30 = 0;
    if( ! refalrts::alloc_chars( n29, n30, ", \"", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n31 = 0;
    if( ! refalrts::alloc_open_call( n31 ) )
      return R05_NO_MEMORY;
    struct r05_node *n32 = 0;
    if( ! refalrts::alloc_name( n32, r05c_EscapeString, "EscapeString" ) )
      return R05_NO_MEMORY;
    struct r05_node *n33 = 0;
    if( ! refalrts::alloc_close_call( n33 ) )
      return R05_NO_MEMORY;
    struct r05_node *n34 = 0;
    struct r05_node *n35 = 0;
    if( ! refalrts::alloc_chars( n34, n35, "\", ", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n36 = 0;
    if( ! refalrts::alloc_open_call( n36 ) )
      return R05_NO_MEMORY;
    struct r05_node *n37 = 0;
    if( ! refalrts::alloc_name( n37, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n38 = 0;
    if( ! refalrts::alloc_close_call( n38 ) )
      return R05_NO_MEMORY;
    struct r05_node *n39 = 0;
    struct r05_node *n40 = 0;
    if( ! refalrts::alloc_chars( n39, n40, ") )", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n41 = 0;
    if( ! refalrts::alloc_close_bracket( n41 ) )
      return R05_NO_MEMORY;
    struct r05_node *n42 = 0;
    if( ! refalrts::alloc_open_bracket( n42 ) )
      return R05_NO_MEMORY;
    struct r05_node *n43 = 0;
    struct r05_node *n44 = 0;
    if( ! refalrts::alloc_chars( n43, n44, "  return R05_NO_MEMORY;", 23) )
      return R05_NO_MEMORY;
    struct r05_node *n45 = 0;
    if( ! refalrts::alloc_close_bracket( n45 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n42, n45 );
    res = refalrts::splice_elem( res, n45 );
    res = refalrts::splice_evar( res, n43, n44 );
    res = refalrts::splice_evar( res, eIndent_b_5, eIndent_e_5 );
    res = refalrts::splice_elem( res, n42 );
    refalrts::link_brackets( n23, n41 );
    res = refalrts::splice_elem( res, n41 );
    res = refalrts::splice_evar( res, n39, n40 );
    refalrts::push_stack( n38 );
    refalrts::push_stack( n36 );
    res = refalrts::splice_elem( res, n38 );
    res = refalrts::splice_stvar( res, sLen_1 );
    res = refalrts::splice_elem( res, n37 );
    res = refalrts::splice_elem( res, n36 );
    res = refalrts::splice_evar( res, n34, n35 );
    refalrts::push_stack( n33 );
    refalrts::push_stack( n31 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_evar( res, eString_b_1, eString_e_1 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_evar( res, n29, n30 );
    refalrts::push_stack( n28 );
    refalrts::push_stack( n26 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_stvar( res, sStringNumber_3 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_evar( res, n24, n25 );
    res = refalrts::splice_evar( res, eIndent_b_4, eIndent_e_4 );
    res = refalrts::splice_elem( res, n23 );
    refalrts::link_brackets( n11, n22 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_evar( res, n20, n21 );
    refalrts::push_stack( n19 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n16 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_stvar( res, sStringNumber_2 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, n12, n13 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::link_brackets( n2, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sStringNumber_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sElemNumber_1;
    static struct r05_node *eElemInfo_b_1;
    static struct r05_node *eElemInfo_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *sElemNumber_2;
    // ( e.Indent ) ( & CmdAllocateElem s.ElemNumber e.ElemInfo )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdAllocateElem, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sElemNumber_1, bb_2, be_2 ) )
      break;
    eElemInfo_b_1 = bb_2;
    eElemInfo_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sElemNumber_2, sElemNumber_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "struct r05_node *", 17) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " = 0;", 5) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_name( n12, r05c_PrintAllocateElem, "PrintAllocateElem" ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n15 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eElemInfo_b_1, eElemInfo_e_1 );
    res = refalrts::splice_stvar( res, sElemNumber_2 );
    refalrts::link_brackets( n13, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::link_brackets( n2, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sElemNumber_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sLeft_1;
    static struct r05_node *sRight_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdLinkBrackets s.Left s.Right )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdLinkBrackets, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sLeft_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "refalrts::link_brackets( ", 25) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_name( n11, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_chars( n13, n14, " );", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_close_bracket( n15 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n15 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, n13, n14 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_stvar( res, sRight_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sLeft_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sElemNumber_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdPushStack s.ElemNumber )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdPushStack, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sElemNumber_1, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "refalrts::push_stack( ", 22) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " );", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sElemNumber_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sElemNumber_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdInsertElem s.ElemNumber )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdInsertElem, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sElemNumber_1, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "res = refalrts::splice_elem( res, ", 34) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " );", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sElemNumber_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sUsings_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdInsertVar s.Usings 'e e.Index )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdInsertVar, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sUsings_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::char_left( 'e', bb_2, be_2 ) )
      break;
    eIndex_b_1 = bb_2;
    eIndex_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "res = refalrts::splice_evar( res, ", 34) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintEVars, "PrintEVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_char( n7, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_chars( n9, n10, " );", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, n9, n10 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sUsings_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdInsertVar s.Usings s.Mode e.Index )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdInsertVar, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sUsings_1, bb_2, be_2 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_2, be_2 ) )
      break;
    eIndex_b_1 = bb_2;
    eIndex_e_1 = be_2;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "res = refalrts::splice_stvar( res, ", 35) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintVar, "PrintVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " );", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sStringNumber_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    // ( e.Indent ) ( & CmdInsertString s.StringNumber )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdInsertString, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sStringNumber_1, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "res = refalrts::splice_evar( res, ", 34) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintStringVar, "PrintStringVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " );", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n2, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sStringNumber_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    static struct r05_node *eIndent_b_4;
    static struct r05_node *eIndent_e_4;
    // ( e.Indent ) ( & CmdReturnResult )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_CmdReturnResult, bb_2, be_2 ) )
      break;
    if (! r05_empty_seq(bb_2, be_2))
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_4, eIndent_e_4, eIndent_b_3, eIndent_e_3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_close_bracket( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "r05_use(&res);", 14) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_chars( n7, n8, "refalrts::splice_to_freelist( arg_begin, arg_end );", 51) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_chars( n11, n12, "return R05_SUCCESS;", 19) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_close_bracket( n13 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n10, n13 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, n11, n12 );
    res = refalrts::splice_evar( res, eIndent_b_4, eIndent_e_4 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, n7, n8 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n2, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::link_brackets( n0, n1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_EscapeString(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eString_b_1;
    static struct r05_node *eString_e_1;
    // e.String
    eString_b_1 = bb_0;
    eString_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_Map, "Map" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_EscapeChar, "EscapeChar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n3 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eString_b_1, eString_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintVar(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sUsings_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    // s.Usings s.Mode e.Index
    if( ! refalrts::svar_left( sUsings_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) )
      break;
    eIndex_b_1 = bb_0;
    eIndex_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_char( n0, '_' ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n3 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintEVar_B(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sUsings_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    // s.Usings s.Mode e.Index
    if( ! refalrts::svar_left( sUsings_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) )
      break;
    eIndex_b_1 = bb_0;
    eIndex_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "_b_", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, n0, n1 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintEVar_E(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sUsings_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    // s.Usings s.Mode e.Index
    if( ! refalrts::svar_left( sUsings_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) )
      break;
    eIndex_b_1 = bb_0;
    eIndex_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "_e_", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, n0, n1 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintEVars(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sUsings_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *sUsings_2;
    static struct r05_node *sMode_2;
    static struct r05_node *eIndex_b_2;
    static struct r05_node *eIndex_e_2;
    // s.Usings s.Mode e.Index
    if( ! refalrts::svar_left( sUsings_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) )
      break;
    eIndex_b_1 = bb_0;
    eIndex_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sUsings_2, sUsings_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sMode_2, sMode_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_PrintEVar_B, "PrintEVar_B" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintEVar_E, "PrintEVar_E" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_stvar( res, sMode_2 );
    res = refalrts::splice_stvar( res, sUsings_2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintMatchSymbol(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sType_1;
    static struct r05_node *eValue_b_1;
    static struct r05_node *eValue_e_1;
    static struct r05_node *sType_2;
    // ( e.Indent ) s.Direction s.BracketNumber s.Type e.Value
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sType_1, bb_0, be_0 ) )
      break;
    eValue_b_1 = bb_0;
    eValue_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sType_2, sType_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_PrintMatch, "PrintMatch" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_SymbolFunc, "SymbolFunc" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_name( n10, r05c_SymbolTextRep, "SymbolTextRep" ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n12 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eValue_b_1, eValue_e_1 );
    res = refalrts::splice_stvar( res, sType_2 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n4, n8 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n2, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_SymbolFunc(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & Char
    if( ! refalrts::function_left( r05c_Char, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "char", 4) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & Number
    if( ! refalrts::function_left( r05c_Number, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "number", 6) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & Name
    if( ! refalrts::function_left( r05c_Name, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "function", 8) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_SymbolTextRep(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sChar_1;
    // & Char s.Char
    if( ! refalrts::function_left( r05c_Char, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sChar_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_char( n0, '\'' ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_EscapeChar, "EscapeChar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_char( n4, '\'' ) )
      return R05_NO_MEMORY;
    res = refalrts::splice_elem( res, n4 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sChar_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sNumber_1;
    // & Number s.Number
    if( ! refalrts::function_left( r05c_Number, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "UL", 2) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n3, n4 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sNumber_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eName_b_1;
    static struct r05_node *eName_e_1;
    // & Name e.Name
    if( ! refalrts::function_left( r05c_Name, bb_0, be_0 ) )
      break;
    eName_b_1 = bb_0;
    eName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "r05c_", 5) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintMatchBrackets(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sInnerNum_1;
    // ( e.Indent ) s.Direction s.BracketNumber s.InnerNum
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sInnerNum_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_PrintMatch, "PrintMatch" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_chars( n5, n6, "brackets", 8) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_name( n9, r05c_BracketsVars, "BracketsVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sInnerNum_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, n5, n6 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n2, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_BreakerFromIndent(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // '    '
    if( ! refalrts::char_left( ' ', bb_0, be_0 ) )
      break;
    if( ! refalrts::char_left( ' ', bb_0, be_0 ) )
      break;
    if( ! refalrts::char_left( ' ', bb_0, be_0 ) )
      break;
    if( ! refalrts::char_left( ' ', bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "break;", 6) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // e.OtherIndent
    // Unused closed variable e.OtherIndent

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "continue;", 9) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintMatchEmpty(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    // ( e.Indent ) s.BracketNumber
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "if (! r05_empty_seq(", 20) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_name( n4, r05c_BracketsVars, "BracketsVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_chars( n6, n7, "))", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_chars( n10, n11, "  ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_name( n13, r05c_BreakerFromIndent, "BreakerFromIndent" ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_close_bracket( n15 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n9, n15 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n12 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, n10, n11 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n0, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, n6, n7 );
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_StrFromDirection(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & AlgLeft
    if( ! refalrts::function_left( r05c_AlgLeft, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "left", 4) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & AlgRight
    if( ! refalrts::function_left( r05c_AlgRight, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "right", 5) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_VarMatchFunction(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // 's'
    if( ! refalrts::char_left( 's', bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "svar", 4) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // 't'
    if( ! refalrts::char_left( 't', bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "tvar", 4) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintMatchSTVar(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *sMode_2;
    // ( e.Indent ) s.Direction s.BracketNumber s.Mode e.Index
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) )
      break;
    eIndex_b_1 = bb_0;
    eIndex_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sMode_2, sMode_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_PrintMatch, "PrintMatch" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_VarMatchFunction, "VarMatchFunction" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_name( n10, r05c_PrintVar, "PrintVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_number( n11, 1UL ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_2 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n4, n8 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n2, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintMatchRepeated(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sUsings_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *sUsings_2;
    static struct r05_node *eIndex_b_2;
    static struct r05_node *eIndex_e_2;
    // ( e.Indent ) s.Direction s.BracketNumber s.Usings 'e e.Index
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sUsings_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::char_left( 'e', bb_0, be_0 ) )
      break;
    eIndex_b_1 = bb_0;
    eIndex_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sUsings_2, sUsings_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_PrintMatch, "PrintMatch" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_chars( n5, n6, "repeated_evar", 13) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_name( n9, r05c_PrintEVars, "PrintEVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_char( n10, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_chars( n12, n13, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_name( n15, r05c_PrintEVars, "PrintEVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_name( n17, r05c_Dec, "Dec" ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_char( n19, 'e' ) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    if( ! refalrts::alloc_close_call( n21 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n21 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n21 );
    refalrts::push_stack( n20 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n16 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_stvar( res, sUsings_2 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, n12, n13 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, n5, n6 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n2, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *sUsings_1;
    static struct r05_node *sMode_1;
    static struct r05_node *eIndex_b_1;
    static struct r05_node *eIndex_e_1;
    static struct r05_node *sUsings_2;
    static struct r05_node *sMode_2;
    static struct r05_node *eIndex_b_2;
    static struct r05_node *eIndex_e_2;
    // ( e.Indent ) s.Direction s.BracketNumber s.Usings s.Mode e.Index
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sUsings_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) )
      break;
    eIndex_b_1 = bb_0;
    eIndex_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sUsings_2, sUsings_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sMode_2, sMode_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_PrintMatch, "PrintMatch" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_chars( n5, n6, "repeated_stvar", 14) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_name( n9, r05c_PrintVar, "PrintVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_chars( n11, n12, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_name( n14, r05c_PrintVar, "PrintVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_open_call( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_name( n16, r05c_Dec, "Dec" ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_close_call( n17 ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return R05_NO_MEMORY;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_close_call( n19 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n19 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_stvar( res, sMode_2 );
    refalrts::push_stack( n17 );
    refalrts::push_stack( n15 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_stvar( res, sUsings_2 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, n11, n12 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_stvar( res, sUsings_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, n5, n6 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    refalrts::link_brackets( n2, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintMatch(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sDirection_1;
    static struct r05_node *sBracketNumber_1;
    static struct r05_node *eFunction_b_1;
    static struct r05_node *eFunction_e_1;
    static struct r05_node *eTextRep_b_1;
    static struct r05_node *eTextRep_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *eIndent_b_3;
    static struct r05_node *eIndent_e_3;
    // ( e.Indent ) s.Direction s.BracketNumber ( e.Function ) e.TextRep
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sDirection_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sBracketNumber_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    eFunction_b_1 = bb_2;
    eFunction_e_1 = be_2;
    eTextRep_b_1 = bb_0;
    eTextRep_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eIndent_b_3, eIndent_e_3, eIndent_b_2, eIndent_e_2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "if( ! refalrts::", 16) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_char( n3, '_' ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_name( n5, r05c_StrFromDirection, "StrFromDirection" ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_chars( n7, n8, "( ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_chars( n9, n10, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_name( n12, r05c_BracketsVars, "BracketsVars" ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_chars( n14, n15, " ) )", 4) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    if( ! refalrts::alloc_close_bracket( n16 ) )
      return R05_NO_MEMORY;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_open_bracket( n17 ) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    struct r05_node *n19 = 0;
    if( ! refalrts::alloc_chars( n18, n19, "  ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n20 = 0;
    if( ! refalrts::alloc_open_call( n20 ) )
      return R05_NO_MEMORY;
    struct r05_node *n21 = 0;
    if( ! refalrts::alloc_name( n21, r05c_BreakerFromIndent, "BreakerFromIndent" ) )
      return R05_NO_MEMORY;
    struct r05_node *n22 = 0;
    if( ! refalrts::alloc_close_call( n22 ) )
      return R05_NO_MEMORY;
    struct r05_node *n23 = 0;
    if( ! refalrts::alloc_close_bracket( n23 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n17, n23 );
    res = refalrts::splice_elem( res, n23 );
    refalrts::push_stack( n22 );
    refalrts::push_stack( n20 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_evar( res, eIndent_b_3, eIndent_e_3 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, n18, n19 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n17 );
    refalrts::link_brackets( n0, n16 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, n14, n15 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_stvar( res, sBracketNumber_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, n9, n10 );
    res = refalrts::splice_evar( res, eTextRep_b_1, eTextRep_e_1 );
    res = refalrts::splice_evar( res, n7, n8 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_stvar( res, sDirection_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eFunction_b_1, eFunction_e_1 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintElemVar(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sNumber_1;
    // s.Number
    if( ! refalrts::svar_left( sNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_char( n0, 'n' ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n3 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNumber_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintStringVar(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sNumber_1;
    static struct r05_node *sNumber_2;
    // s.Number
    if( ! refalrts::svar_left( sNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sNumber_2, sNumber_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_char( n0, 'n' ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_name( n2, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_chars( n4, n5, ", n", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_name( n7, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_name( n9, r05c_Inc, "Inc" ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sNumber_2 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, n4, n5 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNumber_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintAllocateElem(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *sElemNumber_1;
    static struct r05_node *sElementType_1;
    static struct r05_node *eInfo_b_1;
    static struct r05_node *eInfo_e_1;
    static struct r05_node *eIndent_b_2;
    static struct r05_node *eIndent_e_2;
    static struct r05_node *sElementType_2;
    static struct r05_node *eInfo_b_2;
    static struct r05_node *eInfo_e_2;
    // ( e.Indent ) s.ElemNumber s.ElementType e.Info
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    if( ! refalrts::svar_left( sElemNumber_1, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sElementType_1, bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_0;
    eInfo_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eIndent_b_2, eIndent_e_2, eIndent_b_1, eIndent_e_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_stvar( sElementType_2, sElementType_1 ) )
      return R05_NO_MEMORY;
    if( ! refalrts::copy_evar( eInfo_b_2, eInfo_e_2, eInfo_b_1, eInfo_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_PrintAllocate_Aux, "PrintAllocate_Aux" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_SwAllocator, "SwAllocator" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_name( n11, r05c_SwInfo, "SwInfo" ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_close_bracket( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_open_bracket( n15 ) )
      return R05_NO_MEMORY;
    struct r05_node *n16 = 0;
    struct r05_node *n17 = 0;
    if( ! refalrts::alloc_chars( n16, n17, "  return R05_NO_MEMORY;", 23) )
      return R05_NO_MEMORY;
    struct r05_node *n18 = 0;
    if( ! refalrts::alloc_close_bracket( n18 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n15, n18 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, n16, n17 );
    res = refalrts::splice_evar( res, eIndent_b_2, eIndent_e_2 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::link_brackets( n9, n13 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eInfo_b_2, eInfo_e_2 );
    res = refalrts::splice_stvar( res, sElementType_2 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n4, n8 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sElementType_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sElemNumber_1 );
    refalrts::link_brackets( n2, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_PrintAllocate_Aux(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eIndent_b_1;
    static struct r05_node *eIndent_e_1;
    static struct r05_node *eConstructor_b_1;
    static struct r05_node *eConstructor_e_1;
    static struct r05_node *eValue_b_1;
    static struct r05_node *eValue_e_1;
    static struct r05_node *sElemNumber_1;
    // ( e.Indent ) s.ElemNumber ( e.Constructor ) ( e.Value )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_right( bb_2, be_2, bb_0, be_0 ) )
      break;
    struct r05_node *bb_3 = 0;
    struct r05_node *be_3 = 0;
    if( ! refalrts::brackets_right( bb_3, be_3, bb_0, be_0 ) )
      break;
    eIndent_b_1 = bb_1;
    eIndent_e_1 = be_1;
    eConstructor_b_1 = bb_3;
    eConstructor_e_1 = be_3;
    eValue_b_1 = bb_2;
    eValue_e_1 = be_2;
    if( ! refalrts::svar_left( sElemNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "if( ! refalrts::", 16) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_chars( n3, n4, "( ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_PrintElemVar, "PrintElemVar" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    struct r05_node *n9 = 0;
    if( ! refalrts::alloc_chars( n8, n9, " ) )", 4) )
      return R05_NO_MEMORY;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n0, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, n8, n9 );
    res = refalrts::splice_evar( res, eValue_b_1, eValue_e_1 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sElemNumber_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, n3, n4 );
    res = refalrts::splice_evar( res, eConstructor_b_1, eConstructor_e_1 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_evar( res, eIndent_b_1, eIndent_e_1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_SwAllocator(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sChar_1;
    // & ElSymbol & Char s.Char
    if( ! refalrts::function_left( r05c_ElSymbol, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_Char, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sChar_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "alloc_char", 10) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & ElSymbol & Name e.Name
    if( ! refalrts::function_left( r05c_ElSymbol, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_Name, bb_0, be_0 ) )
      break;
    // Unused closed variable e.Name

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "alloc_name", 10) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sNumber_1;
    // & ElSymbol & Number s.Number
    if( ! refalrts::function_left( r05c_ElSymbol, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_Number, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNumber_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "alloc_number", 12) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & ElOpenBracket
    if( ! refalrts::function_left( r05c_ElOpenBracket, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "alloc_open_bracket", 18) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & ElCloseBracket
    if( ! refalrts::function_left( r05c_ElCloseBracket, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "alloc_close_bracket", 19) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & ElOpenCall
    if( ! refalrts::function_left( r05c_ElOpenCall, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "alloc_open_call", 15) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    // & ElCloseCall
    if( ! refalrts::function_left( r05c_ElCloseCall, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, "alloc_close_call", 16) )
      return R05_NO_MEMORY;
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_SwInfo(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eName_b_1;
    static struct r05_node *eName_e_1;
    static struct r05_node *eName_b_2;
    static struct r05_node *eName_e_2;
    // & ElSymbol & Name e.Name
    if( ! refalrts::function_left( r05c_ElSymbol, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_Name, bb_0, be_0 ) )
      break;
    eName_b_1 = bb_0;
    eName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_evar( eName_b_2, eName_e_2, eName_b_1, eName_e_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, ", r05c_", 7) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_chars( n2, n3, ", \"", 3) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_char( n4, '\"' ) )
      return R05_NO_MEMORY;
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eName_b_2, eName_e_2 );
    res = refalrts::splice_evar( res, n2, n3 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sType_1;
    static struct r05_node *eValue_b_1;
    static struct r05_node *eValue_e_1;
    // & ElSymbol s.Type e.Value
    if( ! refalrts::function_left( r05c_ElSymbol, bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sType_1, bb_0, be_0 ) )
      break;
    eValue_b_1 = bb_0;
    eValue_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_chars( n0, n1, ", ", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_name( n3, r05c_SymbolTextRep, "SymbolTextRep" ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eValue_b_1, eValue_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, n0, n1 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sOther_1;
    // s.Other
    if( ! refalrts::svar_left( sOther_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_BeginNative(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_EndNative(struct r05_node *, struct r05_node *) {
  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenNative(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sNativeLineNo_1;
    static struct r05_node *eCode_b_1;
    static struct r05_node *eCode_e_1;
    // s.NativeLineNo e.Code
    if( ! refalrts::svar_left( sNativeLineNo_1, bb_0, be_0 ) )
      break;
    eCode_b_1 = bb_0;
    eCode_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_BeginNative, "BeginNative" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_bracket( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_name( n4, r05c_EndNative, "EndNative" ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eCode_b_1, eCode_e_1 );
    refalrts::link_brackets( n0, n2 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sNativeLineNo_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

enum r05_fnresult r05c_GenPostprocess(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eSrcName_b_1;
    static struct r05_node *eSrcName_e_1;
    static struct r05_node *eOutputName_b_1;
    static struct r05_node *eOutputName_e_1;
    static struct r05_node *eLines_B_b_1;
    static struct r05_node *eLines_B_e_1;
    static struct r05_node *eLines_E_b_1;
    static struct r05_node *eLines_E_e_1;
    // ( e.SrcName ) ( e.OutputName ) e.Lines_B ( & EndNative ) e.Lines_E
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    eSrcName_b_1 = bb_1;
    eSrcName_e_1 = be_1;
    eOutputName_b_1 = bb_2;
    eOutputName_e_1 = be_2;
    eLines_B_b_1 = 0;
    eLines_B_e_1 = 0;
    refalrts::start_e_loop();
    do {
      struct r05_node *bb_3 = bb_0;
      struct r05_node *be_3 = be_0;
      struct r05_node *bb_4 = 0;
      struct r05_node *be_4 = 0;
      if( ! refalrts::brackets_left( bb_4, be_4, bb_3, be_3 ) )
        continue;
      if( ! refalrts::function_left( r05c_EndNative, bb_4, be_4 ) )
        continue;
      if (! r05_empty_seq(bb_4, be_4))
        continue;
      eLines_E_b_1 = bb_3;
      eLines_E_e_1 = be_3;

      refalrts::reset_allocator();
      struct r05_node *res = arg_begin;
      struct r05_node *n0 = 0;
      if( ! refalrts::alloc_open_call( n0 ) )
        return R05_NO_MEMORY;
      struct r05_node *n1 = 0;
      if( ! refalrts::alloc_name( n1, r05c_DelAccumulator, "DelAccumulator" ) )
        return R05_NO_MEMORY;
      struct r05_node *n2 = 0;
      if( ! refalrts::alloc_open_call( n2 ) )
        return R05_NO_MEMORY;
      struct r05_node *n3 = 0;
      if( ! refalrts::alloc_name( n3, r05c_MapReduce, "MapReduce" ) )
        return R05_NO_MEMORY;
      struct r05_node *n4 = 0;
      if( ! refalrts::alloc_open_bracket( n4 ) )
        return R05_NO_MEMORY;
      struct r05_node *n5 = 0;
      if( ! refalrts::alloc_name( n5, r05c_EnumerateLines, "EnumerateLines" ) )
        return R05_NO_MEMORY;
      struct r05_node *n6 = 0;
      if( ! refalrts::alloc_open_bracket( n6 ) )
        return R05_NO_MEMORY;
      struct r05_node *n7 = 0;
      if( ! refalrts::alloc_close_bracket( n7 ) )
        return R05_NO_MEMORY;
      struct r05_node *n8 = 0;
      if( ! refalrts::alloc_open_bracket( n8 ) )
        return R05_NO_MEMORY;
      struct r05_node *n9 = 0;
      if( ! refalrts::alloc_close_bracket( n9 ) )
        return R05_NO_MEMORY;
      struct r05_node *n10 = 0;
      if( ! refalrts::alloc_close_bracket( n10 ) )
        return R05_NO_MEMORY;
      struct r05_node *n11 = 0;
      if( ! refalrts::alloc_number( n11, 1UL ) )
        return R05_NO_MEMORY;
      struct r05_node *n12 = 0;
      if( ! refalrts::alloc_open_call( n12 ) )
        return R05_NO_MEMORY;
      struct r05_node *n13 = 0;
      if( ! refalrts::alloc_name( n13, r05c_GenCommonHeaders, "GenCommonHeaders" ) )
        return R05_NO_MEMORY;
      struct r05_node *n14 = 0;
      if( ! refalrts::alloc_close_call( n14 ) )
        return R05_NO_MEMORY;
      struct r05_node *n15 = 0;
      if( ! refalrts::alloc_open_bracket( n15 ) )
        return R05_NO_MEMORY;
      struct r05_node *n16 = 0;
      if( ! refalrts::alloc_name( n16, r05c_EndNative, "EndNative" ) )
        return R05_NO_MEMORY;
      struct r05_node *n17 = 0;
      if( ! refalrts::alloc_close_bracket( n17 ) )
        return R05_NO_MEMORY;
      struct r05_node *n18 = 0;
      if( ! refalrts::alloc_open_call( n18 ) )
        return R05_NO_MEMORY;
      struct r05_node *n19 = 0;
      if( ! refalrts::alloc_name( n19, r05c_GenCommonTailer, "GenCommonTailer" ) )
        return R05_NO_MEMORY;
      struct r05_node *n20 = 0;
      if( ! refalrts::alloc_close_call( n20 ) )
        return R05_NO_MEMORY;
      struct r05_node *n21 = 0;
      if( ! refalrts::alloc_close_call( n21 ) )
        return R05_NO_MEMORY;
      struct r05_node *n22 = 0;
      if( ! refalrts::alloc_close_call( n22 ) )
        return R05_NO_MEMORY;
      refalrts::push_stack( n22 );
      refalrts::push_stack( n0 );
      res = refalrts::splice_elem( res, n22 );
      refalrts::push_stack( n21 );
      refalrts::push_stack( n2 );
      res = refalrts::splice_elem( res, n21 );
      refalrts::push_stack( n20 );
      refalrts::push_stack( n18 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      res = refalrts::splice_elem( res, n18 );
      res = refalrts::splice_evar( res, eLines_E_b_1, eLines_E_e_1 );
      refalrts::link_brackets( n15, n17 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_elem( res, n16 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_evar( res, eLines_B_b_1, eLines_B_e_1 );
      refalrts::push_stack( n14 );
      refalrts::push_stack( n12 );
      res = refalrts::splice_elem( res, n14 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n11 );
      refalrts::link_brackets( n4, n10 );
      res = refalrts::splice_elem( res, n10 );
      refalrts::link_brackets( n8, n9 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eOutputName_b_1, eOutputName_e_1 );
      res = refalrts::splice_elem( res, n8 );
      refalrts::link_brackets( n6, n7 );
      res = refalrts::splice_elem( res, n7 );
      res = refalrts::splice_evar( res, eSrcName_b_1, eSrcName_e_1 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_elem( res, n5 );
      res = refalrts::splice_elem( res, n4 );
      res = refalrts::splice_elem( res, n3 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n1 );
      res = refalrts::splice_elem( res, n0 );
      r05_use(&res);
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return R05_SUCCESS;
    } while ( refalrts::open_evar_advance( eLines_B_b_1, eLines_B_e_1, bb_0, be_0 ) );
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eLines_b_1;
    static struct r05_node *eLines_e_1;
    // ( e.SrcName ) ( e.OutputName ) e.Lines
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    // Unused closed variable e.SrcName
    // Unused closed variable e.OutputName
    eLines_b_1 = bb_0;
    eLines_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_GenCommonHeaders, "GenCommonHeaders" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_name( n4, r05c_GenCommonTailer, "GenCommonTailer" ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eLines_b_1, eLines_e_1 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_EnumerateLines(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eSrcName_b_1;
    static struct r05_node *eSrcName_e_1;
    static struct r05_node *sLineNo_1;
    static struct r05_node *sNativeLineNo_1;
    // ( e.SrcName ) ( e.OutputName ) s.LineNo ( & BeginNative s.NativeLineNo )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    struct r05_node *bb_3 = 0;
    struct r05_node *be_3 = 0;
    if( ! refalrts::brackets_right( bb_3, be_3, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_BeginNative, bb_3, be_3 ) )
      break;
    eSrcName_b_1 = bb_1;
    eSrcName_e_1 = be_1;
    // Unused closed variable e.OutputName
    if( ! refalrts::svar_left( sLineNo_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;
    if( ! refalrts::svar_left( sNativeLineNo_1, bb_3, be_3 ) )
      break;
    if (! r05_empty_seq(bb_3, be_3))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_Inc, "Inc" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_name( n4, r05c_LineDirective, "LineDirective" ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eSrcName_b_1, eSrcName_e_1 );
    res = refalrts::splice_stvar( res, sNativeLineNo_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sLineNo_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eOutputName_b_1;
    static struct r05_node *eOutputName_e_1;
    static struct r05_node *sLineNo_1;
    static struct r05_node *sLineNo_2;
    // ( e.SrcName ) ( e.OutputName ) s.LineNo ( & EndNative )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    struct r05_node *bb_3 = 0;
    struct r05_node *be_3 = 0;
    if( ! refalrts::brackets_right( bb_3, be_3, bb_0, be_0 ) )
      break;
    if( ! refalrts::function_left( r05c_EndNative, bb_3, be_3 ) )
      break;
    if (! r05_empty_seq(bb_3, be_3))
      break;
    // Unused closed variable e.SrcName
    eOutputName_b_1 = bb_2;
    eOutputName_e_1 = be_2;
    if( ! refalrts::svar_left( sLineNo_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    if( ! refalrts::copy_stvar( sLineNo_2, sLineNo_1 ) )
      return R05_NO_MEMORY;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_Inc, "Inc" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_name( n4, r05c_LineDirective, "LineDirective" ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return R05_NO_MEMORY;
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eOutputName_b_1, eOutputName_e_1 );
    res = refalrts::splice_stvar( res, sLineNo_2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sLineNo_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *eLine_b_1;
    static struct r05_node *eLine_e_1;
    static struct r05_node *sLineNo_1;
    // ( e.SrcName ) ( e.OutputName ) s.LineNo ( e.Line )
    struct r05_node *bb_1 = 0;
    struct r05_node *be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) )
      break;
    struct r05_node *bb_2 = 0;
    struct r05_node *be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) )
      break;
    struct r05_node *bb_3 = 0;
    struct r05_node *be_3 = 0;
    if( ! refalrts::brackets_right( bb_3, be_3, bb_0, be_0 ) )
      break;
    // Unused closed variable e.SrcName
    // Unused closed variable e.OutputName
    eLine_b_1 = bb_3;
    eLine_e_1 = be_3;
    if( ! refalrts::svar_left( sLineNo_1, bb_0, be_0 ) )
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_call( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    if( ! refalrts::alloc_name( n1, r05c_Inc, "Inc" ) )
      return R05_NO_MEMORY;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_close_call( n2 ) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_close_bracket( n4 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n3, n4 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eLine_b_1, eLine_e_1 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n0 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sLineNo_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}

static enum r05_fnresult r05c_LineDirective(struct r05_node *arg_begin, struct r05_node *arg_end) {
  refalrts::this_is_generated_function();
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    refalrts::start_sentence();
    static struct r05_node *sLineNo_1;
    static struct r05_node *eFileName_b_1;
    static struct r05_node *eFileName_e_1;
    // s.LineNo e.FileName
    if( ! refalrts::svar_left( sLineNo_1, bb_0, be_0 ) )
      break;
    eFileName_b_1 = bb_0;
    eFileName_e_1 = be_0;

    refalrts::reset_allocator();
    struct r05_node *res = arg_begin;
    struct r05_node *n0 = 0;
    if( ! refalrts::alloc_open_bracket( n0 ) )
      return R05_NO_MEMORY;
    struct r05_node *n1 = 0;
    struct r05_node *n2 = 0;
    if( ! refalrts::alloc_chars( n1, n2, "#line ", 6) )
      return R05_NO_MEMORY;
    struct r05_node *n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return R05_NO_MEMORY;
    struct r05_node *n4 = 0;
    if( ! refalrts::alloc_name( n4, r05c_StrFromInt, "StrFromInt" ) )
      return R05_NO_MEMORY;
    struct r05_node *n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return R05_NO_MEMORY;
    struct r05_node *n6 = 0;
    if( ! refalrts::alloc_name( n6, r05c_Inc, "Inc" ) )
      return R05_NO_MEMORY;
    struct r05_node *n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return R05_NO_MEMORY;
    struct r05_node *n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return R05_NO_MEMORY;
    struct r05_node *n9 = 0;
    struct r05_node *n10 = 0;
    if( ! refalrts::alloc_chars( n9, n10, " \"", 2) )
      return R05_NO_MEMORY;
    struct r05_node *n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return R05_NO_MEMORY;
    struct r05_node *n12 = 0;
    if( ! refalrts::alloc_name( n12, r05c_EscapeString, "EscapeString" ) )
      return R05_NO_MEMORY;
    struct r05_node *n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return R05_NO_MEMORY;
    struct r05_node *n14 = 0;
    if( ! refalrts::alloc_char( n14, '\"' ) )
      return R05_NO_MEMORY;
    struct r05_node *n15 = 0;
    if( ! refalrts::alloc_close_bracket( n15 ) )
      return R05_NO_MEMORY;
    refalrts::link_brackets( n0, n15 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eFileName_b_1, eFileName_e_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, n9, n10 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sLineNo_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    r05_use(&res);
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return R05_SUCCESS;
  } while ( 0 );

  return (enum r05_fnresult)(
    R05_RECOGNITION_IMPOSSIBLE | (__LINE__ << 8)
  );
}


//End of file
