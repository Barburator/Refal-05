  Цель лабы.
  Целью данной лабы было преобразование имеющегося компилятора Простого Рефала,
генерирующего код на Си++ в компилятор того же языка, генерирующий код на C#.
  Лаба проводилась в весеннем семестре 2010 года совместно со студенкой 5 курса
кафедры ИУ9 Быкадоровой Натальей, за что я ей выражаю огромную благодарность.
Наталья, помимо всего прочего, выполнила титаническую работу по перекодированию
скучных участков кода с языка Си++ на Си Шарп (см. ниже).
  Достаточно подробный отчёт по работе приведён пояснительной записке к курсо-
вому проекту (файл РПЗ_Быкадорова.doc), поэтому здесь я опишу только те особен-
ности которые или не вошли в записку, или мне показались особо интересными (см.
Выводы). Дальнейшие ссылки на расчётно-пояснительную записку будут оформляться
как (РПЗ).

  Выводы.
  1. Преобразование компилятора не ограничилось только переписыванием кодогене-
ратора (Generator.sref), рантайма (refalrts.cs), библиотеки базовых функций
(Library.cs) и поиска исходных текстов (т.к. расширение выходных файлов смени-
лось с .cpp на .cs). Потребовалось внести ряд изменений в Algorithm.sref, дабы
учесть уровень вложенности циклов по открытым e-переменным (РПЗ), была выкинута
поддержка режима интерпретации (см. ниже), также модификации подверглись
Driver.sref и SymTable.sref (см. ниже).
  2. Не смотря на то, что синтаксис Простого Рефала отчасти наследует ограниче-
ния языка Си++, в частности требование предобъявления всех используемых сущнос-
тей (функции и идентификаторы-метки), при переходе к целевому языку, лишённому
этих недостатков, синтаксис решено было не менять. Решение было продиктовано
двумя соображениями: (1) нежелание плодить несколько версий я з ы к а  и обрат-
ная совместимость, (2) ускорение разработки, т.к. изменение лексера и парсера
--- это ненужные времязатраты.
  3. Поскольку задача оптимизации не ставилась, то в предпоследней версии (та,
с которой защищалась Наталья), даже отсутствовал профилировщик. По этой же при-
чине (не ставилась задача оптимизации), а также, чтобы тоже ускорить разработ-
ку, режим интерпретации Сухарева также был выкинут.
  Позже профилировщик всё-таки был добавлен. Как выяснилось, общее время работы
компилятора на Си Шарпе примерно в два раза больше, чем общее время работы ком-
пилятора на Си++, причём чистое время работы сопоставимо. Объясняется это, ско-
рее всего, тем, что объектно-ориентированная библиотека .NET Framework работает
медленнее, чем стандартная библиотека языка Си.
  4. Для сохранения семантики локальных функций (в разных файлах исходного тек-
ста, компилируемых независимо в целевой язык), пришлось в имена классов, реали-
зующих функции добавлять имя файла исходного текста. Для этой цели пришлось из-
менить таблицу символов, чтобы та хранила имя файла, а также Driver.sref, в ко-
тором эта особенность должна учитываться.
  5. Сделана одна мелкая, но приятная оптимизация. В случае функций вида

  F {
    ....
    e.X = ...;
  }

т.е. когда последнее предложение перехватывает все возможные случаи аргумента,
в конце тела функции (метода perform класса функции) последний оператор return
RefalRTS.FnResult.RecognitionImpossible не генерируется (точнее, генерируется
закомментированным). Сделано это не из хорошей жизни, а чтобы подавить лишние
предупреждения компилятора.
  6. Кодогенератор не претерпел никаких существенных идеологических изменений,
хотя технически в нём переделано было не мало. Объясняется это только тем, что
надо генерировать другой (хоть и похожий) целевой код и для сохранения указате-
лей разбора (bb_..., be_...) был добавлен уровень вложенности.
  Кстати, об этих указателях. Уровень вложенности был добавлен точно также, как
и в back-end'е C++/SR Модульного Рефала, а именно, путём модификации формата
команд --- фактически текстовой замены переменной s.BracketNumber на пару пере-
менных s.BracketNum s.Nested, что потребовало существенную переработку кода. В
то же время можно было не переделывать огромный массив кода, т.к. Простой Рефал
уже поддерживает вложенные функции и, представив s.BracketNumber функцией-объ-
ектом, можно в неё упихнуть всё, что угодно. Таким образом в исследовании опти-
мизации результатного выражения (Simple Refal.006 OR) в переменную s.Direction
было упаковано не только направление разбора (что было раньше), но и номер пе-
ременной, в которую сохраняется указатель на распознаваемый объект.
  7. По своему устройству рантайм во многом повторяет особенности рантайма Про-
стого Рефала (Си++). Основное отличие заключается в том, что узлы двусвязного
списка представляют собой структуры, которые находятся в большом массиве, и для
ссылок на них используются не указатели (которых в C# нету), а целочисленный
индекс массива. Кроме того, контенты замыканий реализованы также, как и тела
статических ящиков (часть поля зрения), а не циклические списки, висящие на уз-
лах-замыканиях.
  В остальных аспектах рантайм фактически представляет собой дословный перевод
исходного рантайма с Си++ на Си Шарп. Задачу по ручному перекодированию рантай-
ма с одного языка на другой выполнила Наталья, за что ей, как уже было сказано,
я выражаю огромную благодарность.
  К сожалению, при таком подходе рантайм унаследовал существенный недостаток
Простого Рефала: рантайм подразумевает существование только одного поля зрения,
которое является глобальным, в отличии от Рефала 2, в котором возможно попере-
менное использование нескольких процессов (совокупность поля зрения и копилки).
Рантайм представляет собой класс RefalRTS со статическими функциями и статичес-
кими членами данных, что несколько не вписывается в дух объектно-ориентирован-
ного программирования. Поэтому если рантайм для Простого Рефала (Си++) был на-
писан в духе Си, что вполне приемлемо, такое построение рантайма для Си Шарпа
выглядит как-то криво.
  Помимо эстетической кривизны, поддержка времени выполнения с единственным по-
лем зрения затрудняет написание функций на Си Шарпе, которые для выполнения
своих задач используют функции, написанные на Рефале. На данный момент обе реа-
лизации Простого Рефала (Си++ и Си Шарп) подразумевают то, что код, написанный
на целевом языке, занимает подчинительное положение по отношению к коду на Ре-
фале, в то время как в Рефале 2 код на Рефале и Си в данном аспекте симметричны
по отношению друг ко другу.
  8. Библиотека написана в том же духе, что и у предыдущих реализаций. Сначала
писалась заготовка функции на Рефале, описывающая внешний вид образца и резуль-
тата. Затем в эту заготовку, в код стадии сопоставления с образцом, распределе-
ния памяти и сборки результата, добавляются, соответственно, дополнительные
проверки (например, для арифметических функций --- что аргументы являются чис-
лами), дополнительные операции распределения памяти и как-то модифицируются
операции сборки.
  9. Одной из интересных идей, которые были воплощены в этой версии Простого
Рефала, является концепция т.н. дескрипторов. Дело в том, что в отличии от
предыдущих версий, где поле информации представляется как объединение (union)
нескольких полей разных типов, здесь поле информации представляет собой пару
полей целочисленного типа и указателя (объектной ссылки) на базовый класс функ-
ции (РПЗ).
  Библиотека Простого Рефала подразумевает наличие типа дескриптора открытого
файла. Этот дескриптор создаётся функцией FOpen, используется функциями
FReadLine и FWriteLine и закрывается функцией FClose. Реализован как одно из
полей объединения типа void*, который на самом деле содержит указатель FILE*
стандартной библиотеки языков Си и Си++. Сначала дескрипторы открытых файлов
для Простого Рефала (Си Шарп) реализовать по аналогии --- включив в структуру
поля для файловых потоков ввода и вывода. Очевидно, что в таком случае возник-
нет огромный расход памяти, поскольку атомы-файлы используются редко, поэтому
соответствующие поля почти всегда не будут использоваться. К тому же, такой
подход не является расширяемым --- при добавлении нового встроенного типа пот-
ребует модификации рантайма (тот же недостаток есть у Простого Рефала (Си++)).
  Лирическое отступление. В языках, содержащих вложенные функции (диалекты Лис-
па, Рефал 7 и Простой Рефал), можно посредством замыканий реализовывать объект-
но-ориентированный подход, при котором замыкание при вызове принимает имя ме-
тода и аргументы, специфичные для данного метода. Подробнее об этом можно про-
читать в note003.txt. Это и наткнуло меня на идею.
  Поэтому возникла идея использовать указатели на базовый класс функции, кото-
рый имеет виртуальную функцию perform, способную работать с полем зрения (вир-
туальая функция string func_name() выполняет исключительно служебную задачу,
поэтому в данном контексте не интересна). Непосредственная реализация идиомы
ООП, т.е. размещение дескрипторов файлов справа от скобки вызова, т.е. с форма-
том
  <s.Handle FWriteLine e.Line>
приведёт к тому, что функции FWriteLine перейдут из первичных в разряд написан-
ных на Рефале, что, по моему мнению, некрасиво. К тому же в этом случае деск-
рипторы станут фактически неотличимы от функций --- различие между ними будет
только в теге. К тому же, потеряется контроль типов --- внутри s.Handle вместо
реального дескриптора можно будет передать всё, что угодно.
  Поэтому был разработан другой подход. Атомы-дескрипторы используют тип узла
RefalRTS.DataTag.Handle, при этом не могут располагаться справа <. Существуют
функции с именами FWriteLine, FReadLine и FClose, которые вызывают функцию
perform узла, передавая ей свой аргумент. Псевдокод:

  public class global_FWriteLine : RefalRTS.Function
  {
    ...
    public override RefalRTS.FnResult perform(
      UInt64 arg_begin, UInt64 arg_end
    ) {
      UInt64 handle = узел слева от имени функции, т.е. в начале аргумента.
      if( ! handle --- дескриптор )
        return RefalRTS.FnResult.RecognitionImpossible;

      return handle.perform(arg_begin, arg_end);
    }
    ...
  }

  Таким образом, функция дескриптора perform может в дальнейшем проверить, что
слева от < находится имя функции FWriteLine, проанализировать дальнейший формат
функции и выполнить характерные для данного метода действия. Для файла, откры-
того для записи --- это запись строки в файл. Если же дескриптор не поддержива-
ет метод FWriteLine (т.е. не ожидает слева от скобки вызова это имя), то вполне
закономерно возвратит RecognitionImpossible. Так себя ведёт дескриптор открыто-
го для чтения файла. 
  В отличии от объектов функций, которые являются глобальными для программы и
реализованы при помощи модификации паттерна Singleton, объекты-дескрипторы рас-
пределяются в куче и уничтожаются сборщиком мусора .NET.
  Можно заметить, что данный подход преодолевает оба вышеперечисленных недоста-
тка: не требует дополнительных затрат памяти и прекрасно расширяем. Действите-
льно, функции FWriteLine, FReadLine и FClose ничего не знают о семантике конк-
ретных дескрипторов, а только перенаправляют запросы.
  Таким образом, можно выделить три основных компонента, из которых "состоит"
дескриптор:
  1) класс дескриптора. Класс должен быть наследником от RefalRTS.Function и
переопределять методы perform и func_name. Как правило, конструктор принимает
параметры, описывающие сам дескриптор. Например, дескрипторы файлов, открытых
для чтения и записи, принимают имя файла. Функция perform должна в качестве
аргумента [arg_begin, arg_end] принимать стоки вида
  <s.Accessor e.SpecificArguments>,
где s.Accessor --- имя функции-акцессора, e.SpecificArguments --- аргументы ак-
цессора, включающие в себя и сам узел дескриптора. Например, дескриптор файла
для записи принимает аргументы
  <FWriteLine s.Handle e.Line> и
  <FClose s.Handle>;
  2) функция-конструктор --- это та функция, которая создаёт и инициализирует
узел-дескриптор. В библиотеке это функция FOpen;
  3) функции-акцессоры. Строго говоря, акцессоры, поскольку они не содержат
специфической семантики, могут разделяться между разными типами дескрипторов.
В библиотеке разделяется акцессор для FClose.
  10. Следует заметить, что в этой версии в библиотеке оказались нереализован-
ными функции SymbType и SymbCompare, которые при вызове падают с ошибкой. Воз-
можно в дальнейшем они появятся.
