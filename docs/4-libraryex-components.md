Библиотека `LibraryEx` и библиотека компонентов компилятора
===========================================================

В данном разделе будут рассмотрены исходные тексты, лежащие в каталоге `src`
дистрибутива Рефала-05. В частности, там располагается библиотека `LibraryEx`
с полезными вспомогательными функциями и интерфейсы исходных текстов компонентов
компилятора.

В библиотеке `LibraryEx` находится несколько полезных функций вроде функции
инкремента, загрузки всего содержимого текстового файла и набора функций высшего
порядка — функции мелкие и простые, но при этом сокращают набор кода и упрощают
программу.

Компилятор построен как набор повторно используемых компонент: синтаксического
дерева, лексического и синтаксического анализаторов, генератора кода и набора
утилитарных функций. Эти компоненты можно использовать как библиотеки при
написании других инструментальных средств для работы с Рефалом-05. Мотивация
такого подхода описана [в первом разделе](1-intro.md).

Все компоненты, рассматриваемые здесь, написаны на общем подмножестве Рефала-05
и Рефала-5, а это значит, что их можно использовать и при программировании
на Рефале-5 тоже. Более того, если для раскрутки компилятора использовался
Рефал-5, то скомпилированные `.rsl`-ки рассматриваемых библиотек лежат в папке
`bin`, а это значит, что её можно добавить в переменную `REF5RSL`. Об этом
говорилось в [разделе установки](3-install-and-usage.md), но повторить лишним
не будет.

**Интерфейс рассматриваемых библиотек может меняться в будущих версиях, что
не всегда будет вовремя отражаться в документации. Поэтому сверяйтесь
с комментариями в исходных текстах.**


Библиотека `LibraryEx`
----------------------

В отличие от библиотеки встроенных функций `Library`, библиотека `LibraryEx`
написана на Рефале без нативных вставок, а значит, принципиально новых
возможностей не несёт. Всё, что в ней есть — это надстройки над встроенными
функциями и другие функции, облегчающие программирование на Рефале.

Средства библиотеки можно условно разделить на две группы: утилитарные функции
и функции высшего порядка. Первые облегчают выполнение некоторых часто
встречающихся задач, вторые инкапсулируют циклы при обработке последовательностей
однородных термов. Поэтому рассмотрим их по отдельности.

**Примечание.** Есть одноимённая библиотека `LibraryEx` в Рефале-5λ, библиотека
Рефала-05 была написана на основе неё. В библиотеке Рефала-5λ имеется гораздо
больше функций, которые не были перенесены в Рефал-05 из соображений минимализма.
Кроме того, эти библиотеки **несовместимы в части функций высшего порядка** —
в Рефале-05 для косвенного вызова используется функция `Mu`, Рефал-5λ функцию
`Mu` не использует. Это надо иметь ввиду.


### Утилитарные функции

#### Пустые функции `Success` и `Fails`

    *$EENUM Success, Fails

Две пустые функции, часто используемые в исходных текстах компилятора как
признак успешного и неуспешного выполнения. Типичный формат функции,
использующей эти признаки:

    <SomeFunc e.SomeArgs>
      == Success e.SuccessfulResult
      == Fails e.ErrorInfo

#### Функция `LoadFile`

    <LoadFile e.FileName> == e.Lines

    e.Lines ::= (e.Line)*
    e.Line ::= s.CHAR*

Функция загружает содержимого текстового файла с заданным именем как
последовательность строк. Функция одинаково корректно работает с файлами,
последняя строка которых как заканчивается на символ перевода строки,
так и не заканчивается. Первый случай некоторые текстовые редакторы трактуют
как пустую строку в конце — функция `LoadFile` пустую строку в конец
не добавляет.

Функция использует дескриптор файла 39.

#### Функция `SaveFile`

    <SaveFile (e.FileName) e.Lines>

Функция сохраняет последовательность строк как новый текстовый файл с заданным
именем. Если файл с таким именем уже был — он перезаписывается. В конец
последней строки всегда добавляется символ перевода строки, что может
трактоваться некоторыми текстовыми редакторами как лишняя пустая строчка
в конце.

Функция использует дескриптор файла 39.

#### Функция `Inc` и `Dec`

    <Inc s.NUMBER> == s.NUMBER
    <Dec s.NUMBER> == s.NUMBER

Функции, соответственно, вычисляют значение на единицу большее и меньшее своего
аргумента. Запись `<Inc s.X>` компактнее, чем `<Add s.X 1>`, поэтому они
добавлены в библиотеку.

#### Функция `ArgList`

    <ArgList> == (e.Arg)+
    e.Arg ::= s.CHAR*

Возвращает список аргументов командной строки. Первый скобочный терм — имя
запущенной программы. Поскольку встроенная функция `Arg` не может отличить
пустой аргумент от последнего (при обращении к аргументу с номером, большим,
чем последний, возвращается пустая строка), функция `ArgList` перечисляет
аргументы до первого пустого.

#### Функция `Trim`

    <Trim s.CHAR*> == s.CHAR*

Отбрасывает символы пустого пространства от начала и конца строки. К символам
пустого пространства относятся пробелы, табуляции (`\t`), возвраты каретки
(`\r`) и переводы строк (`\n`).


### Функции высшего порядка

#### Замыкание (`t.Closure`), функция `Apply`

    t.Closure ::=
        s.FUNCTION
      | (t.Closure e.Bounded)

    <Apply t.Closure e.Arg> == e.Res

    e.Bounded, e.Arg, e.Res ::= e.AnyExpr

Все функции высшего порядка принимают объект «замыкание», который может быть
либо символом функции, либо каррированной функцией. Каррированная функция
представляет собой скобочный терм, первым термом содержимого которого является
другое замыкание, остальная часть — связанный аргумент.

Например, `(Add 3)` — замыкание, в котором функция сложения связана с первым
аргументом. `(Map (Add 3))` — функция, которая принимает последовательность
чисел и к каждому прибавляет 3 (функция `Map` чуть ниже по тексту).

Для вызова замыкания используется функция `Apply`:

    <Apply Add 1 2>                   → 3
    <Apply (Add 3) 10>                → 13
    <Apply (Map (Add 3)) 100 200 300> → 103 203 303

Функция `Apply` для вызова замыкания использует `Mu`. Остальные функции
высшего порядка используют уже `Apply` для вызова замыканий, а значит, косвенно
используют `Mu`. Детали использования `Mu` в общем подмножестве рассмотрены
[во втором разделе](2-syntax.md).

**Примечание.** В Рефале-5λ все функции высшего порядка библиотеки `LibraryEx`
тоже используют `Apply`, но функция `Apply` не использует `Mu`. Поэтому
в функции высшего порядка там можно передавать только символы-функции, которые
графически отличаются от символов-функций Рефала-05, поскольку начинаются с `&`.

Поэтому, если используете Рефал-5λ для компиляции исходников, написанных для
Рефала-05, следует использовать библиотеку `LibraryEx` Рефала-05.

#### Функция `Map`

    <Map t.Closure t.Item*> == e.ItemRes*

    <Apply t.Closure t.Item> == e.ItemRes

Функция применяет `t.Closure` к `t.Item*` слева-направо. Заметим, что в отличие
от других языков программирования, функция `Map` в Рефале более универсальна.
Замыкание может не возвращать никакое значение (возвращать пустую строку),
и в итоге весь вызов `Map` будет возвращать пустоту. Функция `Map` также может
осуществлять фильтрацию, если замыкание возвращает либо свой аргумент как есть,
если терм «подходит», либо возвращает пустую строку, если терм «не подходит».

**Пример.** Преобразование каждого числа в строковую форму с добавлением
точки с запятой в конце:

    /*
      <CSVLine s.NUMBER*> == s.CHAR*
    */
    CSVLine {
      e.Numbers = <Map map_example_FormatNumber e.Numbers>;
    }

    $ENTRY map_example_FormatNumbers {
      s.Number = <Symb s.Number> ';';
    }

Функция распечатывает строчки чисел по одной на строке

    /*
      <CSVTable (s.NUMBER*)*> == пусто
    */
    CSVTable {
      e.Lines = <Map map_example_PutLine e.Lines>;
    }

    $ENTRY map_example_PutLine {
      (e.Numbers) = <Prout <CSVLine e.Numbers>>;
    }

Функция удаляет пустые строки:

    /*
      <RemoveEmpty e.Lines> == e.Lines
      e.Lines ::= (s.CHAR*)*
    */
    RemoveEmpty {
      e.Lines = <Map map_example_CheckEmpty e.Lines>;
    }

    $ENTRY map_example_CheckEmpty {
      (/* пусто */) = /* пропускаем */;

      (e.Line) = (e.Line); /* оставляем */
    }

### Функция `Reduce`

    <Reduce t.Closure t.Accum t.Item*> == t.Accum′

    <Apply t.Closure t.Accum t.Item> == t.Accum′
    t.Accum′ ::= t.Accum

Функция реализует левую свёртку, т.е. применяет замыкание `t.Closure` к паре
из аккумулятора `t.Accum` и очередного терма `t.Item` слева-направо, результат
выполнения замыкания должен быть ровно одним термом — новым значением
аккумулятора. Если замыкание возвращает не один терм (а, например, пустую строку
или несколько термов), поведение функции не определено. Возвращаемое значение —
аккумулятор после свёртки последнего терма.

**Пример.** Хеш-функция:

    /*
      <Hash s.Value*> == s.NUMBER
      s.Value ::= s.NUMBER | s.CHAR
    */
    Hash {
      e.InputString = <Reduce reduce_example_HashOne 43 <Ord e.InputString>>;
    }

    $ENTRY reduce_example_HashOne {
      s.Hash s.Number = <Add <Mul s.Hash 37> s.Number>;
    }

#### Функция `MapAccum`

    <MapAccum t.Closure t.Accum t.Item*> == t.Accum′ e.ItemRes*

    <Apply t.Closure t.Accum t.Item> == t.Accum′ e.ItemRes
    t.Accum′ ::= t.Accum

Функция применяет замыкание `t.Closure` к каждому терму из `t.Item*`
с использованием состояния, сохранённого в аккумуляторе `t.Accum`. Возвращаемое
значение замыкания — новое содержимое аккумулятора и результат преобразования
очередного терма. Результат всей функции — последнее значение аккумулятора
и конкатенация результатов трансформации термов.

**Пример.** Функция, которая отделяет агнцев от козлищ.

    *$ENUM Lamb /* агнец */, Goat /* козлище */

    /*
      <Separate t.Animal*> == (t.Lamb*) t.Goat*
      t.Animal ::=
          (Lamb t.Lamb)
        | (Goat t.Goat)
    */
    Separate {
      e.Animals =
        <MapAccum mapaccum_example_Separate (/* lambs */) e.Animals>;
    }

    $ENTRY mapaccum_example_Separate {
      (e.Lambs) (Lamb t.Lamb) = (e.Lambs t.Lamb) /* пусто */;

      (e.Lambs) (Goat t.Goat) = (e.Lambs) t.Goat;
    }

Здесь функция `mapaccum_example_Separate` кладёт ягнёнка в аккумулятор
и оставляет пустоту как результат преобразования. Козла же в аккумулятор она
не кладёт, оставляя его как результат. В итоге после завершения перебора
в аккумуляторе остаются ягнята, козлы остаются снаружи.

Другой пример в функции `DelAccumulator`.

#### Функция `DelAccumulator`

    <DelAccumulator t.Accum e.AnyExpr> == e.AnyExpr

Просто отбрасывает первый терм от выражения. Используется в сочетании
с `MapAccum`, если последнее значение аккумулятора не нужно, он использовался
ради побочного эффекта.

Формально это, конечно, функция первого порядка, но она предназначена для
совместного использования с функцией `MapAccum`, поэтому рассматривается
в этом подразделе.

**Пример.** Функция, которая добавляет номер в начало каждой строки.

    /*
      <Enumerate (e.Line)*> == (s.NUMBER e.Line)*
    */
    Enumerate {
      e.Lines =
        <DelAccumulator
          <MapAccum mapaccum_example_AddNumber 1 e.Lines>
        >;
    }

    $ENTRY mapaccum_example_AddNumber {
      s.LineNo (e.Line) = <Inc s.LineNo> (s.LineNo e.Line);
    }

После завершения прохода по строкам функция `MapAccum` оставит в поле зрения
пронумерованные строки и число, на единицу большее номера последней строки. Это
число не нужно, его отбрасываем при помощи `DelAccumulator`.


Абстрактное синтаксическое дерева Рефала-05 — компонент `R05-AST`
-----------------------------------------------------------------

В этом компоненте находятся имена-функции для построения абстрактного
синтаксического дерева Рефала-05 — синтаксическое дерево в описанном формате
порождается синтаксическим анализатором (`R05-Parser`) и потребляется
генератором кода (`R05-Generator`). Элементы дерева могут быть вызваны как
функции (со своим содержимым), результатом вызова будет исходный код
на Рефале-05 (но не на общем подмножестве) для данной синтаксической
конструкции. В интерфейсе есть также функции для построения «безымянных»
элементов, представленных e-переменными — самого дерева и выражения.


    e.Tree ::= t.TreeItem*
    t.TreeItem ::=
        (Extern e.Name)
      | (Function s.Scope (e.Name) e.Body)
      | (Native e.Native)

    e.Name ::= s.CHAR+
    s.Scope ::= Entry | Local

    e.Body ::= Sentences t.Sentence* | Native e.Native
    e.Native ::= (e.SourceName s.Line) (s.CHAR*)*
    s.Line ::= s.NUMBER
    e.SourceName ::= s.CHAR+

    t.Sentence ::= ((e.Pattern) (e.Result))
    e.Pattern, e.Result ::= e.Expression
    e.Expression ::= t.Term*
    t.Term ::=
        (Symbol Char s.CHAR)
      | (Symbol Number s.NUMBER)
      | (Symbol Name t.SrcPos e.Name)
      | (Variable s.Mode e.Index)
      | (Brackets e.Expression)
      | (CallBrackets e.Expression)
    t.SrcPos ::= (s.Row s.Col)
    s.Mode ::= 's' | 't' | 'e'
    e.Index ::= s.CHAR+

    <R05-TextFromTree e.Tree> == s.CHAR*

    <Extern e.Name> == s.CHAR*
    <Function s.Scope (e.Name) e.Body> == s.CHAR*
    <Entry> == s.CHAR*  -- '$ENTRY'
    <Local> == s.CHAR*  -- пусто
    <Sentences t.Sentence*> == s.CHAR*
    <Native e.Native> == s.CHAR*

    <Symbol s.Type e.Info> == s.CHAR*
    <Char s.CHAR> == s.CHAR*
    <Number s.NUMBER> == s.CHAR*
    <Name t.SrcPos e.Name> == s.CHAR*
    <Variable s.Mode e.Index> == s.CHAR*
    <Brackets e.Expression> == s.CHAR*
    <CallBrackets e.Expression> == s.CHAR*

    <TextFromExpr e.Expression> == s.CHAR*

    <EscapeChar s.CHAR> == s.CHAR*

Все элементы синтаксического дерева могут вызываться как функции — формируют
соответствующий текст на Рефале-05. Функции `R05-TextFromTree` и `TextFromExpr`
предназначены для «неименованных» конструкций — самого дерева и выражения
(образца и результата). Функция `EscapeChar` при необходимости экранирует символ
по правилам Рефала-05.

`$ENUM` и `$EENUM` — это синтаксический сахар, разрешаемый при синтаксическом
анализе. Пустые функции, введённые при помощи этих ключевых слов, эквивалентны
функциям, записанным с пустотой между фигурными скобками — в дереве они
изображаются как функции, в теле которой ноль предложений.

`s.Scope` — область видимости функции: entry-функции имеют область видимости
`Entry`, локальные — `Local`. Для единообразия `Entry` при вызове возвращает
строку `$ENTRY`, `Local` — пустую строчку, формально можно записать

    <s.Scope> == s.CHAR*

Нативная вставка `e.Native` содержит номер строки и имя исходного файла для
того, чтобы при генерации кода можно было добавить директиву `#line`.

Образец и результат описываются одинаковым синтаксическим деревом, разница
только в том, что в образце не может быть `CallBrackets` (что гарантирует
парсер).

Остальные элементы дерева соответствуют синтаксическим конструкциям, описанным
в [Приложении B][B], в дополнительных комментариях не нуждаются.


Фреймворк для построения компилятора Рефала-05 — компонент `R05-CompilerUtils`
------------------------------------------------------------------------------

**Компонент зависит от `LibraryEx`.**

Данный компонент содержит несколько функций, упрощающих написание
инструментальных средств, совместимых по поведению с Рефалом-05.

### Функция `R05-LoadPath`

    <R05-LoadPath> == e.Folders

    e.Folders ::= (e.Folder)*
    e.Folder ::= s.CHAR+

Функция возвращает пути поиска, заданные в переменной окружения `R05PATH`.

### Функции `R05-FindFiles-Default` и `R05-FindFiles`

    *$EENUM Source, Output, NotFound

    <R05-FindFiles-Default e.Files> == t.FoundFile*
    <R05-FindFiles (e.Folders) e.Files> == t.FoundFile*

    e.Files ::= (e.FileName)*

    t.FoundFile ::=
        (Source (e.Source) e.Output)
      | (Output e.Output)
      | (NotFound e.FileName)

    e.Source, e.Output, e.FileName ::= s.CHAR+

Функции производят поиск указанных файлов в каталогах поиска. Первая функция
`R05-FindFiles-Default` осуществляет поиск в каталогах по умолчанию, заданных
в переменной окружения `R05PATH`. Вторая функция осуществляет поиск в каталогах,
указанных пользователем.

### Функция `R05-CCompile`

    <R05-CCompile e.CSources> == e.RetCode

    e.CSources ::= (s.CHAR* '.c')*
    e.RetCode ::= '-'? s.NUMBER

Выполняет компиляцию исходных текстов на Си компилятором, заданным в переменной
окружения `R05CCOMP`, с флагами, заданными в `R05CFLAGS`. Функция автоматически
добавляет к командной строке компилятора каталоги из `R05PATH` как каталоги
поиска заголовочных файлов (используется опция `-Iкаталог`).

Если переменная `R05CCOMP` установлена и непустая, то возвращаемое значение
функции совпадает с возвращаемым значением функции `System`, при помощи которой
активируется командная строка.

Если переменная `R05CCOMP` не установлена или пустая, то возвращаемое значение
всегда `0`.


Компиляция синтаксического дерева в код на Си — компонент `R05-Generator`
-------------------------------------------------------------------------

**Компонент зависит от `LibraryEx` и `R05-AST`.**

В этом компоненте всего две похожие функции

    <R05-Generate-ToFile (e.OutputFile) e.Tree> == пусто
    (использует SaveFile → файл № 39)

    <R05-Generate-ToLines e.Tree> == (s.CHAR*)*

Обе функции принимают синтаксическое дерево и формируют код на Си. Первая
функция записывает исходный текст в файл (используя `SaveFile`, т.е. файл № 39),
вторая возвращает сгенерированный текст как последовательность строк.

Вокруг каждой нативной вставки добавляются директивы `#line`, сообщающие
компилятору Си позицию последующего кода. Координаты (имя файла и номер строки)
для первой директивы извлекаются из синтаксического дерева. Координаты для
второй директивы зависят от функции. Функция `R05-Generate-ToFile` указывает
имя файла, равное `e.OutputName` и номер строки в сгенерированном коде.
Функция `R05-Generate-ToLines` сообщает номер строки в сгенерированном коде,
но в качестве имени файла указывает `"<user output>"`.


Лексический анализ Рефала-05 — компонент `R05-Lexer`
----------------------------------------------------

**Компонент зависит от `LibraryEx`.**

### Функции `R05-LexScan-File` и `R05-LexScan-String`

    <R05-LexScan-File e.SourceName>
      == e.Tokens
    e.Tokens ::= (s.TokType t.SrcPos e.Info)*
    t.SrcPos ::= (s.Row s.Col)

    (использует LoadFile → файл № 39)

    <R05-LexScan-String e.String> == e.Tokens

    e.String ::= s.CHAR*

Обе функции выполняют синтаксический анализ. Функция `R05-LexScan-File`
загружает сканируемый текст из файла, функция `R05-LexScan-String` анализирует
указанную строку.

Функция `R05-LexScan-File` читает файл при помощи `LoadFile`, а значит,
использует файл № 39. Позиции токенов соответствуют актуальным позициям в файле,
для токена `TkNative` имя файла соответствует имени в аргументе.

Функция `R05-LexScan-String` устанавливает позиции токенов такими, какими они
были бы, если бы текст был сохранён в файле. В качестве имени файла для
`TkNative` используется имя `'<user input>'`.

Позиция записывается как пара чисел — номер строки и номер колонки. Табуляция
считается за одну колонку.

### Типы токенов

    s.TokType e.Info ::=
        TkChar s.CHAR
      | TkClose s.Bracket
      | TkCloseBlock
      | TkComma
      | TkEEnum
      | TkEOF
      | TkEntry
      | TkEnum
      | TkError e.Message
      | TkExtern
      | TkName e.Name
      | TkNative (e.SourceName s.LineNo) (s.CHAR*)*
      | TkNumber s.NUMBER
      | TkOpen s.Bracket
      | TkOpenBlock
      | TkReplace
      | TkSemicolon
      | TkUnexpected e.BadCharacters
      | TkVariable s.Mode e.Index

    s.Bracket ::= Bracket | CallBracket
    e.Message, e.Name, e.SourceName, e.BadCharacters, e.Index ::= s.CHAR+
    s.LineNo ::= s.NUMBER
    s.Mode ::= 's' | 't' | 'e'

    <Mu s.TokType e.Info> == s.CHAR*

    *$EENUM Bracket, CallBracket

Каждый токен записывается как скобочный терм, содержащий имя функции — тип
токена, его позицию и атрибут токена (для большинства он пустой).

Каждый токен может быть вызван как функция — в результате он вернёт своё
текстовое представление (с одним исключением).

Лексическая структура Рефала-05 описана в [приложении B][B], здесь мы только
опишем, чему соответствуют имена функций `Tk…`. Итак

* ключевые слова:
  * `$EXTERN` — `TkExtern`,
  * `$ENTRY` — `TkEntry`,
  * `$ENUM` — `TkEnum`,
  * `$EENUM` — `TkEEum`,
* открывающая скобка — `TkOpen`, атрибут указывает на тип скобки:
  * `Bracket` — `(`,
  * `CallBracket` — `<`,
* закрывающая скобка — `TkClose`, атрибут указывает на тип скобки:
  * `Bracket` — `)`,
  * `CallBracket` — `>`,
* остальные знаки пунктуации `,`, `;`, `=`, `{`, `}` это соответственно
  `TkComma`, `TkSemicolon`, `TkReplace`, `TkOpenBlock`, `TkCloseBlock`,
* имя — `TkName`, атрибут — имя функции как последовательность литер,
* целое число — `TkNumber`, атрибут — его значение как число,
* литера — `TkChar`, атрибут — литера,
* переменная — `TkVariable`, атрибут — тип и индекс переменной,
* нативная вставка — `TkNative`, атрибут — её координаты (имя файла и номер
  строки) и последовательность строк как скобочных термов (см. функции
  `R05-LexScan-File` и `R05-LexScan-String` выше),
* служебные токены `TkEOF`, `TkError`, `TkUnexpected`.

Функция `TkNative` при вызове со своим атрибутом форматирует нативную вставку
как есть, предваряя её однострочным комментарием с исходными координатами.

`TkEOF` атрибута не имеет, возвращается лексером при достижении конца ввода
(конца файла для `R05-LexScan-File` или конца строки `R05-LexScan-String`).
Вызов `TkEOF` порождает комментарий `/* end of file */`.

`TkError` возвращается лексером при обнаружении лексической ошибки (после неё
восстанавливается и продолжает разбор). Атрибут — сообщение об ошибке. Вызов
`<TkError e.Message>` порождает строку `'[LEXER ERROR: ' e.Message ']'`.

`TkUnexpected` возвращается при обнаружении неожиданных символов во входном
потоке. Если неожиданных символов несколько, соседние токены `TkUnexpected`
склеиваются в один. Атрибут — неожиданные символы. Вызов токена как функции
`<TkUnexpected e.BadCharacters>` просто вернёт эти символы — так сделано для
получения взаимно-обратного конвертирования исходного файла (см. функцию
`R05-LexDump` ниже).

`TkUnexpected` возвращается при неожиданных символах во входной строке
на верхнем уровне. `TkError` при других ошибках, например, незакрытая кавычка
или неправильное ключевое слово.

### Функция `StrFromToken`

    <StrFromToken s.TokType e.Info> ::= e.HumanReadableRep
    e.HumanReadableRep ::= s.CHAR*

Функция возвращает человекочитаемое представление токена, которое можно
использовать, например, в сообщениях об ошибке. В текущей реализации она
вызывает сам токен, как функцию, за исключением `TkNative` и `TkUnexpected`.
В первом случае она не распечатывает содержимое нативной вставки, во втором —
форматирует его как сообщение об ошибке.

### Функция `R05-LexDump`

    <R05-LexDump e.Tokens> == s.CHAR*

Функция преобразует последовательность токенов в исходный текст на Рефале-05.

Функция не пытается в точности сохранить исходную форму текста по значениям
координат (это было бы слишком сложно, и в общем случае — например, после
препроцессирования — невозможно), однако пытается угадать места перевода строк
по координатам. Если два соседних токена имеют одинаковые номера строк, они
будут расположены на одной строке, если разные — между ними будет добавлен
один перенос строки.

Если исходная последовательность токенов была корректной — в ней не встречались
`TkError` и `TkUnexpected`, результат преобразования также будет корректной
программой на Рефале-05 (но не на общем подмножестве). Если в ней встречались
только `TkUnexpected`, то в дампе некорректные символы восстановятся на «своих
местах». `TkError` распечатываются в некорректную строчку с сообщением
об ошибке `[LEXER ERROR: message]`, из-за чего результат преобразования тоже
останется некорректным.


Синтаксический анализ Рефала-05 — компонент `R05-Parser`
--------------------------------------------------------

**Компонент зависит от `LibraryEx`, `R05-AST` и `R05-Lexer`.**

В этом компоненте три похожие функции:

    <R05-Parse-File e.SourceFile>
      == Success e.Tree
      == Fails e.Errors
    <R05-Parse-String e.String>
      == Success e.Tree
      == Fails e.Errors
    <R05-Parse-Tokens e.Tokens>
      == Success e.Tree
      == Fails e.Errors

    e.Errors ::= ((s.Row s.Col) e.Message)*

Все три функции выполняют синтаксический анализ указанного источника,
и, если не было синтаксических ошибок, возвращают дерево, в противном случае
возвращают список ошибок.

Функция `R05-Parse-Tokens` выполняет синтаксический разбор для цепочки
токенов, две другие функции — `R05-Parse-File` и `R05-Parse-String` —
определены через неё и функции `R05-LexScan-File` и `R05-LexScan-String`
соответственно.


Главный файл компилятора — компонент `refal05c`
-----------------------------------------------

Формально он не предназначен для повторного использования, как остальные
компоненты — он содержит функцию `$ENTRY Go` и связывает рассмотренные выше
библиотеки в единое целое.

Но, при желании, его можно использовать как компонент, подменив зависимые
компоненты на альтернативные компоненты с тем же интерфейсом. Например,
если реализовать в собственном коде функцию `R05-Generate-ToFile`, то можно
собрать компилятор с альтернативным кодогенератором.

Однако, этот способ использования не поддерживается и не рекомендуется.

[B]: B-syntax-grammar.md
