Библиотека компонентов компилятора
==================================

В данном разделе будут рассмотрены исходные тексты, лежащие в каталоге `src`
дистрибутива Рефала-05.

Компилятор построен как набор повторно используемых компонент: синтаксического
дерева, лексического и синтаксического анализаторов, генератора кода и набора
утилитарных функций. Эти компоненты можно использовать как библиотеки при
написании других инструментальных средств для работы с Рефалом-05. Мотивация
такого подхода описана [в первом разделе](1-intro.md).

Все компоненты, рассматриваемые здесь, написаны на общем подмножестве Рефала-05
и Рефала-5, а это значит, что их можно использовать и при программировании
на Рефале-5 тоже. Более того, если для раскрутки компилятора использовался
Рефал-5, то скомпилированные `.rsl`-ки рассматриваемых библиотек лежат в папке
`bin`, а это значит, что её можно добавить в переменную `REF5RSL`. Об этом
говорилось в [разделе установки](3-install-and-usage.md), но повторить лишним
не будет.

**Интерфейс рассматриваемых библиотек может меняться в будущих версиях, что
не всегда будет вовремя отражаться в документации. Поэтому сверяйтесь
с комментариями в исходных текстах.**


Абстрактное синтаксическое дерева Рефала-05 — компонент `R05-AST`
-----------------------------------------------------------------

В этом компоненте находятся имена-функции для построения абстрактного
синтаксического дерева Рефала-05 — синтаксическое дерево в описанном формате
порождается синтаксическим анализатором (`R05-Parser`) и потребляется
генератором кода (`R05-Generator`). Элементы дерева могут быть вызваны как
функции (со своим содержимым), результатом вызова будет исходный код
на Рефале-05 (но не на общем подмножестве) для данной синтаксической
конструкции. В интерфейсе есть также функции для построения «безымянных»
элементов, представленных e-переменными — самого дерева и выражения.


    e.Tree ::= t.TreeItem*
    t.TreeItem ::=
        (Extern e.Name)
      | (Function s.Scope (e.Name) e.Body)

    e.Name ::= s.CHAR+
    s.Scope ::= Entry | Local

    e.Body ::= t.Sentence*
    s.Line ::= s.NUMBER
    e.SourceName ::= s.CHAR+

    t.Sentence ::= ((e.Pattern) (e.Result))
    e.Pattern, e.Result ::= e.Expression
    e.Expression ::= t.Term*
    t.Term ::=
        (Symbol Char s.CHAR)
      | (Symbol Number s.NUMBER)
      | (Symbol Word t.SrcPos e.Name)
      | (Variable s.Mode e.Index)
      | (Brackets e.Expression)
      | (Call e.Expression)
    t.SrcPos ::= (s.Row s.Col)
    s.Mode ::= 's' | 't' | 'e'
    e.Index ::= s.CHAR+

    <R05-TextFromTree e.Tree> == s.CHAR*

    <Extern e.Name> == s.CHAR*
    <Function s.Scope (e.Name) e.Body> == s.CHAR*
    <Entry> == s.CHAR*  -- '$ENTRY'
    <Local> == s.CHAR*  -- пусто

    <TextFromBody t.Sentence*> == s.CHAR*

    <Symbol s.Type e.Info> == s.CHAR*
    <Char s.CHAR> == s.CHAR*
    <Number s.NUMBER> == s.CHAR*
    <Word t.SrcPos e.Name> == s.CHAR*
    <Variable s.Mode e.Index> == s.CHAR*
    <Brackets e.Expression> == s.CHAR*
    <Call e.Expression> == s.CHAR*

    <TextFromExpr e.Expression> == s.CHAR*

    <EscapeChar s.CHAR> == s.CHAR*

Все элементы синтаксического дерева могут вызываться как функции — формируют
соответствующий текст на Рефале-05. Функции `R05-TextFromTree`, `TextFromBody`
и `TextFromExpr` предназначены для «неименованных» конструкций — самого дерева,
тела функции и выражения (образца и результата). Функция `EscapeChar`
при необходимости экранирует символ по правилам Рефала-05.

`$ENUM` и `$EENUM` — это синтаксический сахар, разрешаемый при синтаксическом
анализе. Пустые функции, введённые при помощи этих ключевых слов, эквивалентны
функциям, записанным с пустотой между фигурными скобками — в дереве они
изображаются как функции, в теле которой ноль предложений.

`s.Scope` — область видимости функции: entry-функции имеют область видимости
`Entry`, локальные — `Local`. Для единообразия `Entry` при вызове возвращает
строку `$ENTRY`, `Local` — пустую строчку, формально можно записать

    <s.Scope> == s.CHAR*

Образец и результат описываются одинаковым синтаксическим деревом, разница
только в том, что в образце не может быть `Call` (что гарантирует парсер).

Остальные элементы дерева соответствуют синтаксическим конструкциям, описанным
в [Приложении B][B], в дополнительных комментариях не нуждаются.


Фреймворк для построения компилятора Рефала-05 — компонент `R05-CompilerUtils`
------------------------------------------------------------------------------

**Компонент зависит от `LibraryEx`.**

Данный компонент содержит несколько функций, упрощающих написание
инструментальных средств, совместимых по поведению с Рефалом-05.

### Функция `R05-LoadPath`

    <R05-LoadPath> == e.Folders

    e.Folders ::= (e.Folder)*
    e.Folder ::= s.CHAR+

Функция возвращает пути поиска, заданные в переменных окружения `R05PATH`
и `REF5RSL`.

### Функции `R05-FindFiles-Default` и `R05-FindFiles`

    *$EENUM Source, Output, NotFound

    <R05-FindFiles-Default e.Files> == t.FoundFile*
    <R05-FindFiles (e.Folders) e.Files> == t.FoundFile*

    e.Files ::= (e.FileName)*

    t.FoundFile ::=
        (Source (e.Source) e.Output)
      | (Output e.Output)
      | (NotFound e.FileName)

    e.Source, e.Output, e.FileName ::= s.CHAR+

Функции производят поиск указанных файлов в каталогах поиска. Первая функция
`R05-FindFiles-Default` осуществляет поиск в каталогах по умолчанию, возвращаемых
функцией `R05-LoadPath`. Вторая функция осуществляет поиск в каталогах,
указанных пользователем.

### Функция `R05-CCompile`

    <R05-CCompile e.CSources> == e.RetCode

    e.CSources ::= (s.CHAR* '.c')*
    e.RetCode ::= '-'? s.NUMBER

Выполняет компиляцию исходных текстов на Си компилятором, заданным в переменной
окружения `R05CCOMP`, с флагами, заданными в `R05CFLAGS`. Функция автоматически
добавляет к командной строке компилятора каталоги, возвращаемые функцией
`R05-LoadPath` как каталоги поиска заголовочных файлов (используется опция
`-Iкаталог`).

Если переменная `R05CCOMP` установлена и непустая, то возвращаемое значение
функции совпадает с возвращаемым значением функции `System`, при помощи которой
активируется командная строка.

Если переменная `R05CCOMP` не установлена или пустая, то возвращаемое значение
всегда `0`.


Компиляция синтаксического дерева в код на Си — компонент `R05-Generator`
-------------------------------------------------------------------------

**Компонент зависит от `LibraryEx` и `R05-AST`.**

В этом компоненте всего две похожие функции

    <R05-Generate-ToFile (e.OutputFile) e.Tree> == пусто
    (использует SaveFile → файл № 39)

    <R05-Generate-ToLines e.Tree> == (s.CHAR*)*

Обе функции принимают синтаксическое дерево и формируют код на Си. Первая
функция записывает исходный текст в файл (используя `SaveFile`, т.е. файл № 39),
вторая возвращает сгенерированный текст как последовательность строк.


Лексический анализ Рефала-05 — компонент `R05-Lexer`
----------------------------------------------------

**Компонент зависит от `LibraryEx`.**

### Функции `R05-LexScan-File` и `R05-LexScan-String`

    <R05-LexScan-File e.SourceName>
      == e.Tokens
    e.Tokens ::= (s.TokType t.SrcPos e.Info)*
    t.SrcPos ::= (s.Row s.Col)

    (использует LoadFile → файл № 39)

    <R05-LexScan-String e.String> == e.Tokens

    e.String ::= s.CHAR*

Обе функции выполняют синтаксический анализ. Функция `R05-LexScan-File`
загружает сканируемый текст из файла, функция `R05-LexScan-String` анализирует
указанную строку.

Функция `R05-LexScan-File` читает файл при помощи `LoadFile`, а значит,
использует файл № 39. Позиции токенов соответствуют актуальным позициям в файле.

Функция `R05-LexScan-String` устанавливает позиции токенов такими, какими они
были бы, если бы текст был сохранён в файле.

Позиция записывается как пара чисел — номер строки и номер колонки. Табуляция
считается за одну колонку.

### Типы токенов

    s.TokType e.Info ::=
        TkChar s.CHAR
      | TkClose s.Bracket
      | TkCloseBlock
      | TkComma
      | TkEEnum
      | TkEOF
      | TkEntry
      | TkEnum
      | TkError e.Message
      | TkExtern
      | TkName e.Name
      | TkNumber s.NUMBER
      | TkOpen s.Bracket
      | TkOpenBlock
      | TkReplace
      | TkSemicolon
      | TkUnexpected e.BadCharacters
      | TkVariable s.Mode e.Index

    s.Bracket ::= Bracket | CallBracket
    e.Message, e.Name, e.SourceName, e.BadCharacters, e.Index ::= s.CHAR+
    s.LineNo ::= s.NUMBER
    s.Mode ::= 's' | 't' | 'e'

    <Mu s.TokType e.Info> == s.CHAR*

    *$EENUM Bracket, CallBracket

Каждый токен записывается как скобочный терм, содержащий имя функции — тип
токена, его позицию и атрибут токена (для большинства он пустой).

Каждый токен может быть вызван как функция — в результате он вернёт своё
текстовое представление (с одним исключением).

Лексическая структура Рефала-05 описана в [приложении B][B], здесь мы только
опишем, чему соответствуют имена функций `Tk…`. Итак

* ключевые слова:
  * `$EXTERN` — `TkExtern`,
  * `$ENTRY` — `TkEntry`,
  * `$ENUM` — `TkEnum`,
  * `$EENUM` — `TkEEum`,
* открывающая скобка — `TkOpen`, атрибут указывает на тип скобки:
  * `Bracket` — `(`,
  * `CallBracket` — `<`,
* закрывающая скобка — `TkClose`, атрибут указывает на тип скобки:
  * `Bracket` — `)`,
  * `CallBracket` — `>`,
* остальные знаки пунктуации `,`, `;`, `=`, `{`, `}` это соответственно
  `TkComma`, `TkSemicolon`, `TkReplace`, `TkOpenBlock`, `TkCloseBlock`,
* имя — `TkName`, атрибут — имя функции как последовательность литер,
* целое число — `TkNumber`, атрибут — его значение как число,
* литера — `TkChar`, атрибут — литера,
* переменная — `TkVariable`, атрибут — тип и индекс переменной,
* служебные токены `TkEOF`, `TkError`, `TkUnexpected`.

`TkEOF` атрибута не имеет, возвращается лексером при достижении конца ввода
(конца файла для `R05-LexScan-File` или конца строки `R05-LexScan-String`).
Вызов `TkEOF` порождает комментарий `/* end of file */`.

`TkError` возвращается лексером при обнаружении лексической ошибки (после неё
восстанавливается и продолжает разбор). Атрибут — сообщение об ошибке. Вызов
`<TkError e.Message>` порождает строку `'[LEXER ERROR: ' e.Message ']'`.

`TkUnexpected` возвращается при обнаружении неожиданных символов во входном
потоке. Если неожиданных символов несколько, соседние токены `TkUnexpected`
склеиваются в один. Атрибут — неожиданные символы. Вызов токена как функции
`<TkUnexpected e.BadCharacters>` просто вернёт эти символы — так сделано для
получения взаимно-обратного конвертирования исходного файла (см. функцию
`R05-LexDump` ниже).

`TkUnexpected` возвращается при неожиданных символах во входной строке
на верхнем уровне. `TkError` при других ошибках, например, незакрытая кавычка
или неправильное ключевое слово.

### Функция `StrFromToken`

    <StrFromToken s.TokType e.Info> ::= e.HumanReadableRep
    e.HumanReadableRep ::= s.CHAR*

Функция возвращает человекочитаемое представление токена, которое можно
использовать, например, в сообщениях об ошибке. В текущей реализации она
вызывает сам токен, как функцию, за исключением `TkUnexpected` — она
форматирует его как сообщение об ошибке.

### Функция `R05-LexDump`

    <R05-LexDump e.Tokens> == s.CHAR*

Функция преобразует последовательность токенов в исходный текст на Рефале-05.

Функция не пытается в точности сохранить исходную форму текста по значениям
координат (это было бы слишком сложно, и в общем случае — например, после
препроцессирования — невозможно), однако пытается угадать места перевода строк
по координатам. Если два соседних токена имеют одинаковые номера строк, они
будут расположены на одной строке, если разные — между ними будет добавлен
один перенос строки.

Если исходная последовательность токенов была корректной — в ней не встречались
`TkError` и `TkUnexpected`, результат преобразования также будет корректной
программой на Рефале-05 (но не на общем подмножестве). Если в ней встречались
только `TkUnexpected`, то в дампе некорректные символы восстановятся на «своих
местах». `TkError` распечатываются в некорректную строчку с сообщением
об ошибке `[LEXER ERROR: message]`, из-за чего результат преобразования тоже
останется некорректным.


Синтаксический анализ Рефала-05 — компонент `R05-Parser`
--------------------------------------------------------

**Компонент зависит от `LibraryEx`, `R05-AST` и `R05-Lexer`.**

В этом компоненте три похожие функции:

    <R05-Parse-File e.SourceFile>
      == Success e.Tree
      == Fails e.Errors
    <R05-Parse-String e.String>
      == Success e.Tree
      == Fails e.Errors
    <R05-Parse-Tokens e.Tokens>
      == Success e.Tree
      == Fails e.Errors

    e.Errors ::= ((s.Row s.Col) e.Message)*

Все три функции выполняют синтаксический анализ указанного источника,
и, если не было синтаксических ошибок, возвращают дерево, в противном случае
возвращают список ошибок.

Функция `R05-Parse-Tokens` выполняет синтаксический разбор для цепочки
токенов, две другие функции — `R05-Parse-File` и `R05-Parse-String` —
определены через неё и функции `R05-LexScan-File` и `R05-LexScan-String`
соответственно.


Главный файл компилятора — компонент `refal05c`
-----------------------------------------------

Формально он не предназначен для повторного использования, как остальные
компоненты — он содержит функцию `$ENTRY Go` и связывает рассмотренные выше
библиотеки в единое целое.

Но, при желании, его можно использовать как компонент, подменив зависимые
компоненты на альтернативные компоненты с тем же интерфейсом. Например,
если реализовать в собственном коде функцию `R05-Generate-ToFile`, то можно
собрать компилятор с альтернативным кодогенератором.

Однако, этот способ использования не поддерживается и не рекомендуется.

[B]: B-syntax-grammar.md
