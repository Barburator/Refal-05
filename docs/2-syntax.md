Язык Рефал-05, его отличия от Рефала-5 и общее подмножество
===========================================================

<div id="toc"></div>
<script src="toc.js"></script>
<script>
makeTOC.localizedHeader = "Содержание"
makeTOC.localizedShow = "Показать";
makeTOC.localizedHide = "Скрыть";
</script>


Синтаксис Рефала-05
-------------------

Синтаксис Рефала-05 является точным подмножеством синтаксиса Рефала-5 (версия
`PZ Oct 29 2004`) — если программма компилируется без ошибок Рефалом-05, то она
будет без ошибок скомпилирована и Рефалом-5 тоже.

Обратное неверно — Рефал-05 может выдавать синтаксические ошибки на некоторые
корректные программы Рефала-5. Это следующие ошибки:

* избыточные внешние объявления,
* неиспользуемые функции.

Так сделано намеренно. Рефал-05 — это не Рефал-5, это другой язык, у него
могут быть другие правила.

### Объявления и определения

Будем говорить, что функция **объявлена,** если имя этой функции присутствует
в списке `$EXTERN`.

Будем говорить, что функция **определена,** если в файле присутствует тело
этой функции.

### Избыточные внешние объявления

С точки зрения Рефала-05 каждая функция может быть либо встроенной, либо
объявленной, либо определённой. Причём, и объявлена, и определена она может
только однократно.

Отсюда следует, что

* нельзя объявлять и определять функции, чьё имя совпадает с именем встроенной
  функции,
* в файле не может быть нескольких определений одной и той же функции (это,
  конечно же, верно и для Рефала-5),
* в файле не может быть нескольких объявлений одной и той же функции — имя
  не может дважды находиться в одном списке `$EXTERN` и не может быть записано
  в нескольких разных списках `$EXTERN`,
* имя определённой функции не может встречаться в списке `$EXTERN`.

### Неиспользуемые функции

Рефал-05 считает синтаксической ошибкой объявления и определения, которые
не используются в программе.

Рефал-05 использует раздельную компиляцию, он за раз анализирует только один
файл исходного текста, поэтому он не может понять, что в конкретной программе
какая-либо функция, помеченная `$ENTRY` не используется. Более того, наличие
таких фактически неиспользуемых функций скорее правило, ведь пользователь
может подключать к программе библиотеку (например, `LibraryEx`), из которой
использовать далеко не все функции. Поэтому функции, помеченные `$ENTRY`,
являются используемыми по определению.

Определим формально, что такое используемые функции и используемые
определения.

Множество **используемых функций** — это минимальное множество, определённое
следующими правилами:

* если функция, помечена как `$ENTRY`, она используемая,
* если функция `F` используемая и её тело содержит вызов `<G …>`, то функция
  `G` тоже используемая,
* если функция `F` используемая, её тело содержит составной символ `G`
  и в текущем файле есть функция с именем `G`, то функция `G` тоже
  используемая.

Множество **используемых объявлений** — это минимальное множество, определённое
следующими правилами:

* если функция `F` используемая, её тело содержит вызов `<G …>` и программа
  содержит имя `G` в списке `$EXTERN`, то это имя в списке `$EXTERN`
  используемое.
* если функция `F` используемая, её тело содержит составной символ `G`
  и программа содержит имя `G` в списке `$EXTERN`, то это имя в списке
  `$EXTERN` используемое.

Соответственно, **неиспользуемые** функции и объявления — это функции
и объявления, которые не входят во множества используемых. На них компилятор
Рефала-05 выдаёт синтаксические ошибки.

Правила вида _«если функция `F` используемая, её тело содержит составной
символ `G`…»_ связаны с семантикой нагруженных идентификаторов —
см. раздел про них и функцию `Mu` ниже.

Могут существовать программы на Рефале-5, в которых есть неиспользуемые
по определению выше функции, но они по факту используются, т.к. вызываются
косвенно через `Mu`. Такие программы были бы несовместимы с Рефалом-05
из-за отличий в семантике `Mu`, даже если бы неиспользуемые функции не были бы
синтаксической ошибкой, прерывающей компиляцию. Об этом тоже будет написано
в разделе про нагруженные идентификаторы и функцию `Mu` ниже.


Отличия в семантике Рефала-05 и Рефала-5
----------------------------------------

### Нагруженные идентификаторы и функция `Mu`

<font color="red">
<p>Раздел в процессе написания</p>
</font>

### Отсутствие длинной арифметики

<font color="red">
<p>Раздел в процессе написания</p>
</font>

### Не все встроенные функции поддерживаются

<font color="red">
<p>Раздел в процессе написания</p>
</font>


Библиотека встроенных функций
-----------------------------

Далее мы перечислим встроенные функции в том порядке и с теми номерами,
в каком их перечисляет встроенная функция `ListOfBuiltin`.


### Нотация для записи типов функций

Для описания типов функций будем использовать следующие обозначения.

_Тип функции:_

    <ИмяФункции тип-аргумента>
      == тип-результата

Здесь `тип-аргумента` — описание области определения функции, `тип-результата` —
описание области значений. Оба типа — типы выражений

_Именованный тип:_

    переменная-типа ::= тип-выражения1 | тип-выражения2 | … | тип-выраженияN

Переменная типа записывается как обычная переменная Рефала, через вертикальную
черту перечисляются различные альтернативы.

Несколько именованных типов могут иметь одинаковое описание:

    перем1, перем2, перем3 ::= тип-выражения

_Тип выражения_ записывается как образцовое выражение, где после термов
(включая переменные) могут использоваться квантификаторы `*` (0 и более раз),
`+` (1 и более раз) и `?` (0 или 1 раз).

Переменные `s.CHAR`, `s.NUMBER` и `s.FUNCTION` описывают, соответственно,
произвольную литеру, число и функцию.

**Примеры.** Произвольное выражение, произвольный терм и произвольный символ:

    e.AnyExpr ::= t.AnyTerm*
    t.AnyTerm ::= s.AnySymbol | (e.AnyExpr)
    s.AnySymbol ::= s.CHAR | s.NUMBER | s.FUNCTION

Входная точка лексического анализатора (длинный список лексем сокращён):

    <R05-LexScan-File e.SourceName>
      == e.Tokens
    e.Tokens ::= (s.TokType t.SrcPos e.Info)
    t.SrcPos ::= (s.Row s.Col)

    s.TokType e.Info ::=
        TkChar s.CHAR
      | TkClose s.Bracket
      | TkCloseBlock
        …
      | TkError e.Message
      | TkExtern
      | TkName e.Name
      | TkNative (e.SourceName s.LineNo) (s.CHAR*)*
      | TkNumber s.NUMBER
      | TkOpen s.Bracket
      | TkOpenBlock
      | TkReplace
      | TkSemicolon
      | TkUnexpected e.BadCharacters
      | TkVariable s.Mode e.Index

    s.Bracket ::= Bracket | CallBracket
    e.Message, e.Name, e.SourceName, e.BadCharacters, e.Index ::= s.CHAR+
    s.LineNo ::= s.NUMBER
    s.Mode ::= 's' | 't' | 'e'

Входная точка синтаксического анализатора:

    <R05-Parse-File e.SourceFile>
      == Success e.Tree
      == Fails e.Errors

    e.Errors ::= ((s.Row s.Col) e.Message)*

Часть описания дерева:

    e.Tree ::= t.TreeItem*
    t.TreeItem ::=
        (Extern e.Name)
      | (Function s.Scope (e.Name) e.Body)
      | (Native e.Native)

    e.Name ::= s.CHAR+
    s.Scope ::= Entry | Local
    e.Body ::= Sentences t.Sentence* | Native e.Native
    e.Native ::= (e.SourceName s.Line) (s.CHAR*)*
    s.Line ::= s.NUMBER
    e.SourceName ::= s.CHAR+


### 1. Mu

    <Mu s.FUNCTION e.AnyExpr> == e.AnyExpr

**Семантика:** функция имеет следующую реализацию на Рефале

    $ENTRY Mu {
      s.Func e.Arg = <s.Func e.Arg>;
    }

Функция нужна для совместимости с Рефалом-5. Зачем она нужна, мы подробно
расскажем в следующем разделе.

**Совместимость с Рефалом-5** См. раздел «Совместимость с Рефалом-5 и общее
подмножество».

### 2. Add

    <Add s.NUMBER s.NUMBER> == 1? s.NUMBER

**Семантика.** Вычисляет сумму двух чисел. Если сумма превышает максимальное
значение целого числа, то возвращается пара чисел: `1` и сумма чисел по модулю
2<sup>N</sup>, где N — число двоичных разрядов типа `unsigned long`
используемого компилятора языка Си.

**Совместимость с Рефалом-5.** В Рефале-5 поддерживаются длинная арифметика
и отрицательные числа. Поэтому аргументами `Add` могут быть длинные числа
со знаком. Для записи длинных чисел первый аргумент заворачивается в круглые
скобки: `<Add (e.X) e.Y>`. Рефал-05 не поддерживает скобки вокруг первого
аргумента, а также знаки и длинную арифметику.

### 3. Arg

    <Arg s.ArgNo> == e.Argument

    s.ArgNo ::= s.NUMBER
    e.Argument ::= s.CHAR*

**Семантика:** возвращает аргумент командной строки с указанным номером.
Нулевой аргумент — имя вызываемой программы. Если запрашиваемый аргумент
не существует — фактическое их число меньше, чем `s.ArgNo`, возвращается
пустая строка.

**Совместимость с Рефалом-5.** Интерпретатор Рефала-5 пропускает все аргументы,
начинающиеся на знак минус, поэтому в переносимых программах не рекомендуется
использовать ключи командной строки, начинающиеся на минус.

### 4. Br

    <Br e.Key '=' e.Value> == пусто

    e.Key, e.Value ::= e.AnyExpr

**Семантика:** Сохраняет в копилке соответствующую пару «ключ-значение».

**Совместимость с Рефалом-5:** полная.

### 5. Card

    <Card> == s.CHAR* 0?

**Семантика.** Считывает ~~перфокарту~~ строчку со стандартного ввода. Если
встречен символ конца файла, в конец прочитанной строки добавляется число `0`.

**Совместимость с Рефалом-5.** Встроенные функции `Card` и `Get` некорректно
считывают строки, содержащие внутри себя символ с кодом нуля `\x00`, поэтому
переносимые программы не должны читать двоичные файлы.

### 6. Chr

    <Chr e.AnyExpr> == e.AnyExprChr

    e.AnyExprChr ::= t.AnyTermChr*
    t.AnyTermChr ::= s.CHAR | s.NUMBER | (e.AnyExprChr)

**Семантика:** функция заменяет в своём аргументе все числа на символы-литеры
с соответствующим ASCII-кодом (по модулю 256).

**Совместимость с Рефалом-5:** полностью совместима.

### 8. Dg

    <Dg e.Key> == e.Value

**Семантика:** Извлекает из копилки последнее сохранённое значение с заданным
ключом. Если с заданным ключом ничего не сохранялось, возвращается пустое
выражение.

**Совместимость с Рефалом-5:** полная. Включая следующую ошибку:

    $ENTRY Go {
      = <Br 'A=B=C'> <Prout <Dg 'A=B'>>
    }

И Рефал-5, и Рефал-05 распечатают `C`.

### 10. Div

    <Div s.NUMBER s.NUMBER> == s.NUMBER

**Семантика.** Выполняет целочисленное деление. Если делитель равен нулю,
программа аварийно останавливается выдачей дампа поля зрения и ошибки «деление
на ноль».

**Совместимость с Рефалом-5:** см. `Add`.

### 11. Divmod

    <Divmod s.NUMBER s.NUMBER> == (s.NUMBER) s.NUMBER

**Семантика.** Вычисляет частное и остаток от деления, частное заключает
в скобки. Если делитель равен нулю, программа аварийно останавливается выдачей
дампа поля зрения и ошибки «деление на ноль».

**Совместимость с Рефалом-5:** см. `Add`.

### 12. Explode

    <Explode s.FUNCTION> == s.CHAR+

**Семантика.** Для символа-функции возвращает её имя как последовательность
литер, вместо литеры `-` возвращается `_`. Пример:

    <Explode R05-Parse-File> → 'R05_Parse_File'
    <Explode findfile_AnalyzeFile-ByFolders> → 'findfile_AnalyzeFile_ByFolders'

**Совместимость с Рефалом-5.** Функция `Explode` в Рефале-5 применяется
к символам-словам, не заменяет знаки `-` на знаки `_`.

### 13. First

    <First s.Len e.Items> == (e.Prefix) e.Suffix

    e.Items : e.Prefix e.Suffix
    |e.Prefix| == s.Len || { |e.Prefix| < s.Len && |e.Suffix| == 0 }

**Семантика.** Отделяет от строки префикс указанной длины. Если строка
короче, то она вся возвращается как префикс.

**Совместимость с Рефалом-5:** полностью совместима.

### 14. Get

    <Get s.FileNo> == s.CHAR* 0?

    s.FileNo ::= s.NUMBER

**Семантика.** Функция читает из файла с заданным номером. Номер файла
вычисляется как остаток от деления `s.FileNo` на `40`:

    file_no = s.FileNo % 40

Если величина `file_no` равна нулю, то читается стандартный ввод, т.е. вызов
`<Get 0>` (или `<Get 40>`, `<Get 80>` и т.д.) будет эквивалентен вызову
`<Card>`.

Если файл с указанным номером не был открыт при помощи функции `Open`,
то открывается файл с именем `REFAL<file_no>.DAT` в режиме «для чтения», где
вместо `<file_no>` означает запись `file_no` в десятичном виде. Например, если
файл с номером 33 не был открыт, то вызов `<Get 143>` откроет для чтения файл
`REFAL33.DAT`.

Точно также, как и функция `Card`, при достижении конца файла функция загружает
в поле зрения число `0`.

**Совместимость с Рефалом-5.** См. `Card`.

### 15. Implode

    <Implode e.ValidPrefix e.Suffix> == s.FUNCTION e.Suffix
    <Implode e.Suffix> == 0 e.Suffix

    e.ValidPrefix ::= s.Lettern { s.Letter | s.Digit | '_' | '-' | '$' }
    s.Letter ::= 'A' | … | 'Z' | 'a' | … | 'z'
    s.Digit ::= '0' | … | '9'

**Семантика.** У аргумента выделяется префикс максимальной длины, являющийся
записью корректного имени функции в Рефале-5. Если этот префикс не пустой,
функция `Implode` возвращает функцию, имя которой записано в префиксе
и суффикс. Если же префикс пустой, то функция возвращает число 0 и суффикс
(фактически, совпадающий со всем аргументом).

Особенность Рефала-05 — если указано имя встроенной функции, то возвращается
встроенная функция (нагруженный идентификатор), если другое имя — пустая
функция (ненагруженный идентификатор):

    <Mu <Implode 'Add' 12 34>>  →  46

**Совместимость с Рефалом-5.** Полная. В частности, и Рефал-5, и Рефал-05
допускают в идентификаторе, создаваемом `Implode`, знак `$`, однако,
в Рефале-5 эта особенность недокументированная.

### 19. Mod

    <Mod s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет остаток от деления. При делении на нуль — см. `Div`.

**Совместимость с Рефалом-5:** см. `Add`.

### 20. Mul

    <Mul s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет произведение двух чисел по модулю 2<sup>N</sup>
(см. `Add`).

**Совместимость с Рефалом-5:** см. `Add`.

### 21. Numb

    <Numb s.CHAR*> == s.NUMBER

**Семантика.** Если аргумент начинается с последовательности цифр,
то возвращается число по модулю 2<sup>N</sup> (см. `Add`). В противном
случае возвращается `0`.

**Совместимость с Рефалом.** В Рефале-5 поддерживаются длинная арифметика
и знаки у чисел, поэтому у функции `Numb` аргумент может начинаться с `'+'`
или `'-'`, результат может содержать знак и несколько макроцифр.

### 22. Open

    <Open s.Mode s.FileNo e.FileName?> == пусто

    s.Mode ::=
        'r' | 'w' | 'a'
      |  r  |  w  |  a
      |  rb |  wb |  ab
    e.FileName ::= s.CHAR+

**Семантика.** Функция открывает файл с заданным номером в заданном режиме.
Номер файла вычисляется по формуле

    file_no = s.FileNo % 40

Если файл с номером `file_no` был открыт ранее, он закрывается. Если имя файла
не задано, то открывается файл с именем `REFAL<file_no>.DAT`, где `<file_no>` —
десятичная запись `file_no`.

Режим доступа может быть задан одной из трёх литер, либо любым именем функции.
Если режим задан функцией, то её имя напрямую передаётся во второй аргумент
`fopen` безо всякой проверки (аналогично Рефалу-5).

Режимы:

* `'r'`, `r` — открытие файла для чтения. Если файл не существует, программа
  аварийно останавливается с выдачей соответствующего сообщения об ошибке.
* `'w'`, `w` — открытие файла для (пере)записи — если файл существует,
  то усекается до нулевой длины, если файл не существует, то будет создан.
* `'a'`, `a` — открытие файла для дозаписи. Если файл существует, то запись
  будет осуществляться в конец, если не существует — будет создан.
* `rb`, `wb`, `ab` — двоичный ввод-вывод (зависит от платформы).

Файл с номером 39 используется в `LibraryEx` функциями `LoadFile` и `SaveFile`.

**Совместимость с Рефалом-5.** Функция полностью совместима. Рефал-5 использует
символы-слова, поэтому можно задавать режимы типа `"r+b"`, `"r,encoding=KOI8-R"`
(какие-то компиляторы такое поддерживают). В Рефале-05 такое не получится.

### 23. Ord

    <Ord e.AnyExpr> ::= AnyExprOrd

    e.AnyExprOrd ::= t.AnyTermOrd*
    t.AnyTermord ::= s.NUMBER | s.FUNCTION | (e.AnyExprOrd)

**Семантика:** заменяет в своём аргументе все литеры на их ASCII-коды.

**Совместимость с Рефалом-5:** полностью совместима.

### 25. Prout

    <Prout e.AnyExpr> == пусто

**Семантика.** Распечатывает объектное выражение. Литеры выводятся как есть,
числа выводятся в десятичном виде, для функций выводятся их имена (с заменой
`-` на `_`), структурные скобки распечатываются как `(` и `)` (при печати
неотличимы от `'('`, `')'`). После чисел и имён функций добавляется пробел,
чтобы при выводе нескольких чисел или функций подряд их образы не слипались.

**Совместимость с Рефалом-5:** полностью совместима за исключением вывода
имён функций (замены дефисов на прочерки).

### 27. Putout

    <Putout s.FileNo e.Expr> == пусто

**Семантика.** Распечатывает объектное выражение в файл с указанным номером.
Преобразование в цепочку литер осуществляет точно также, как и `Prout`. Номер
файла определяется по формуле:

    file_no = s.FileNo % 40

Если файл с номером `file_no` не открыт, то открывается файл с именем
`REFAL<file_no>.DAT`, где `<file_no>` — десятичная запись `file_no` в режиме
(пере)записи (см. `'w'` у функции `Open`).

**Совместимость с Рефалом-5:** см. `Prout`.

### 30. Sub

    <Sub s.NUMBER s.NUMBER> == '-'? s.NUMBER

**Семантика:** вычисляет разность двух чисел. Если первое число меньше второго,
возвращается литера `'-'` и значением модуля их разности. Иначе просто
возвращается их разность.

**Совместимость с Рефалом-5:** см. `Add`.

### 31. Symb

    <Symb e.Sign s.Number> == e.Sign s.CHAR+
    e.Sign ::= '+' | '-' | пусто

**Семантика.** Преобразует число в его десятичную запись. Если числу
предшествовала литера `'+'` или `'-'`, та же литера будет предшествовать
и результату. Поддержка знака была добавлена для совместимости с функцией
`System`.

**Совместимость с Рефалом-5.** Рефал-5 поддерживает длинную арифметику, поэтому
в аргументе может быть указано несколько чисел-макроцифр, таким образом,
функция `Symb` Рефала-05 обрабатывает помножество области определения функции
Рефала-5.

### 33. Type

    <Type e.AnyExpr> == s.Type s.SubType e.AnyExpr

    s.Type s.SubType ::=
        'Lu' — uppercase latin letter
      | 'Ll' — lowercase latin letter
      | 'D0' — decimal digit
      | 'Wi' — identifier (function)
      | 'N0' — number
      | 'Pu' — isprint() && isupper()
      | 'Pl' — isprint() && ! isupper()
      | 'Ou' — other && isupper()
      | 'Ol' — other && ! isupper()
      | 'B0' — brackets
      | '*0' — empty expression

**Семантика:** возвращает тип первого терма аргумента. Если аргумент пустой,
возвращает `'*0'`. Остальные типы и подтипы:

* `'L'` — литера, латинская буква. `'Lu'` — заглавная, `'Ll'` — строчная.
* `'D'` — литера, десятичная цифра. Подтип всегда `'0'`.
* `'W'` — функция. Подтип `'i'`, если имя функции может быть записано без
  кавычек, `'q'`, если только в кавычках. Для подтипа `'q'` функция всегда
  будет пустой.
* `'N'` — число. Подтип всегда `'0'`.
* `'P'` — литера, печатный знак. Реализация повторяет семантику Рефала-5
  `PZ Oct 29 2004`: подтип `'u'`, если функция `isupper()` вернула истину,
  `'l'` в противном случае. Для локали `"C"` функция `isupper()` возвращает
  истину только для латинских букв, значит, для любого печатного знака, значит
  подтип всегда будет `'l'`.
* `'O'` — любая другая литера. Подтип — см. замечание к `'P'`.
* `'B'` — скобочный терм. Подтип всегда `'0'`.

Работа функции зависит от установленной локали (которая по умолчанию вроде
`"C"`), если локаль изменена (конфигурацией операционной системы или внешней функцией
на Си), то функция будет работать иначе. Лексический анализатор полагается
на эту функцию.

**Совместимость с Рефалом-5.** В Рефале-5 тип `'W'` используется для слов, подтип
`'i'` соответствует словам в «идентификаторной форме», подтип `'q'` — словам,
записываемым «в кавычках».

### 51. GetEnv

    <GetEnv e.EnvName> == e.EnvValue
    e.EnvName, e.EnvValue ::= s.CHAR*

**Семантика:** возвращает значение переменной среды с заданным именем. Если
переменная среды не установлена, возвращает пустую строку.

**Совместимость с Рефалом-5:** полная.

### 52. System

    <System e.Command> == e.RetCode
    e.Command ::= s.CHAR*
    e.RetCode ::= '-'? s.NUMBER

**Семантика.** Выполняет команду `e.Command` при помощи функции `system()`
языка Си.

На POSIX (если установлен ключ `-DR05_POSIX` компилятора Си), если запущенный
процесс успешно завершился, возвращает код его возврата, иначе возвращает
`'-' 1`. На Windows (т.е. когда не установлен `-DR05_POSIX`) возвращает то,
что вернула `system()` как есть.

Отрицательный код возврата представляется как число с предшествующей литерой
`'-'`.

**Совместимость с Рефалом-5:** полная.

### 53. Exit

    <Exit e.RetCode>
    e.RetCode ::= '-'? s.NUMBER

**Семантика.** Завершает программу с заданным кодом возврата. Отрицательное
значение записывается как литера `'-'` с последующим числом.

**Совместимость с Рефалом-5:** полная.

### 54. Close

    <Close s.FileNo> == пусто

**Семантика.** Закрывает открытый файл с номером `s.FileNo % 40`. Если файл
с этим номером не был открыт, функция ничего не делает.

**Совместимость с Рефалом-5:** полная.

### 55. ExistFile

    <ExistFile e.FileName> == True | False
    e.FileName ::= s.CHAR*

    $EENUM True, False;

**Семантика.** Функция пытается открыть файл с указанным именем для чтения
при помощи `fopen()`. Если удаётся — закрывает открытый файл и возвращает
`True`, в противном случае возвращает `False`. Функции `True` и `False`
не являются встроенными функциями, это значит, что их нужно явно подключать
при помощи `$EXTERN`. Так сделано из соображений простоты и переносимости.

**Совместимость с Рефалом-5.** Рефал-5 действует честнее — использует средства
операционной системы, чтобы понять, существует файл или нет. А это значит,
что если файл существует, но недоступен для чтения, функции `ExistFile` Рефала-5
и Рефала-05 увидят его по-разному.

### 58. Implode_Ext

    <Implode_Ext s.CHAR*> == s.FUNCTION

**Семантика.** Строит составной символ из литер в аргументе. Точно также, как
и в случае `Implode`, если составной символ образует имя встроенной функции,
составной символ оказывается «нагруженным» указателем на эту функцию. Если
не образует, то вызов такого составного символа при помощи `Mu` приведёт
к ошибке отождествления.

В Рефале-05 символы `"%"`, `"*"`, `"+"`, `"-"`, `"/"` и `"?"` являются
именами соответствующих встроенных функций (синонимы для `Mod`, `Mul`, `Add`,
`Sub`, `Div` и `Residue` соответственно).

**Совместимость с Рефалом-5.** У Рефала-5 есть недокументированное расширение —
фактический формат имеет вид:

    <Implode_Ext s.CHAR* e.ANY> == s.FUNCTION

где `e.ANY` не начинается с литеры. Рефал-05 такое расширение не поддерживает.

В остальном совместимость полная.

### 60. TimeElapsed

    <TimeElapsed 0?> == s.CHAR+

**Семантика.** Функция возвращает число секунд, прошедших с момента
предыдущего вызова `<TimeElapsed 0>`, либо с начала программы, если
`<TimeElapsed>` ни разу не вызывалась. Число секунд возвращается в виде
десятичной записи дробного числа вида `'12.345'`.

**Совместимость с Рефалом-5.** Полная.

### 61. Compare

    <Compare s.NUMBER s.NUMBER> == '-' | '0' | '+'

**Семантика.** Возвращает `'-'`, если первое число меньше второго, `'0'` — если
они равны и `'+'`, если первое больше второго. Иначе говоря, возвращает знак
разности этих двух чисел.

**Совместимость с Рефалом-5.** Рефал-5 поддерживает длинную арифметику и числа
со знаком, в том числе и для функции `Compare` (см. `Add`).

### 67. ListOfBuiltin

    <ListOfBuiltin> == (s.FuncNo s.Name s.BuiltinType)+

    s.FuncNo ::= s.NUMBER
    s.Name ::= s.FUNCTION
    s.BuiltinType ::= special | regular

    $EENUM special, regular;

**Семантика.** Выводит список встроенных функций в указанном формате. Величины
`s.FuncNo` и `s.BuiltinType` в данной реализации смысла не имеют, добавлены для
совместимости с Рефалом-5. Значения `s.FuncNo` и `s.BuiltinType` текущая
реализация возвращает те же, что и Рефал-5 версии `PZ Oct 29 2004`.

Список имён, возвращаемых этой функцией, используется компилятором, чтобы неявно
предобъявлять встроенные функции.

**Совместимость с Рефалом-5.** Закономерное отличие: `s.Name` и `s.BuiltinType`
являются символами-словами, кроме того, эта функция в Рефале-5 перечисляет
гораздо больше имён. Значения `s.FuncNo` и `s.BuiltinType` относятся
ко внутренней реализации интерпретатора.


Рефал-05 и Рефал-5: общее подмножество
--------------------------------------

Рефал-05 проектировался как язык, имеющий общее подмножество с Рефалом-5, притом
это подмножество должно быть удобным для программирования (сам компилятор должен
быть написан на нём). И действительно, при наложении небольших ограничений
на стиль кодирования можно писать программы, которые одинаково работают на обоих
диалектах.

Далее под фразой «общее подмножество» мы будем подразумевать общее подмножество
Рефала-5 и Рефала-05.

Некоторые ограничения достаточно очевидны, их можно описать одной строчкой,
другие потребуют более глубокого рассмотрения — о них в следующих двух
подразделах.

Итак, как надо писать на Рефале-05, чтобы полученная программа также работала
на Рефале-5:

* Нельзя определять функции, имена которых совпадают со встроенными функциями
  Рефала-5, не реализованными в Рефале-05, например, `Print`, `First`, `Lenw`.
* В программе не должно быть entry-функции с именем `GO`.
* Нельзя писать функции, в которых отсутствуют предложения между фигурными
  скобками.
* При выполнении арифметических действий (включая функцию `Numb`) следует
  избегать переполнения.
* Литералы чисел должны быть меньше 2³².
* Если в имени функции есть `-` или `_`, то во всех точках его использования
  (`$EXTERN`, символы-имена) оно должно писаться также, как и в определении
  (обычном или `$ENUM`/`$EENUM`). Например, если в определении функции
  используется имя `Ab-cd_ef`, то в других местах недопустимо её писать как
  `Ab_cd-ef`, `Ab-cd-ef` или `Ab_cd_ef`.
* После `<` может быть записано только имя функции, причём эта функция не может
  быть определена при помощи ключевых слов `$ENUM` или `$EENUM`. Знак `<` и имя
  функции должны быть написаны слитно (без пробельного символа или комментария
  между ними). Для косвенного вызова следует использовать встроенную функцию
  `Mu` (с некоторыми тонкими ограничениями — послеследующий подраздел).
* Функции делятся на две категории: подлежащие вызову (непосредственно — имя
  записывается после `<` или косвенно — вызываются через `Mu`) и не подлежащие
  вызову (используются ради их имён). Первые функции определяются обычным
  образом, вторые — при помощи ключевых слов `$ENUM` и `$EENUM`
  (в псевдокомментариях).
* Определения функций при помощи `$ENUM` и `$EENUM` должны записываться только
  в псевдокомментариях (подробнее в следующем подразделе).
* Для других целей псевдокомментарии использовать нельзя за исключением
  объявлений (`$EXTERN`) пустых entry-функций. Писать или нет такие объявления
  псевдокомментариями — вопрос личных предпочтений.
* Если косвенный вызов функции осуществляется из другого файла, вызываемая
  функция должна быть определена как entry (подробнее — через один подраздел).
* Если программа читает аргументы командной строки, они не должны начинаться
  со знака `-`, поскольку они игнорируются `refgo`.

И наоборот, как нужно писать программы на Рефале-5, чтобы они работали
в Рефале-05:

* Можно использовать только те встроенные функции, которые доступны в Рефале-05.
* В программе не должно быть entry-функции с именем `GO`. Стартовая функция
  программы должна называться `Go`.
* Длинную арфиметику и отрицательные числа использовать нельзя. Длинная
  арифметика в Рефале-05 не поддерживается вообще, числа со знаком поддерживают
  функции `Symb` и частично `Exit` и `System`. Следует избегать вычислений,
  где результат может быть отрицательным или состоять из нескольких макроцифр.
* Литеры чисел должны быть меньше 2³², если используется Рефал-5,
  скомпилированный на платформе Linux x64 или macOS — в нём макроцифры
  64-разрядные.
* Символы-слова могут записываться только в идентификаторной форме, двойными
  кавычками пользоваться нельзя.
* Нельзя определять функции или использовать символы-слова, которые различаются
  знаками `-` и `_`, поскольку в Рефале-05 они взаимозаменяемы.
* Сокращённый синтаксис (`<+ …>`) для арифметических функций использовать нельзя.
* Для любого символа-слова в текущем файле должно быть или определение функции
  с этим именем, или определение в псевдокомментарии, или объявление `$EXTERN`
  (можно в псевдокомментарии), или оно должно быть именем встроенной функции,
  доступной в Рефале-5. Дополнительные ограничения описаны в следующем
  подразделе.
* Косвенный вызов функций (через `Mu`) должен подчиняться ограничениям,
  описанным в подразделе после следующего.
* Условиями и блоками пользоваться нельзя.
* Неиспользуемая локальная функция в Рефале-05 является синтаксической ошибкой.

Вообще, при программировании на Рефале-05 рекомендуется придерживаться общего
подмножества. По двум причинам:

* Программы становятся переносимыми. Если пишется компонент, то его можно
  подключать и к программам на Рефале-5, и к программам на Рефале-05. Пример
  такого компонента — библиотека [`LibraryEx`][4].
* В выразительных возможностях программист почти ничего не теряет, но получает
  возможность пользоваться обоими инструментами, например, [встроенной
  отладкой][3] Рефала-05 и отладчиком `reftr` Рефала-5, не говоря уже
  о возможностях Рефала-5λ.
* По субъективному мнению автора программировать на общем подмножестве
  интереснее, чем на чистом Рефале-05.

### Куда поместить `$ENUM` и `$EENUM`: псевдокомментарии

Рефал-5 ключевые слова `$ENUM` и `$EENUM` не понимает. Функции, у которых между
фигурными скобками нет ни одного предложения, тоже не понимает.

Что же делать?

Не использовать символические имена вообще? Плохая идея, символические имена
упрощают понимание программы.

Для символических имён писать функции, единственное предложение которых содержит
какую-нибудь глупость? Многословно и засоряет код.

Было принято решение ввести синтаксис псевдокомментариев — особых комментариев,
которые Рефал-5 игнорирует, а Рефал-05 понимает. Тогда псевдокомментарий,
содержащий определение пустой функции Рефал-5 проигнорирует (для него это будет
обычный комментарий), а Рефал-05 поймёт как обычное определение пустой функции.

_Псевдокомментарий_ — это однострочный комментарий, в котором непосредственно
после `*` следует корректное ключевое слово (`$ENUM`, `$EENUM`, `$ENTRY` или
`$EXTERN`. Текст данного комментария обрабатывается так, как если бы звёздочки
не было и в конце строки была бы точка с запятой. Если однострочный комментарий
не начинается с корректного ключевого слова, то он игнорируется.

Например, следующие строки

    *$ENUM start, middle, end

    *$EENUM Opened, Closed, World

    *$EXTERN printf, scanf

    *$EXTERNAL WriteLn, ReadLn

    *$ENTRY Hello { = World }

    *$FROM LibraryEx
    $EXTERN Success;

Рефал-05 проинтерпретирует также, как эти строки:

     $ENUM start, middle, end;

     $EENUM Opened, Closed, World;

     $EXTERN printf, scanf;



     $ENTRY Hello { = World };


    $EXTERN Success;

Т.е. для псевдокомментариев звёздочка будет эквивалентна пустому месту
(здесь это показано пробелом в начале), обычные комментарии или комментарии
с «неключевыми» словами (`*$EXTERNAL`, `*$FROM`) будут проигнорированы.

Рефал-5 увидит в том же тексте только одну строчку:

    $EXTERN Success;

поскольку псевдокомментариев он не понимает.

Ради единообразия и простоты реализации псевдокомментарии могут начинаться
с любого допустимого ключевого слова, следовательно, в них можно прятать
`$EXTERN`’ы и даже объявления `$ENTRY`-функций. Очевидно, что если в программе
вызывается такая спрятанная функция, то она не сможет быть откомпилирована
Рефалом-5 — будет синтаксическая ошибка. Поэтому в общем подмножестве можно
использовать псевдокомментарии только для таких вещей, которые Рефал-5 видеть
не должен (`$ENUM` и `$EENUM`) или видеть ему не обязательно (`$EXTERN`’ы для
функций, которые не вызываются).

**Примечание.** Можно объявить пустую entry-функцию и без ключевого слова
`$EENUM`, вот так:

    *$ENTRY EmptyFunction {}

Программа с таким определением пустой функции будет попадать в общее
подмножество, однако, такой подход более многословный и не идиоматичный.
С точки зрения хорошего стиля так лучше не делать.

#### Для программистов на **Рефале-05** — как писать на общем подмножестве

Повторимся. Чтобы программа на Рефале-05 была корректной программой на Рефале-5:

* Пустые функции определялись только в псевдокомментариях.
* Псевдокомментарии не использовались для объявления и определения функций,
  которые вызываются из программы.

Для объявления функций, которые не вызываются и используются только ради
символических имён, можно помещать `$EXTERN` внутрь псевдокомментария — это
вопрос личных предпочтений программиста. В исходных текстах Рефала-05
псевдокомментарии для таких объявлений не использовались.

#### Для программистов на **Рефале-5** — как писать на общем подмножестве

Чтобы программа на Рефале-5 была корректной программой на Рефале-05, нужно
помнить, что каждый используемый символ-слово является именем функции, и имена
функций сравниваются не по текстовому представлению, а по ссылке.

Это значит, что если в разных файлах одно и то же имя объявлено в комментарии
`*$ENUM`, то символы, порождённые в разных файлах, в Рефале-05 будут не равны.

А имя, описанное в псевдокомментарии `*$EENUM`, находится в глобальной области
видимости — в одной программе не может быть определён символ в двух разных
комментариях `*$EENUM`.

Можно сформулировать такие правила. Для того, чтобы программа на Рефале-5
была корректной программой на Рефале-05:

* У любого имени, используемого в качестве символа-слова, в текущем файле
  должно быть или определение функции с этим именем, или это имя должно
  находиться в списке `$EXTERN`, либо в комментариях, начинающихся на `*$ENUM`,
  `*$EENUM`, `*$EXTERN`, либо это слово должно быть именем встроенной функции
  Рефала-05.
* В комментариях, начинающихся со слова `*$ENUM`, `*$EENUM` или `*$EXTERN`
  перечисляются через запятую имена допустимых символов.
* Символ не может быть описан более чем в одном комментарии `*$ENUM` или
  `*$EENUM` в данном файле.
* Символ не может быть описан более чем в одном комментарии `*$EENUM` во всей
  программе.
* Если символ описывается как `*$EENUM` в одном из файлов исходного текста,
  то во всех остальных, где он используется, либо должна экспортироваться
  функция в списке `$EXTERN`, либо имя записано в комментарии `*$EXTERN`.
* Если имя описано в комментарии `*$ENUM`, то символы с этим именем не могут
  «покидать» данного файла.

Последние два правила можно нарушать, если понимать, что `*$ENUM` и `*$EENUM` —
это определения функций, которые сравниваются не по именам, а по ссылкам.

#### А вообще — пустые функции не нужны

Рефал — функциональный язык. Рефал-05 и Рефал-5 — функциональные языки
с ограниченной поддержкой функций высшего порядка (в Рефале-5 она более
ограничена). Поддержка высшего порядка есть и в общем подмножестве, тонкостям
которого посвящён следующий подраздел.

А пустые функции — костыль, упрощающий реализацию компилятора и рантайма.

Поэтому хорошей практикой при программировании и на Рефале-05, и на общем
подмножестве (можно и на обычном Рефале-5 при желании) является использование
_непустых_ функций для символических имён.

Обычно пустые функции пишутся целыми семействами — например, если пишется
компилятор, будут группы символических имён для токенов, будут группы имён
для элементов синтаксического дерева, будут группы имён для команд
промежуточного кода (что, например, можно наблюдать в исходниках настоящего
компилятора).

И с такими группами иногда можно связать какое-либо действие «по умолчанию».
Например, каждый токен должен уметь себя выводить в текстовой форме для
вывода сообщения об ошибке. Команда промежуточного кода компилируется в кусок
целевого кода.

Поэтому если действие «по умолчанию» найти можно, то его обработку можно
поместить не в функцию, которая выбирает операцию в зависимости от символа,
а в сам символ — определив его непустой функцией. А потом его можно вызвать
при помощи функции `Mu` (но есть много тонких нюансов — см. следующий
подраздел).

Например, пусть у нас есть синтаксическое дерево такого вида

    t.Expr ::=
        (ExNumber s.Number)
      | (ExVariable e.Name)
      | (ExAdd t.Left t.Right)
      | (ExSub t.Left t.Right)
      | (ExMul t.Left t.Right)
      | (ExDiv t.Left t.Rigth)
      | (ExMinus t.Expr)

    t.Left, t.Right ::= t.Expr

И есть функция вывода этого дерева в виде арифметического выражения:

    StrFromExpr {
      (ExNumber s.Number) = <Symb s.Number>;
      (ExVariable e.Name) = e.Name;
      (ExAdd t.Left t.Right) =
         '(' <StrFromExpr t.Left> '+' <StrFromExpr t.Rigth ')';
      ...
    }

Если выбрать действием по умолчанию печать, то имена узлов дерева можно
определить как функции:

    $ENTRY ExNumber {
      s.Number = <Symb s.Number>;
    }

    $ENTRY ExVariable {
      e.Name = e.Name;
    }

    $ENTRY ExAdd {
      (s.Left e.LeftVal) (s.Right e.RightVal) =
        '(' <Mu s.Left e.LeftVal> '+' <Mu s.Right e.RightVal> ')';
    }

    ...

Теперь функции с символическими именами не пустые, а уже имеют некоторе
осмысленное тело.

В самом компиляторе Рефала-05 токены, формируемые лексическим анализатором,
умеют печатать сами себя — для любого токена вида

    (s.TokType t.SrcPos e.Info)

можно вызвать

    <Mu s.TokType e.Info>

и получить текстовую строку. Аналогично ведёт себя синтаксическое дерево —
любой его узел при вызове печатает себя в виде кода на Рефале-05. Внутри
кодогенератора для команд промежуточного языка определены функции, формирующие
код на Си этой конструкции.

#### Лирическое отступление: ООП в Рефале-05

Вообще, это подход можно развить до идиоматической реализации ООП (без
наследования). Каждый объект — скобочный терм, начинающийся с символического
имени. Функция символического имени является виртуальной таблицей — может
обрабатывать различные сообщения. Методы эти сообщения посылают.

Выглядит это так. Фигуры «Прямоугольник» (`ORect`) и «Круг» (`OCircle`) могут
распечатать себя в текстовом виде (метод `MPrint`), сдвинуться (метод `MMove`)
и ответить, содержат ли они точку с заданными координатами (метод `MHasPoint`).
Точка (`OPoint`) тоже может себя печатать и двигаться:

    ORect {
      (ORect t.LeftTop t.RightBottom) MPrint =
        'Rectangle [' <MPrint t.LeftTop> '-' <MPrint t.RightBottom> ']';

      (ORect t.LeftTop t.RightBottm) MMove t.Offset =
        (ORect <MMove t.LeftTop t.Offset> <MMove t.RightBootom t.Offset>);

      (ORect (OPoint s.Left s.Top) (OPoint s.Right s.Bottom))
      MHasPoint (OPoint s.X s.Y)
        <And <InRange s.Left s.X s.Right> <InRange s.Bottom s.Y s.Top>>;
    }

    OCircle {
      (OCircle t.Center s.Radius) MPrint =
        'Circle [center: ' <MPrint t.Center> ', radius: ' <Symb s.Radius> ']';

      (OCircle t.Center s.Radius) MMove t.Offset =
        (OCircle <MMove t.Center> s.Radius);

      (OCircle (OPoint s.CX s.CY) s.Radius) MHasPoint (OPoint s.X s.Y) =
        <InRange
          0
          <Add <Square <Dist s.CX s.X>> <Square <Dist s.CY s.Y>>>
          <Square s.Radius>
        >;
    }

    OPoint {
      (OPoint s.X s.Y) MPrint = '(' <Symb s.X> ', ' <Symb s.Y> ')';

      (OPoint s.X s.Y) MMove (OPoint s.dX s.dY) =
        (OPoint <Add s.X s.dX> <Add s.Y s.dY>);
    }

    MPrint {
      t.Object = <Send t.Object MPrint>;
    }

    MMove {
      t.Object t.Offset = <Send t.Object MMove t.Offset>;
    }

    MHasPoint {
      t.Object t.Point = <Send t.Object MHasPoint t.Offset>;
    }

    Send {
      (s.VTable e.Data) s.Method e.Args =
        <Mu s.VTable (s.VTable e.Data) s.Method e.Args>;
    }

(Функции `InRange`, `Dist` и `Square` имеют очевидную, но громоздкую реализацию,
которая для краткости не приведена.)

И кто теперь скажет, что Рефал-05 не объектно-ориентированный язык 😉?
<!--Тут подмигивающий эмодзи-->

### Косвенный вызов в Рефале-5 и Рефале-05, разная семантика `Mu`

#### Косвенный вызов в Рефале-05: вызов по указателю

В Рефале-05 всё достаточно просто: имена функций — это указатели на сами
функции, когда имя функции оказывается справа от `<` — она вызывается.

Рассмотрим пример, пусть у нас есть такие четыре файла:

Файл `go.ref`:

    *$FROM a.ref
    $EXTERN IndirectA;

    *$FROM b.ref
    $EXTERN IndirectB;

    *$FROM c.ref
    $EXTERN IndirectC;

    $ENTRY Go {
      /* пусто */ =
        <IndirectA>
        <IndirectB>
        <IndirectC>;
    }

Файл `a.ref`:

    *$FROM b.ref
    $EXTERN Call;

    $ENTRY IndirectA { = <Call Callable> }

    Callable { = <Prout 'A'> }

Файл `b.ref`:

    $ENTRY IndirectB { = <Call Callable> }

    Callable { = <Prout 'B'> }

    $ENTRY Call {
      s.Func = </*Mu*/ s.Func>;
    *             ↑——— раскомментировать для Рефала-5
    }

Файл `c.ref`:

    *$FROM b.ref
    $EXTERN Call;

    $ENTRY IndirectC { = <Call CallableC> }

    /*$ENTRY*/ CallableC { = <Prout 'C'> }
    *    ↑——— раскомментировать для Рефала-5

(О комментариях будет сказано в следующем подпараграфе.)

Программа напечатает:

    A
    B
    C

Эта программа — программа на Рефале-05, которая, однако, не является корректной
программой на Рефале-5, очевидно, из-за того, что в функции `Call` косвенный
вызов записывается без `Mu`.

Косвенный вызов в Рефале-05 ничем: ни синтаксически, ни семантически
не отличается от прямого. После открывающей угловой скобки синтаксически может
располагаться всё, что угодно, главное, чтобы при активации этой скобки там
оказался символ-функция.

Различий между именами функций, которые пишутся непосредственно после `<`
и в любых других местах ни при компиляции, ни при выполнении нет.

Символы-функции содержат указатель на код, при активации этот код просто
выполняется.

Поэтому косвенный вызов в Рефале-05 не более чем приём программирования, когда
после `<` размещается не фиксированное имя, а переменная или даже результат
вызова другой функции.

Поэтому функция `IndirectA` поместит в поле зрения указатель на функцию
`Callable` из файла `a.ref`, и именно её «косвенно» вызовет функция `Call`.
В результате будет напечатана буква `A`. Аналогично будут вызываться
`Callable` из файла `b.ref` и `CallableC` из файла `c.ref`.

Функция `Mu` в Рефале-05 определена как

    $ENTRY Mu {
       s.Func e.Arg = <s.Func e.Arg>;
    }

т.е. она просто осуществляет косвенный вызов. Запись `<s.Func …>` и `<Mu
s.Func …>` семантически идентичны, просто во втором случае требуется ещё один
шаг рефал-машины.


#### Косвенный вызов в Рефале-5: вызов по имени

Если мы попробуем откомпилировать и запустить код из предыдущего подпараграфа,
то Рефал-5 даст нам по рукам два раза. Первый раз при компиляции — потребуется
заменить синтаксически некорректный косвенный вызов в функции `Call` на функцию
`Mu`. Второй раз во время выполнения — программа вылетит при вызове `Mu`
с аргументом `CallableC`. Чтобы это исправить, нужно сделать функцию `CallableC`
entry-функцией. (Правки, которые необходимо внести, отмечены комментариями.)

Тогда программа корректно отработает и напечатает

    B
    B
    C

С добавлением `Mu` в функцию `Call` всё понятно — синтаксис Рефала-5 требует,
чтобы открывающая угловая скобка буквально _содержала_ имя функции (скобка и имя
рассматриваются как единый токен, между ними даже нельзя поставить пробел).
А вот с `CallableC` и первой строчкой `B` всё не так очевидно.

Во время загрузки программы имена функций при открывающих скобках вызова
заменяются на адреса соответствующих функций, при их активации управление
передаётся на нужный адрес.

Косвенный вызов в Рефале-5 осуществляется при помощи функции `Mu` — она первым
термом принимает имя функции, остальная часть трактуется как аргумент. Имя может
быть записано либо как символ-слово, либо как последовательность литер в круглых
скобках:

    <Mu t.FuncName e.AnyExpr> == e.AnyExpr

    t.FuncName ::= s.WORD | (s.CHAR+)

Символы-слова в Рефале-5 никаких указателей на функции (адреса кода)
не содержат, а уж цепочки литер — и подавно.

Функция `Mu` находит выполняемую функцию _по её имени,_ причём поиск
осуществляется сначала в том файле, где _записан_ вызов функции `Mu`, а потом
(если имя не найдено) — среди всех entry-функций программы.

Иначе говоря, можно считать, что в каждом файле исходной программы неявно
определена своя _локальная_ функция `Mu`, имеющая по паре предложений для каждой
функции файла, каждой внешней функции и каждой встроенной функции. Например,
для файла `b.ref` функция `Mu` имела бы такой вид:

    Mu {
      /* все функции файла */
      IndirectB e.Arg = <IndirectB e.Arg>;
      ('IndirectB') e.Arg = <IndirectB e.Arg>;

      Callable e.Arg = <Callable e.Arg>;
      ('Callable') e.Arg = <Callable e.Arg>;

      Call e.Arg = <Call e.Arg>;
      ('Call') e.Arg = <Call e.Arg>;

      /* все entry-функции */
      Go e.Arg = <Go e.Arg>;
      ('Go') e.Arg = <Go e.Arg>;

      IndirectA e.Arg = <IndirectB e.Arg>;
      ('IndirectA') e.Arg = <IndirectB e.Arg>;

      IndirectB e.Arg = <IndirectB e.Arg>;
      ('IndirectB') e.Arg = <IndirectB e.Arg>;

      IndirectC e.Arg = <IndirectB e.Arg>;
      ('IndirectC') e.Arg = <IndirectB e.Arg>;

      CallableC e.Arg = <CallableC e.Arg>;
      ('CallableC') e.Arg = <CallableC e.Arg>;

      /* все встроенные функции */
      Mu e.Arg = <Mu e.Arg>;
      ('Mu') e.Arg = <Mu e.Arg>;

      Add e.Arg = <Add e.Arg>;
      ('Add') e.Arg = <Add e.Arg>;

      Arg e.Arg = <Arg e.Arg>;
      ('Arg') e.Arg = <Arg e.Arg>;

      ...
    }

**Примечание.** Поиск среди entry-функций не документирован в учебнике Турчина,
но о нём написано [в дополнениях к учебнику][Att].

Теперь рассмотрим, что происходит в нашем примере. Функция `IndirectA` помещает
в поле зрения вызов `<Call Callable>`, где `<Call` — вызов функции `Call`
из `b.ref` (прямые вызовы разрешаются при загрузке программы), а `Callable` —
это просто символ-слово. Заметим, что к функции `Callable` из файла `a.ref`
этот символ никакого отношения не имеет.

Функция `Call` определена в файле `b.ref` и она вызывает функцию `Mu`, которая
будет осуществлять поиск в файле, где её вызов записан. Т.е. в `b.ref`. А там
уже есть своя функция с именем `Callable` — она и будет вызвана. Поэтому первой
строчкой напечатается `B`.

Абсолютно аналогично будет выполняться вызов функции `IndirectB`.

С функцией `IndirectC` интереснее — в поле зрения будет помещён `<Call
CallableC>`, который раскроется в `<Mu CallableC>`. Функция `CallableC`
не определена в файле `b.ref`, поэтому функция `Mu` будет осуществлять поиск
среди entry-функций. `CallableC` — entry-функция, поэтому она будет вызвана
и напечатает `C`. До того, как мы добавили ключевое слово `$ENTRY`, программа
падала, поскольку функция `Mu` ничего не находила.

**Примечание.** Косвенный вызов в Рефале-5 может осуществляться также функциями
`Up`, `Ev-met` и недокументированной `Residue`, имеющей короткий синтаксис
`<? …>`, но для них поиск имени осуществляется точно так же.

Благодаря тому, что функция `Mu` может вызывать любые entry-функции программы,
на Рефале-5 можно писать библиотеки функций высшего порядка. Например, можно
написать функцию `Map` такого вида:

    $ENTRY Map {
      s.Func t.Next e.Items = <Mu s.Func t.Next> <Map s.Func e.Items>;
      s.Func /* пусто */ = /* пусто */;
    }

(Функция `Map` в `LibraryEx` определена немного иначе). А чтобы `Mu` могла
находить вызываемую функцию по имени, её надо будет определять как entry:

    $EXTERN Map;

    $ENTRY Go {
      = <Map PrintLine ('One') ('Two') ('Three')>;
    }

    $ENTRY PrintLine {
      (e.Line) = <Prout e.Line>;
    }

При этом надо быть уверенным, что файл с определением `Map` сам не содержит
локальную функцию с именем `PrintLine`, поскольку в таком случае будет вызвана
не та функция.

#### Косвенный вызов в общем подмножестве

Механизмы косвенного вызова в Рефале-05 и Рефале-5 существенно различаются,
однако, для них можно найти общий знаменатель.

Очевидные синтаксические ограничения:

* В Рефале-05 для косвенного вызова нужно обязательно использовать функцию `Mu`.
* В Рефале-5 имя функции для `Mu` всегда должно передаваться символом-словом
  (а не цепочкой литер в скобках).

Тонкие семантические особенности:

* Если вызываемые функции определены в том же файле, где и их вызов при помощи
  функции `Mu`, то ничего делать не надо — программа уже находится в общем
  подмножестве.
* Если вызов функции `Mu` и косвенно вызываемая функция расположены в разных
  файлах, то вызываемая функция должна быть entry (как в примере с `PrintLine`
  выше). На Рефале-05 это ключевое слово будет избыточным, но в Рефале-5 оно
  необходимо.
* Следует помнить о том, что на Рефале-5 функция `Mu` сначала просматривает
  функции файла со своим вызовом, а уже потом — глобальное пространство
  entry-функций. А это значит, что надо остерегаться конфликта имён с обеих
  сторон: подбирать имя entry-функции таким образом, чтобы оно не было похоже
  на локальные функции модуля с косвенным вызовом и подбирать имена локальным
  функциям, чтобы избежать конфликта с возможными entry-функциями.

Да, в Рефале-5 локальные функции не такие локальные: если в файле есть вызов
`Mu`, можно извне вызвать любую из них.

Есть один важный стилевой момент. Основное предназначение ключевого слова
`$ENTRY` — отделять интерфейс модуля (набор входных точек) от его реализации,
внутренней кухни. Но в случае косвенного вызова в Рефале-5 и общем подмножестве
программист вынужден делать входными точками те функции, которые по смыслу
являются деталями реализации и в интерфейс не входят.

Как же избежать конфликта имён? В исходных текстах Рефала-05 принят такой
подход. Имена всех функций по умолчанию пишутся с большой буквы. Функций,
которые косвенно вызываются извне и должны быть entry, начинаются с префикса,
представляющего собой имя файла с маленькой буквы и прочерк. Такое странное
имя, во-первых, предотвращает возможный конфликт, если в разных файлах
потребуется определить entry-Функции с одинаковыми именами, во-вторых,
намекает, что эта entry-функция является деталью реализации и не входит
в интерфейс модуля. Пример такого имени: `generator_GenCommand`, которая
определена в файле `R05-Generator.ref`

С другой стороны — локальные функции часто являются частью алгоритма какой-то
другой entry-функции. Имена таких вспомогательных функций строятся из имени
entry-функции путём добавления либо префиксов `Sw` и `Do`, либо смысловых
суффиков вида `Функция-Подфункция` (см. [Приложение A](A-style-guide.md)).
Таким образом имена точек входа и имена вспомогательных функций заметно
различаются и тем самым минимизируется конфликт.

Подытожим. Чтобы программа на Рефале-05 была корректной программой на Рефале-5:

* косвенный вызов всегда должен осуществляться через `Mu`,
* функции, косвенно вызываемые в другом модуле, должны быть помечены ключевым
  словом entry,
* при написании нужно помнить о возможных конфликтах с локальными функциями
  в месте вызова.

Чтобы программа на Рефале-5 была корректной программой на Рефале-05:

* Имя вызываемой функции для функции `Mu` должно передаваться как символ-слово,
  а не скобочный терм с литерами.
* Символ-слово, который передаётся потом в функцию `Mu`, должен быть именем
  функции, видимой как в точке написания символа, так и в точке вызова функции
  `Mu` — причём должна быть видна одна и та же функция.

Для иллюстрации последнего правила рассмотрим следующий пример. Файл `go.ref`:

    $EXTERN CallA, CallB, Foo, Bar;

    $ENTRY Go {
      = <CallA Foo> <CallB Foo> <CallA Bar> <CallB Bar>
    }

Файл `a.ref`:

    $ENTRY CallA { s.Func = <Mu s.Func> }

    $ENTRY Foo { = <Prout 'A Foo'> }
    Bar { = <Prout 'A Bar'> }

    * В Рефале-05 неиспользуемая локальная функция является ошибкой синтаксиса
    $ENTRY A { = Bar }

Файл `b.ref`:

    $ENTRY CallB { s.Func = <Mu s.Func> }

    Foo { = <Prout 'B Foo'> }
    $ENTRY Bar { = <Prout 'B Bar'> }

    * В Рефале-05 неиспользуемая локальная функция является ошибкой синтаксиса
    $ENTRY B { = Foo }

Эта функция нарушает последнее правило, поскольку в вызове `<CallB Foo>` символ
`Foo` является именем функции `Foo` из файла `a.ref`, а в точке вызова функции
`Mu` (в теле функции `CallB`) видна локальная функция `Foo` файла `b.ref`. Та же
проблема и с вызовом `<CallA Bar>`. И действительно, не смотря на то, что эта
программа успешно компилируется и запускается обоими языками, результат выводится
разный:

    C:\…>refal05c.exe go.ref a.ref b.ref refal05rts Library
    *Compiling go.ref:
    *Compiling a.ref:
    *Compiling b.ref:
    +Linking C:\…\refal05rts.c
    +Linking C:\…\Library.c
    *** Compilation successed ***

    C:\…>go.exe
    A Foo
    A Foo
    B Bar
    B Bar

    C:\…>refc go.ref a.ref b.ref
    Refal-5 Compiler. Version PZ Oct 29 2004
    Copyright: Refal Systems Inc.

    C:\…>refgo go+a+b
    A Foo
    B Foo
    A Bar
    B Bar

[Att]: ftp://ftp.botik.ru/pub/local/scp/refal5/book/attachment-to-refal-book_180214.zip
[B]: B-syntax-grammar.md
[3]: 3-install-and-usage.md
[4]: https://mazdaywik.github.io/refal-5-framework/LibraryEx
[5]: 5-implementation.md
