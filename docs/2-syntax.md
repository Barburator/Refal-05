Язык Рефал-05, его отличия от Рефала-5 и общее подмножество
===========================================================

Синтаксис Рефала-05
-------------------

Синтаксис внешне похож на классический Рефал-5 (версия `PZ Oct 29 2004`),
но с некоторыми тонкими отличиями. Программисты, знакомые с Рефалом-5, могут
пробежать глазами этот раздел, обращая лишь внимание на эти отличия (они будут
выделены **жирным** шрифтом).

Программа на Рефале-05 состоит из нескольких единиц трансляции — исходных
файлов на Рефале и на Си. Компилятор каждый исходный файл на Рефале транслирует
в файл на языке Си (сохраняя его в той же папке и с тем же именем), после
чего вызывает компилятор языка Си для сборки исполнимого файла (подробнее —
в руководстве пользователя <!--TODO-->). Каждая единица трансляции на Рефале
компилируется независимо.

Программа на Рефале записывается в свободном синтаксисе, т.е. переводы строк
являются обычными разделителями, наряду с пробелами и табуляциями. Пробельные
символы могут вставляться между любыми лексемами языка, обязательны лишь там,
где их отсутствие приведёт к склеиванию лексем (например, пара чисел `10 20`,
разделённая пробелом, склеится в одно число `1020`). Внутри цепочек литер
(см. далее) пробелы уже значимы — интерпретируются как литеры со значением
«пробел».

На месте любого пробельного символа можно записать комментарий. Комментарии
могут быть двух видов: однострочные и многострочные. Однострочные комментарии —
это строки программы, самым первым символом которой является знак `*`.
Многострочные комментарии такие же как в Си: начинаются с `/*` и заканчиваются
на `*/`. Многострочные комментарии не могут быть вложенными. Даже более того,
внутри многострочных комментариев запрещена последовательность символов `/*`
(чтобы предотвратить попытки закомментировать код, уже содержащий комментарий).

Компилятор обычно игнорирует содержимое комментариев, за исключением двух
случаев. Во-первых, как уже сказано, просматривается содержимое многострочных
комментариев — проверяется, что внутри них нет знаков `/*`. Во-вторых, есть
так называемые _псевдокомментарии,_ которые на самом деле комментариями
не являются. Но о них позже.


### Имена функций, объявления и определения

Файл исходного текста на Рефале состоит из набора объявлений и определений
функций. Определение функции описывает саму функцию, объявление функции
говорит о том, что где-то в программе (как правило, в другой единице трансляции)
определена функция с этим именем. Объявление функции, определённой в том же
файле, совершенно бесполезно, однако, синтаксической ошибкой не является.

**Имена функций** имеют примерно тот же вид, что и в других языках
программирования: начинаются с латинской буквы и состоят из латинских букв,
цифр, знаков прочерка _и знаков минуса,_ при этом знаки минуса и прочерка
взаимозаменяемы, имена чувствительны к регистру. Примеры: `Go`, `fact`,
`R05-Generate-ToFile`, `findfile_AnalyzeFile-ByFolders`. Три разных имени
функции: `ABC`, `Abc` и `abc`, поскольку имена чувствительны к регистру.
Одно и то же имя функции: `A_b-c` и `A-b_c`, поскольку знаки `-` и `_`
взаимозаменяемы. Рефал-05 длину имён функций не ограничивает, однако,
нижележащий компилятор языка Си может рассматривать как значимые только
первые `N` символов (где величина `N` зависит от компилятора).

**Отличие от Рефала-5.** Знаки `-` и `_` в именах функций взаимозаменяемы.

Объявление функции имеет вид:

    $EXTERN Имя;

Здесь ключевое слово `$EXTERN` говорит о том, что эта функция определена где-то
ещё, после ключевого слова записывается имя функции.

Рефал-05 — динамически типизированный язык, все функции принимают и возвращают
произвольное объектное выражение (см. далее). Поэтому в объявлени ничего, кроме
имени, указывать не надо.

После ключевого слова `$EXTERN` можно указывать несколько имён функций:

    $EXTERN Имя1, Имя2, Имя3;

Это то же самое, что и

    $EXTERN Имя1;
    $EXTERN Имя2;
    $EXTERN Имя3;

**Отличие от Рефала-5.** В Рефале-5 можно использовать ключевые слова `$EXTERN`,
`$EXTRN` и `$EXTERNAL`. В Рефале-05 — только `$EXTERN`.

Определение функции в общем случае имеет вид:

    ИмяФункции {
      тело-функции
    }

или

    $ENTRY ИмяФункции {
      тело-функции
    }

Если функция определена без ключевого слова `$ENTRY`, то её область видимости
ограничена тем файлом, где она находится — _по имени_ к ней обратиться можно
только в текущем файле. Если функция определена с использованием ключевого
слова `$ENTRY`, то она находится в _глобальной области видимости_ — на неё
можно сослаться из других файлов при помощи ключевого слова `$EXTERN`. Будем
говорить об области видимости файла как о _локальной области видимости,_
функции, помеченные словом `$ENTRY` будем называть _entry-функциями,_ без этого
ключевого слова — _локальными функциями._ Entry-функции одновременно находятся
и в глобальной области видимости всей программы, и в локальной области видимости
файла, где они определены.

Теперь можно точнее сформулировать семантику ключевого слова `$EXTERN`: оно
используется для того, чтобы добавить указанные имена функций из глобальной
области видимости в локальную.

В коде на языке Си локальные функции соответствуют определениям, записанным
с использованием ключевого слова `static`, entry-функции — определениям без
ключевого слова `static`. Объявления внешних функций (но только тех, которые
используются), компилируются в `extern`’ы. Тонкости кодогенерации мы рассмотрим
в одной из следующих глав. <!--TODO-->

Функция в Рефале-05 может быть написана как на Рефале, так и на языке Си (при
помощи синтаксиса _нативных вставок)._ В этом разделе мы будем рассматривать
только функции, написанные на Рефале.

**Отличие от Рефала-5.** Тело функции может быть записано на языке Си, см. одну
из следующих глав. <!--TODO-->

_Тело функции_ представляет собой набор из нескольких предложений — правил
вычисления функции:

    ИмяФункции {
      предложение1;
      предложение2;
      …
      предложениеN;
    }

В конце каждого предложения пишется точка с запятой, при этом в конце последнего
предложения точку с запятой допустимо не ставить.

_Предложение_ состоит из двух частей — образца и результата, которые разделяются
знаком равенства:

    образец = результат;

_Образец_ описывает подмножество значений аргумента, для которого применимо
данное предложение, _результат_ — как должна вычисляться функция на данном
подмножестве. Образец также называют _образцовым выражением_ или _левой частью,_
результат — _результатным выражением_ или _правой частью._

Объединение множеств значений аргумента, описываемых каждым из образцов,
образует область определения функции с учётом вызовов других функций в правых
частях.

Аргумент сопоставляется с образцами сверху вниз, срабатывает правая часть
у первого образца с которым удалось _отождествить_ аргумент функции. Если
такого образца не нашлось, программа аварийно останавливается с выдачей ошибки
_«отождествление невозможно»_ (recognition impossible).

Рефал-05 допускает функции с пустым телом — когда между фигурными скобками
не записано ни одного предложения. Такие функции аварийно останавливаются
при любом аргументе. Просто потому, что нет подходящего предложения, потому что
предложений вообще нет.

**Отличие от Рефала-5.** Рефал-5 не допускает функции без предложений, Рефал-05
допускает.

На первый взгляд может показаться, что такие функции бесполезны. Но, как будет
показано ниже, такие функции в Рефале-05 на столько часто нужны, что для их
записи предусмотрен синтаксический сахар. Ключевое слово `$ENUM` определяет
пустые локальные функции с заданными именами, `$EENUM` (entry enum) —
entry-функции. Запись

    $ENUM One, Two, Three;
    $EENUM Four, Five, Six;

эквивалентна

    One { }
    Two { }
    Three { }
    $ENTRY Four { }
    $ENTRY Five { }
    $ENTRY Six { }

**Отличие от Рефала-5.** В Рефале-5 нет ни пустых функций, ни сокращённого
синтаксиса для них.

Прежде, чем описать вид образца и результата, нужно обсудить, какие данные Рефал
обрабатывает, что именно является аргументом функции.

Данные, обрабатываемые Рефалом, называются _объектными выражениями._ Объектное
выражение — это последовательность символов (неделимых элементов данных, атомов)
и _круглых скобок,_ причём круглые скобки должны быть сбалансированы.

_Символы_ делятся на три вида:

* символы-литеры — ASCII-символы: буквы, цифры, знаки препинания и арифметики,
  пробелы, переводы строк и прочие,
* символы-числа — неотрицательные числа меньше чем 2<super>N</super>, где N —
  число, зависящее от используемой платформы,
* символы-функции — имена функций из области видимости файла.

**Символы-литеры** записываются в одинарных кавычках: `'a'`, `'R'`, `'7'`,
`'+'`, `':'` и т.д. Несколько литер, записанных подряд, могут быть записаны
слитно под одними кавычками: `'O' 'n' 'e'` эквивалентно `'One'`. Допустимы
escape-последовательности

Последовательность |              Означает
-------------------|------------------------------------
      `'\n'`       | новая строка
      `'\r'`       | возврат каретки
      `'\t'`       | табуляция
      `'\''`       | одинарная кавычка
      `'\\'`       | символ обратной косой черты
     `'\xHH'`      | символ с шестнадцатеричным кодом HH

Также поддерживаются последовательности `'\"'`, `'\<'`, `'\>'`, `'\('`, `\)'`,
означающие, соответственно, `'"'`, `'<'`, `'>'`, `'('`, `')'`. Формально они
не нужны, но добавлены для совместимости с Рефалом-5.

**Символы-числа** — целые числа в диапазоне от 0 до 2<super>N</super>−1,
величина N равна числу бит в типе `unsigned long` используемого компилятора Си.
Записываются они как последовательности десятичных цифр, причём переполнение
не проверяется — если записанное число не входит в допустимый диапазон, то оно
будет молча проинтерпретировано как остаток от деления этого числа
на 2<super>N</super>. Например, если `unsigned long` содержит 32 двоичных
разряда, число `99999999999999999999999999999999` будет проинтерпретировано
как `4294967295`, если 64 — как `9632337040368467967`.

**Отличие от Рефала-5.** В Рефале-5 символы-числа называются макроцифрами,
поскольку встроенные арифметические функции поддерживают длинную арифметику.
Ещё в Рефале-5 компилятор всё-таки контролирует переполнение.

**Символы-функции** — это имена функций, видимых в текущем файле (т.е. функция
с этим именем должна быть определена, либо объявлена как `$EXTERN`). Функции
в Рефале-05 используются с двумя целями: собственно, как вызываемые функции,
и только как их имена.

Часто при программировании на Рефале возникает потребность выразить одно
из нескольких значений. Например, встроенная функция `ExistFile`, проверяющая
существование файла, должна вернуть некий признак истины или лжи. Можно
возвращать литеры, например, `'T'` или `'F'`, можно возвращать числа, например,
`1` или `0`, можно возвращать слова из литер: `'True'`, `'False'`.

Одиночные литеры или цифры малопонятны, строчки из литер избыточны — значение
можно передать одним знаком. В Рефале-05 для выражения таких признаков
используются имена функций, например, функция `ExistFile` возвращает функцию
`True` или `False`. Такие функции обычно не вызываются, а используются ради
их имён, поэтому их обычно определяют как пустые функции.

Функции сравниваются не по имени, а по ссылке. Это значит, что если в разных
файлах определены две одноимённые функции (обе локальные, или одна из них
entry), то они будут не равны не смотря на одинаковое имя. Например, символы
`True` и `False` определены в стандартной библиотеке `Library` (как `$EENUM`),
поэтому если пользователь определит эти же имена как `$ENUM` — новые функции
будут не равны, хоть и будут иметь то же имя.

Следовательно, чтобы не возникало недоразумений, пустые функции должны или
определяться как `$EENUM` в одной единице трансляции, а в остальных поключаться
как `$EXTERN`, или определяться как `$ENUM`, но при этом использоваться только
внутри текущей единицы трансляции.

**Отличие от Рефала-5.** В Рефале-5 нет символов-функций, есть символы-слова.
Слова могут записываться как произвольные строки символов, окружённые двойными
кавычками. Если слово удовлетворяет ограничениям на идентификатор Рефала-5
(начинается с буквы и состоит из букв, цифр, прочерков и минусов), то его
можно записывать без кавычке. Слова не являются указателями на функции, т.е.
слово `False` не требует, чтобы где-нибудь в программе была объявлена функция
`False`. Символы-слова в Рефале-5 сравниваются по их текстовому представлению.

**Круглые скобки** не являются символами, они служат для задания структуры
объектному выражению, поэтому их также называют **структурными скобками.**
Выражение, записанное в круглых скобках, образует **скобочный терм** — объект,
в некоторых случаях интерпретируемый как единое целое.

**Термом** объектного выражения называется либо символ, либо скобочный терм,
таким образом, можно дать альтернативное определение объектному выражению:

**Объектное выражение** — последовательность термов.
**Терм** — символ или выражение в круглых скобках (скобочный терм).

Теперь уже можно рассмотреть, чем являются образцовые и результатные выражения.












