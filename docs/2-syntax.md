Язык Рефал-05, его отличия от Рефала-5 и общее подмножество
===========================================================

Синтаксис Рефала-05
-------------------

Синтаксис внешне похож на классический Рефал-5 (версия `PZ Oct 29 2004`),
но с некоторыми тонкими отличиями. Программисты, знакомые с Рефалом-5, могут
пробежать глазами этот раздел, обращая лишь внимание на эти отличия (они будут
выделены **жирным** шрифтом).

Программа на Рефале-05 состоит из нескольких единиц трансляции — исходных
файлов на Рефале и на Си. Компилятор каждый исходный файл на Рефале транслирует
в файл на языке Си (сохраняя его в той же папке и с тем же именем), после
чего вызывает компилятор языка Си для сборки исполнимого файла (подробнее —
в руководстве пользователя <!--TODO-->). Каждая единица трансляции на Рефале
компилируется независимо.

Программа на Рефале записывается в свободном синтаксисе, т.е. переводы строк
являются обычными разделителями, наряду с пробелами и табуляциями. Пробельные
символы могут вставляться между любыми лексемами языка, обязательны лишь там,
где их отсутствие приведёт к склеиванию лексем (например, пара чисел `10 20`,
разделённая пробелом, склеится в одно число `1020`). Внутри цепочек литер
(см. далее) пробелы уже значимы — интерпретируются как литеры со значением
«пробел».

На месте любого пробельного символа можно записать комментарий. Комментарии
могут быть двух видов: однострочные и многострочные. Однострочные комментарии —
это строки программы, самым первым символом которой является знак `*`.
Многострочные комментарии такие же как в Си: начинаются с `/*` и заканчиваются
на `*/`. Многострочные комментарии не могут быть вложенными. Даже более того,
внутри многострочных комментариев запрещена последовательность символов `/*`
(чтобы предотвратить попытки закомментировать код, уже содержащий комментарий).

Компилятор обычно игнорирует содержимое комментариев, за исключением двух
случаев. Во-первых, как уже сказано, просматривается содержимое многострочных
комментариев — проверяется, что внутри них нет знаков `/*`. Во-вторых, есть
так называемые _псевдокомментарии,_ которые на самом деле комментариями
не являются. Но о них позже, в разделе об общем подмножестве.


### Имена функций, объявления и определения

Файл исходного текста на Рефале состоит из набора объявлений и определений
функций. Определение функции описывает саму функцию, объявление функции
говорит о том, что где-то в программе (как правило, в другой единице трансляции)
определена функция с этим именем. Объявление функции, определённой в том же
файле, совершенно бесполезно, однако, синтаксической ошибкой не является.

**Имена функций** имеют примерно тот же вид, что и в других языках
программирования: начинаются с латинской буквы и состоят из латинских букв,
цифр, знаков прочерка _и знаков минуса,_ при этом знаки минуса и прочерка
взаимозаменяемы, имена чувствительны к регистру. Примеры: `Go`, `fact`,
`R05-Generate-ToFile`, `findfile_AnalyzeFile-ByFolders`. Три разных имени
функции: `ABC`, `Abc` и `abc`, поскольку имена чувствительны к регистру.
Одно и то же имя функции: `A_b-c` и `A-b_c`, поскольку знаки `-` и `_`
взаимозаменяемы. Рефал-05 длину имён функций не ограничивает, однако,
нижележащий компилятор языка Си может рассматривать как значимые только
первые `N` символов (где величина `N` зависит от компилятора).

**Отличие от Рефала-5.** Знаки `-` и `_` в именах функций взаимозаменяемы.

Объявление функции имеет вид:

    $EXTERN Имя;

Здесь ключевое слово `$EXTERN` говорит о том, что эта функция определена где-то
ещё, после ключевого слова записывается имя функции.

Рефал-05 — динамически типизированный язык, все функции принимают и возвращают
произвольное объектное выражение (см. далее). Поэтому в объявлени ничего, кроме
имени, указывать не надо.

После ключевого слова `$EXTERN` можно указывать несколько имён функций:

    $EXTERN Имя1, Имя2, Имя3;

Это то же самое, что и

    $EXTERN Имя1;
    $EXTERN Имя2;
    $EXTERN Имя3;

**Отличие от Рефала-5.** В Рефале-5 можно использовать ключевые слова `$EXTERN`,
`$EXTRN` и `$EXTERNAL`. В Рефале-05 — только `$EXTERN`.

Определение функции в общем случае имеет вид:

    ИмяФункции {
      тело-функции
    }

или

    $ENTRY ИмяФункции {
      тело-функции
    }

Если функция определена без ключевого слова `$ENTRY`, то её область видимости
ограничена тем файлом, где она находится — _по имени_ к ней обратиться можно
только в текущем файле. Если функция определена с использованием ключевого
слова `$ENTRY`, то она находится в _глобальной области видимости_ — на неё
можно сослаться из других файлов при помощи ключевого слова `$EXTERN`. Будем
говорить об области видимости файла как о _локальной области видимости,_
функции, помеченные словом `$ENTRY` будем называть _entry-функциями,_ без этого
ключевого слова — _локальными функциями._ Entry-функции одновременно находятся
и в глобальной области видимости всей программы, и в локальной области видимости
файла, где они определены.

**Примечание.** Компилятор Рефала-05 требует, чтобы все локальные функции
в программе использовались, в противном случае выдаётся синтаксическая ошибка.
Возможно, в будущих версиях ошибка будет заменена на предупреждение,
не препятствующее дальнейшей компиляции.

Теперь можно точнее сформулировать семантику ключевого слова `$EXTERN`: оно
используется для того, чтобы добавить указанные имена функций из глобальной
области видимости в локальную.

В коде на языке Си локальные функции соответствуют определениям, записанным
с использованием ключевого слова `static`, entry-функции — определениям без
ключевого слова `static`. Объявления внешних функций (но только тех, которые
используются), компилируются в `extern`’ы. Тонкости кодогенерации мы рассмотрим
в одной из следующих глав. <!--TODO-->


### Синтаксис функций: предложения, объектные выражения, образцы, результаты

Функция в Рефале-05 может быть написана как на Рефале, так и на языке Си (при
помощи синтаксиса _нативных вставок)._ В этом разделе мы будем рассматривать
только функции, написанные на Рефале.

**Отличие от Рефала-5.** Тело функции может быть записано на языке Си, см. одну
из следующих глав. <!--TODO-->

_Тело функции_ представляет собой набор из нескольких предложений — правил
вычисления функции:

    ИмяФункции {
      предложение1;
      предложение2;
      …
      предложениеN;
    }

В конце каждого предложения пишется точка с запятой, при этом в конце последнего
предложения точку с запятой допустимо не ставить.

_Предложение_ состоит из двух частей — образца и результата, которые разделяются
знаком равенства:

    образец = результат;

_Образец_ описывает подмножество значений аргумента, для которого применимо
данное предложение, _результат_ — как должна вычисляться функция на данном
подмножестве. Образец также называют _образцовым выражением_ или _левой частью,_
результат — _результатным выражением_ или _правой частью._

Объединение множеств значений аргумента, описываемых каждым из образцов,
образует область определения функции с учётом вызовов других функций в правых
частях.

Аргумент сопоставляется с образцами сверху вниз, срабатывает правая часть
у первого образца с которым удалось _отождествить_ аргумент функции. Если
такого образца не нашлось, программа аварийно останавливается с выдачей ошибки
_«отождествление невозможно»_ (recognition impossible).

Рефал-05 допускает функции с пустым телом — когда между фигурными скобками
не записано ни одного предложения. Такие функции аварийно останавливаются
при любом аргументе. Просто потому, что нет подходящего предложения, потому что
предложений вообще нет.

**Отличие от Рефала-5.** Рефал-5 не допускает функции без предложений, Рефал-05
допускает.

На первый взгляд может показаться, что такие функции бесполезны. Но, как будет
показано ниже, такие функции в Рефале-05 на столько часто нужны, что для их
записи предусмотрен синтаксический сахар. Ключевое слово `$ENUM` определяет
пустые локальные функции с заданными именами, `$EENUM` (entry enum) —
entry-функции. Запись

    $ENUM One, Two, Three;
    $EENUM Four, Five, Six;

эквивалентна

    One { }
    Two { }
    Three { }
    $ENTRY Four { }
    $ENTRY Five { }
    $ENTRY Six { }

**Отличие от Рефала-5.** В Рефале-5 нет ни пустых функций, ни сокращённого
синтаксиса для них.

Прежде, чем описать вид образца и результата, нужно обсудить, какие данные Рефал
обрабатывает, что именно является аргументом функции.

Данные, обрабатываемые Рефалом, называются _объектными выражениями._ Объектное
выражение — это последовательность символов (неделимых элементов данных, атомов)
и _круглых скобок,_ причём круглые скобки должны быть сбалансированы.

_Символы_ делятся на три вида:

* символы-литеры — ASCII-символы: буквы, цифры, знаки препинания и арифметики,
  пробелы, переводы строк и прочие,
* символы-числа — неотрицательные числа меньше чем 2<super>N</super>, где N —
  число, зависящее от используемой платформы,
* символы-функции — имена функций из области видимости файла.

**Символы-литеры** записываются в одинарных кавычках: `'a'`, `'R'`, `'7'`,
`'+'`, `':'` и т.д. Несколько литер, записанных подряд, могут быть записаны
слитно под одними кавычками: `'O' 'n' 'e'` эквивалентно `'One'`. Допустимы
escape-последовательности

Последовательность |              Означает
-------------------|------------------------------------
      `'\n'`       | новая строка
      `'\r'`       | возврат каретки
      `'\t'`       | табуляция
      `'\''`       | одинарная кавычка
      `'\\'`       | символ обратной косой черты
     `'\xHH'`      | символ с шестнадцатеричным кодом HH

Также поддерживаются последовательности `'\"'`, `'\<'`, `'\>'`, `'\('`, `\)'`,
означающие, соответственно, `'"'`, `'<'`, `'>'`, `'('`, `')'`. Формально они
не нужны, но добавлены для совместимости с Рефалом-5.

_Символы-числа_ — целые числа в диапазоне от 0 до 2<super>N</super>−1,
величина N равна числу бит в типе `unsigned long` используемого компилятора Си.
Записываются они как последовательности десятичных цифр, причём переполнение
не проверяется — если записанное число не входит в допустимый диапазон, то оно
будет молча проинтерпретировано как остаток от деления этого числа
на 2<super>N</super>. Например, если `unsigned long` содержит 32 двоичных
разряда, число `99999999999999999999999999999999` будет проинтерпретировано
как `4294967295`, если 64 — как `9632337040368467967`.

**Отличие от Рефала-5.** В Рефале-5 символы-числа называются макроцифрами,
поскольку встроенные арифметические функции поддерживают длинную арифметику.
Ещё в Рефале-5 компилятор всё-таки контролирует переполнение.

_Символы-функции_ — это имена функций, видимых в текущем файле (т.е. функция
с этим именем должна быть определена, либо объявлена как `$EXTERN`). Функции
в Рефале-05 используются с двумя целями: собственно, как вызываемые функции,
и только как их имена.

Часто при программировании на Рефале возникает потребность выразить одно
из нескольких значений. Например, встроенная функция `ExistFile`, проверяющая
существование файла, должна вернуть некий признак истины или лжи. Можно
возвращать литеры, например, `'T'` или `'F'`, можно возвращать числа, например,
`1` или `0`, можно возвращать слова из литер: `'True'`, `'False'`.

Одиночные литеры или цифры малопонятны, строчки из литер избыточны — значение
можно передать одним знаком. В Рефале-05 для выражения таких признаков
используются имена функций, например, функция `ExistFile` возвращает функцию
`True` или `False`. Такие функции обычно не вызываются, а используются ради
их имён, поэтому их обычно определяют как пустые функции.

Функции сравниваются не по имени, а по ссылке. Это значит, что если в разных
файлах определены две одноимённые функции (обе локальные, или одна из них
entry), то они будут не равны не смотря на одинаковое имя. Например, символы
`True` и `False` определены в стандартной библиотеке `Library` (как `$EENUM`),
поэтому если пользователь определит эти же имена как `$ENUM` — новые функции
будут не равны, хоть и будут иметь то же имя.

Следовательно, чтобы не возникало недоразумений, пустые функции должны или
определяться как `$EENUM` в одной единице трансляции, а в остальных поключаться
как `$EXTERN`, или определяться как `$ENUM`, но при этом использоваться только
внутри текущей единицы трансляции.

**Отличие от Рефала-5.** В Рефале-5 нет символов-функций, есть символы-слова.
Слова могут записываться как произвольные строки символов, окружённые двойными
кавычками. Если слово удовлетворяет ограничениям на идентификатор Рефала-5
(начинается с буквы и состоит из букв, цифр, прочерков и минусов), то его
можно записывать без кавычке. Слова не являются указателями на функции, т.е.
слово `False` не требует, чтобы где-нибудь в программе была объявлена функция
`False`. Символы-слова в Рефале-5 сравниваются по их текстовому представлению.

_Круглые скобки_ не являются символами, они служат для задания структуры
объектному выражению, поэтому их также называют _структурными скобками._
Выражение, записанное в круглых скобках, образует _скобочный терм_ — объект,
в некоторых случаях интерпретируемый как единое целое.

_Термом_ объектного выражения называется либо символ, либо скобочный терм,
таким образом, можно дать альтернативное определение объектному выражению:

_Объектное выражение_ — последовательность термов.
_Терм_ — символ или выражение в круглых скобках (скобочный терм).

Теперь уже можно рассмотреть, чем являются образцовые и результатные выражения.

_Образец_ состоит из символов, круглых скобок (которые должны быть спаренными)
и переменных. Переменные имеют вид `тип.имя`, где `тип` — буква `s`, `t` или
`e`, `имя` — последовательность латинских букв, цифр, прочерков и минусов,
причём прочерки и минусы взаимозаменяемы (как и в именах функций).

**Отличие от Рефала-5:** в именах переменных символы `_` и `-` взаимозаменяемы.

Тип переменной определяет множество значений:

* s-переменные могут принимать значения произвольного символа,
* t-переменные могут принимать значение произвольного терма (символ или
  выражение в скобках),
* e-переменные могут принимать значение произвольного выражения, в том числе
  и пустого.

Таким образом, образец описывает некоторое множество объектных выражений,
которые можно построить из образца путём замены переменных на некоторые
значения соответствующего типа. При этом, если некоторая переменная входит
в образец несколько раз, все её вхождения должны заменяться на одинаковые
значения. Примеры образцов:

* `s.1 s.2 s.3` — три произвольных символа,
* `s.1 s.1 s.1` — три одинаковых символа,
* `(TkError (s.Row s.Col) e.Message) e.Tokens` — выражение, начинающееся
  со скобочного терма, содержимое самого скобочного терма начинается на имя
  функции `TkError`, за которым следует скобочный терм, содержащий два
  произвольных символа.
* `t.ErrorList (e.References) t.Unexpected e.Tail` — выражение, которое
  начинается с трёх термов, причём второй — скобочный.

Проверка на то, входит ли аргумент функции во множество объектных выражений,
описываемым образцом, осуществляется в ходе процедуры сопоставления с образцом
(pattern matching).

_Сопоставлением_ объектного выражения `E` _с образцом_ `P` (обозначается как
`E : P`) называется процедура поиска таких значений переменных из `P`, что
их подстановка обращает `P` в `E`. Если такая подстановка существует, значит
объектное выражение `E` удалось _сопоставить или отождествить с_ `P`.

Сопоставление может быть неоднозначным — могут существовать несколько
подстановок, переводящих `P` в `E`. Например, для сопоставления

    ('error') ('lexer') : (e.1 s.X e.2) (e.3 s.X e.4)

получатся следующие подстановки:

    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'l' ← e.3, 'xer' ← e.4
    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'lex' ← e.3, 'r' ← e.4
    'e' ← e.1, 'r' ← s.X, 'ror' ← e.2, 'lexe' ← e.3, ε ← e.4
    'er' ← e.1, 'r' ← s.X, 'or' ← e.2, 'lexe' ← e.3, ε ← e.4
    'erro' ← e.1, 'r' ← s.X, ε ← e.2, 'lexe' ← e.3, ε ← e.4

Здесь знаком `ε` обозначено пустое выражение.

Из всех допустимых подстановок выбирается та, где самая левая e-переменная
принимает кратчайшее (в термах) значение. Если это не разрешает неоднозначности,
рассматривается следующая e-переменная и т.д.

В примере самая левая e-переменная — это `e.1`, она принимает кратчайшее
значение (ноль термов) в первых двух подстановках:

    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'l' ← e.3, 'xer' ← e.4
    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'lex' ← e.3, 'r' ← e.4

Неоднозначность осталась. Следующая e-переменная, `e.2`, принимает
в подстановках одинаковое значение, поэтому смотрим дальше. `e.3` в первой
подстановке имеет длину 1, во второй — 3. Поэтому выбирается первая подстановка.

_Результатное выражение_ состоит символов, переменных, круглых (структурных)
скобок и _угловых скобок_ — _скобок вызова функции._ Угловые скобки часто
называются _скобками активации_ или _скобками конкретизации._ При этом круглые
и угловые скобки должны быть правильно сбалансированы — для каждой открывающей
должна быть своя закрывающая, пары круглых и угловых скобок не могут
накладываться друг на друга.

Иначе говоря — результатное выражение есть последовательность результатных
термов, а _результатный терм_ — это либо символ, либо переменная, либо
результатное выражение в круглых или угловых скобках.

**Отличие от Рефала-5.** Синтаксис Рефала-5 требует, чтобы после знака `<`
обязательно располагалось имя функции, фактически, `<ИмяФункции` рассматривается
как монолитный объект. В Рефале-05 такого требования нет, наличие имени функции
после `<` проверяется во время выполнения.

**Отличие от Рефала-5.** Рефал-5 имеет сокращённый синтаксис для вызова
встроенных функций арифметики: можно писать `<+ …>` вместо `<Add …>`, `<* …>`
вместо `<Mul …>` и т.д. Рефал-05 такой синтаксис не поддерживает.


Пример результатного выражения:

    <ParseSentence-Aux
      (e.Sentences)
      <ParsePattern t.ErrorList (e.References) e.Tokens>
    >

При этом в правой части предложения могут использоваться только те переменные,
которые есть в левой части.

Семантика результатного выражения проще, чем образцового: подстановка, найденная
при сопоставлении аргумента с образцом, применяется к правой части.

А как же вычисления? Об этом в следующем разделе.


### Рефал-машина и поле зрения

Семантика Рефала-05 описывается в терминах рефал-машины — абстрактного
исполнителя программ на Рефале. Рефал-машина имеет две области памяти: поле
программ, где хранятся определения функций, и поле зрения, хранящее текущее
состояние вычисления.

Содержимое поля программ заполняется при запуске и остаётся неизменным всё
время работы рефал-машины, поэтому его рассматривать не интересно. К тому же
в актуальной реализации оно явным образом не выделено — все определения функций
скомпилированы в машинный код и загружаются операционной системой.

В поле зрения рефал-машины хранится объектное выражение, дополненное скобками
вызова функций — так называемое _активное выражение._

Рефал-машина работает по шагам. На каждом шаге она находит _первичное активное
подвыражение_ — самую левую пару скобок активации, не содержащую внутри себя
других скобок активации.

После чего рефал-машина смотрит, что находится справа от открывающей угловой
скобки. Если там находится имя функции, т.е. первичное активное подвыражение
имеет вид `<F E>`, то функция `F` вызывается, а выражение между именем функции
и закрывающей угловой скобкой `E` передаётся ей в качестве аргумента.

Если справа от `<` имени функции не нашлось — сразу за `<` следует `>` или
там находится что-то другое — круглая скобка, число или литера — рефал-машина
останавливается с ошибкой невозможности отождествления (recognition impossible).

**Отличие от Рефала-5.** Такая ситуация в Рефале-5 невозможна, поскольку имя
вызываемой функции неотделимо от открывающей угловой скобки.

Функция при успешном выполнении заменяет первичное активное подвыражение
на некоторое новое активное выражение. Функции, написанные на Рефале заменяют
свой вызов на результатное выражение с подстановкой переменных из левой части,
как написано в предыдущем разделе. Функции, написанные на Си, формируют новое
выражение на месте своего вызова в соответствии со своим алгоритмом.

Например, встроенная функция `ExistFile` ожидает, что её аргументом будет
последовательность литер — имя файла, существование которого надо проверить.
Если аргумент — не последовательность литер, функция завершает программу
с ошибкой невозможности отождествления. Если аргумент является цепочкой
литер, то функция пытается открыть файл с этим именем для чтения. Если открыть
файл удалось, то функция его закрывает и заменяет свой вызов (первичное
активное подвыражение) на имя функции `True`, в противном случае — на `False`.

Рефал-машина продолжает выполнение программы до тех пор, пока в поле зрения
есть скобки активации. Если скобок активации нет (поле зрения пассивно),
рефал-машина останавливается.

Предположим, мы имеем программу

    CheckFiles {
      e.Files = <Map CheckFile e.Files>;
    }

    Map {
      s.Func t.Next e.Tail = <s.Func t.Next> <Map s.Func e.Tail>;

      s.Func /* пусто */ = /* пусто */;
    }

    CheckFile {
      (e.FileName) = <ExistFile e.FileName>;
    }

поле зрения имеет вид

    <CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>

и файлы `foo.txt` и `baz.ref` существуют, а `bar.lisp` — нет.

На первом шаге рефал-машина найдёт единственный вызов функции, он будет
первичным активным подвыражением:

    <CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Подходящим предложением функции `CheckFiles` будет самое первое, переменная
`e.Files` свяжется со всем аргументом функции. Первичное активное подвыражение
будет заменено на правую часть:

    <Map CheckFile ('foo.txt') ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Подходящим будет первое предложение функции `Map`, при сопотавлении аргумента
с первым образцом будет получена следующая подстановка:

    CheckFile ← s.Func, ('foo.txt') ← t.Next, ('bar.lisp') ('baz.ref') ← e.Tail

Вызов функции `Map` будет заменён на результатное выражение первого предложения:

    <CheckFile ('foo.txt')> <Map CheckFile ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^

Первичным активным подвыражением (подчёркнуто) будет вызов `CheckFile`, он
заменится на вызов `ExistFile`:

    <ExistFile 'foo.txt'> <Map CheckFile ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^

Файл существует, поэтому встроенная функция `ExistFile` будет заменена на `True`:

    True <Map CheckFile ('bar.lisp') ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Последующие шаги будут иметь вид:

    True <Map CheckFile ('bar.lisp') ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    True <CheckFile ('bar.lisp')> <Map CheckFile ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^
    True <ExistFile 'bar.lisp'> <Map CheckFile ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^
    True False <Map CheckFile ('baz.ref')>
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^

Первое предложение функции `Map` будет подходящим, будет найдена подстановка

    CheckFile ← s.Func, ('baz.ref') ← t.Next, ε ← e.Tail

Т.е. переменная `e.Tail` примет значение пустого выражения. Идём дальше:

    True False <CheckFile ('baz.ref')> <Map CheckFile>
               ^^^^^^^^^^^^^^^^^^^^^^^
    True False <ExistFile 'baz.ref'> <Map CheckFile>
               ^^^^^^^^^^^^^^^^^^^^^
    True False True <Map CheckFile>
                    ^^^^^^^^^^^^^^^

Сопоставить `CheckFile` с левой частью первого предложения невозможно, но можно
с левой частью второго предложения:

    CheckFile ← s.Func

Правая часть второго предложения пустая, поэтому вызов функции заменяется
на пустое выражение:

    True False True

Вызовов функций нет, рефал-машина корректно останавливается.

Другой пример. Имеем программу

    Map {
      s.Func t.Next e.Tail = <s.Func t.Next> <Map s.Func e.Tail>;

      s.Func /* пусто */ = /* пусто */;
    }

и выражение в поле зрения `<Map 1 2 3 4 5>`:

    <Map 1 2 3 4 5>
    ^^^^^^^^^^^^^^^

Первое предложение применимо, существует подстановка:

    1 ← s.Func, 2 ← t.Next, 3 4 5 ← e.Tail

Заменяем на правую часть:

    <1 2> <Map 1 3 4 5>
    ^^^^^

В первичном активном подвыражении после `<` находится не имя функции, а число —
рефал-машина останавливается с ошибкой невозможности отождествления.

Поле программ такое же, как в первом примере, поле зрения содержит выражение:

    <<CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>>

Рефал-машина выполнит следующие шаги:

    <<CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <<Map CheckFile ('foo.txt') ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <<CheckFile ('foo.txt')> <Map CheckFile ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^
    <<ExistFile 'foo.txt'> <Map CheckFile ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^
    <True <Map CheckFile ('bar.lisp') ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <True <CheckFile ('bar.lisp')> <Map CheckFile ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^^^
    <True <ExistFile 'bar.lisp'> <Map CheckFile ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^
    <True False <Map CheckFile ('baz.ref')>>
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <True False <CheckFile ('baz.ref')> <Map CheckFile>>
                ^^^^^^^^^^^^^^^^^^^^^^^
    <True False <ExistFile 'baz.ref'> <Map CheckFile>>
                ^^^^^^^^^^^^^^^^^^^^^
    <True False True <Map CheckFile>>
                     ^^^^^^^^^^^^^^^
    <True False True>
    ^^^^^^^^^^^^^^^^^

Рефал-машина вызывает функцию `True`, передавая ей аргументом `False True`.
Но функция `True` пустая — в ней ноль предложений. А это значит, что применимого
предложения нет. Программа останавливается с ошибкой невозможности отождествления.

Поле зрения и рефал-машина, работающая по шагам — это не просто математическая
абстракция, используемая для описания семантики. Рассматриваемая реализация
Рефала-05 действительно моделирует поле зрения в виде двусвязного списка
и действительно оно меняется по шагам — на каждом шаге обнаруживается следующий
вызов функции и эта функция вызывается. Подробнее об этом в разделе, посвящённом
интерфейсу с языком Си. <!--TODO-->


Библиотека встроенных функций
-----------------------------

Выше по тексту упоминались некие «встроенные функции» и даже приводился пример
одной из них — `ExistFile`. Любая функция, используемая в файле должна быть
описана — либо определена, либо объявлена как внешняя при помощи ключевого
слова `$EXTERN`. В Рефале-05 _встроенные функции_ — это функции, которые
компилятор неявно объявляет сам в каждой единице трансляции. Т.е. для встроенных
функций в каждом файле есть неявный невидимый `$EXTERN`, который их объявляет.

Но на деле эти функции должны быть где-то определены. В текущей реализации
они определены в библиотечном файле `Library.ref`, большинство из них написаны
на Си.

**Отличие от Рефала-5.** В Рефале-5 встроенные функции буквально встроены
в язык — жёстко зашиты в исходники компилятора и интерпретатора. Для них
действуют определённые правила — нельзя в файле объявить или определить
функцию, имя которой совпадает со встроенной, даже локальную. В Рефале-05
таких ограничений нет, встроенные функции — это просто функции, которые
неявно объявляются компилятором.

Далее мы перечислим встроенные функции в том порядке и с теми номерами,
в каком их перечисляет встроенная функция `ListOfBuiltin`.


### Нотация для записи типов функций

Для описания типов функций будем использовать следующие обозначения.

_Тип функции:_

    <ИмяФункции тип-аргумента>
      == тип-результата

Здесь `тип-аргумента` — описание области определения функции, `тип-результата` —
описание области значений. Оба типа — типы выражений

_Именованный тип:_

    переменная-типа ::= тип-выражения1 | тип-выражения2 | … | тип-выраженияN

Переменная типа записывается как обычная переменная Рефала, через вертикальную
черту перечисляются различные альтернативы.

Несколько именованных типов могут иметь одинаковое описание:

    перем1, перем2, перем3 ::= тип-выражения

_Тип выражения_ записывается как образцовое выражение, где после термов
(включая переменные) могут использоваться квантификаторы `*` (0 и более раз),
`+` (1 и более раз) и `?` (0 или 1 раз).

Переменные `s.CHAR`, `s.NUMBER` и `s.FUNCTION` описывают, соответственно,
произвольную литеру, число и функцию.

**Примеры.** Произвольное выражение, произвольный терм и произвольный символ:

    e.AnyExpr ::= t.AnyTerm*
    t.AnyTerm ::= s.AnySymbol | (e.AnyExpr)
    s.AnySymbol ::= s.CHAR | s.NUMBER | s.FUNCTION

Входная точка лексического анализатора (длинный список лексем сокращён):

    <R05-LexScan-File e.SourceName>
      == e.Tokens
    e.Tokens ::= (s.TokType t.SrcPos e.Info)
    t.SrcPos ::= (s.Row s.Col)

    s.TokType e.Info ::=
        TkChar s.CHAR
      | TkClose s.Bracket
      | TkCloseBlock
        …
      | TkError e.Message
      | TkExtern
      | TkName e.Name
      | TkNative (e.SourceName s.LineNo) (s.CHAR*)*
      | TkNumber s.NUMBER
      | TkOpen s.Bracket
      | TkOpenBlock
      | TkReplace
      | TkSemicolon
      | TkUnexpected e.BadCharacters
      | TkVariable s.Mode e.Index

    s.Bracket ::= Bracket | CallBracket
    e.Message, e.Name, e.SourceName, e.BadCharacters, e.Index ::= s.CHAR+
    s.LineNo ::= s.NUMBER
    s.Mode ::= 's' | 't' | 'e'

Входная точка синтаксического анализатора:

    <R05-Parse-File e.SourceFile>
      == Success e.Tree
      == Fails e.Errors

    e.Errors ::= ((s.Row s.Col) e.Message)*

Часть описания дерева:

    e.Tree ::= t.TreeItem*
    t.TreeItem ::=
        (Extern e.Name)
      | (Function s.Scope (e.Name) e.Body)
      | (Native e.Native)

    e.Name ::= s.CHAR+
    s.Scope ::= Entry | Local
    e.Body ::= Sentences t.Sentence* | Native e.Native
    e.Native ::= (e.SourceName s.Line) (s.CHAR*)*
    s.Line ::= s.NUMBER
    e.SourceName ::= s.CHAR+


### 1. Mu

    <Mu s.FUNCTION e.AnyExpr> == e.AnyExpr

**Семантика:** функция имеет следующую реализацию на Рефале

    $ENTRY Mu {
      s.Func e.Arg = <s.Func e.Arg>;
    }

Функция нужна для совместимости с Рефалом-5. Зачем она нужна, мы подробно
расскажем в следующем разделе.

**Совместимость с Рефалом-5** См. раздел «Совместимость с Рефалом-5 и общее
подмножество».

### 2. Add

    <Add s.NUMBER s.NUMBER> == s.NUMBER

**Семантика.** Вычисляет сумму двух чисел по модулю 2<super>N</super>, где
N — число двоичных разрядов типа `unsigned long` используемого компилятора
языка Си. Т.е. если сумма двух чисел превышает 2<super>N</super>, то результатом
этой функции будет число, образованное последними N битами.

**Совместимость с Рефалом-5.** В Рефале-5 поддерживаются длинная арифметика
и отрицательные числа. Поэтому аргументами `Add` могут быть длинные числа
со знаком. Для записи длинных чисел первый аргумент заворачивается в круглые
скобки: `<Add (e.X) e.Y>`. Рефал-05 не поддерживает скобки вокруг первого
аргумента, а также знаки и длинную арифметику.

### 3. Arg

    <Arg s.ArgNo> == e.Argument

    s.ArgNo ::= s.NUMBER
    e.Argument ::= s.CHAR*

**Семантика:** возвращает аргумент командной строки с указанным номером.
Нулевой аргумент — имя вызываемой программы. Если запрашиваемый аргумент
не существует — фактическое их число меньше, чем `s.ArgNo`, возвращается
пустая строка.

**Совместимость с Рефалом-5.** Интерпретатор Рефала-5 пропускает все аргументы,
начинающиеся на знак минус, поэтому в переносимых программах не рекомендуется
использовать ключи командной строки, начинающиеся на минус.

### 5. Card

    <Card> == s.CHAR* 0?

**Семантика.** Считывает ~~перфокарту~~ строчку со стандартного ввода. Если
встречен символ конца файла, в конец прочитанной строки добавляется число `0`.

**Совместимость с Рефалом-5.** Встроенные функции `Card` и `Get` некорректно
считывают строки, содержащие внутри себя символ с кодом нуля `\x00`, поэтому
переносимые программы не должны читать двоичные файлы.

### 6. Chr

    <Chr e.AnyExpr> == e.AnyExprChr

    e.AnyExprChr ::= t.AnyTermChr*
    t.AnyTermChr ::= s.CHAR | s.NUMBER | (e.AnyExprChr)

**Семантика:** функция заменяет в своём аргументе все числа на символы-литеры
с соответствующим ASCII-кодом (по модулю 256).

**Совместимость с Рефалом-5:** полностью совместима.

### 10. Div

    <Div s.NUMBER s.NUMBER> == s.NUMBER

**Семантика.** Выполняет целочисленное деление. Если делитель равен нулю,
программа аварийно останавливается выдачей дампа поля зрения и ошибки «деление
на ноль».

**Совместимость с Рефалом-5:** см. `Add`.

### 12. Explode

    <Explode s.FUNCTION> == s.CHAR+

**Семантика.** Для символа-функции возвращает её имя как последовательность
литер, вместо литеры `-` возвращается `_`. Пример:

    <Explode R05-Parse-File> → 'R05_Parse_File'
    <Explode findfile_AnalyzeFile-ByFolders> → 'findfile_AnalyzeFile_ByFolders'

**Совместимость с Рефалом-5.** Функция `Explode` в Рефале-5 применяется
к символам-словам, не заменяет знаки `-` на знаки `_`.

### 14. Get

    <Get s.FileNo> == s.CHAR* 0?

    s.FileNo ::= s.NUMBER

**Семантика.** Функция читает из файла с заданным номером. Номер файла
вычисляется как остаток от деления `s.FileNo` на `40`:

    file_no = s.FileNo % 40

Если величина `file_no` равна нулю, то читается стандартный ввод, т.е. вызов
`<Get 0>` (или `<Get 40>`, `<Get 80>` и т.д.) будет эквивалентен вызову
`<Card>`.

Если файл с указанным номером не был открыт при помощи функции `Open`,
то открывается файл с именем `REFAL<file_no>.DAT` в режиме «для чтения», где
вместо `<file_no>` означает запись `file_no` в десятичном виде. Например, если
файл с номером 33 не был открыт, то вызов `<Get 143>` откроет для чтения файл
`REFAL33.DAT`.

Точно также, как и функция `Card`, при достижении конца файла функция загружает
в поле зрения число `0`.

**Совместимость с Рефалом-5.** См. `Card`.

### 19. Mod

    <Mod s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет остаток от деления. При делении на нуль — см. `Div`.

**Совместимость с Рефалом-5:** см. `Add`.

### 20. Mul

    <Mul s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет произведение двух чисел по модулю 2<super>N</super>
(см. `Add`).

**Совместимость с Рефалом-5:** см. `Add`.

### 21. Numb

    <Numb s.CHAR*> == s.NUMBER

**Семантика.** Если аргумент начинается с последовательности цифр,
то возвращается число по модулю 2<super>N</super> (см. `Add`). В противном
случае возвращается `0`.

**Совместимость с Рефалом.** В Рефале-5 поддерживаются длинная арифметика
и знаки у чисел, поэтому у функции `Numb` аргумент может начинаться с `'+'`
или `'-'`, результат может содержать знак и несколько макроцифр.

### 22. Open

    <Open s.Mode s.FileNo e.FileName?> == пусто

    s.Mode ::=
        'r' | 'w' | 'a'
      |  r  |  w  |  a
      |  rb |  wb |  ab
    e.FileName ::= s.CHAR+

**Семантика.** Функция открывает файл с заданным номером в заданном режиме.
Номер файла вычисляется по формуле

    file_no = s.FileNo % 40

Если файл с номером `file_no` был открыт ранее, он закрывается. Если имя файла
не задано, то открывается файл с именем `REFAL<file_no>.DAT`, где `<file_no>` —
десятичная запись `file_no`.

Режим доступа может быть задан одной из трёх литер, либо любым именем функции.
Если режим задан функцией, то её имя напрямую передаётся во второй аргумент
`fopen` безо всякой проверки (аналогично Рефалу-5). В `Library.ref` заготовлены
пустые функции с именами `r`, `w`, `a`, `rb`, `wb`, `ab`, но пользователь можнет
создать и собственную функцию, а не экспортировать имеющиеся.

Режимы:

* `'r'`, `r` — открытие файла для чтения. Если файл не существует, программа
  аварийно останавливается с выдачей соответствующего сообщения об ошибке.
* `'w'`, `w` — открытие файла для (пере)записи — если файл существует,
  то усекается до нулевой длины, если файл не существует, то будет создан.
* `'a'`, `a` — открытие файла для дозаписи. Если файл существует, то запись
  будет осуществляться в конец, если не существует — будет создан.
* `rb`, `wb`, `ab` — двоичный ввод-вывод (зависит от платформы).

Файл с номером 39 используется в `LibraryEx` функциями `LoadFile` и `SaveFile`.

**Совместимость с Рефалом-5.** Функция полностью совместима. Рефал-5 использует
символы-слова, поэтому можно задавать режимы типа `"r+b"`, `"r,encoding=KOI8-R"`
(какие-то компиляторы такое поддерживают). В Рефале-05 такое не получится.

### 23. Ord

    <Ord e.AnyExpr> ::= AnyExprOrd

    e.AnyExprOrd ::= t.AnyTermOrd*
    t.AnyTermord ::= s.NUMBER | s.FUNCTION | (e.AnyExprOrd)

**Семантика:** заменяет в своём аргументе все литеры на их ASCII-коды.

**Совместимость с Рефалом-5:** полностью совместима.

### 25. Prout

    <Prout e.AnyExpr> == пусто

**Семантика.** Распечатывает объектное выражение. Литеры выводятся как есть,
числа выводятся в десятичном виде, для функций выводятся их имена (с заменой
`-` на `_`), структурные скобки распечатываются как `(` и `)` (при печати
неотличимы от `'('`, `')'`). После чисел и имён функций добавляется пробел,
чтобы при выводе нескольких чисел или функций подряд их образы не слипались.

**Совместимость с Рефалом-5:** полностью совместима за исключением вывода
имён функций (замены дефисов на прочерки).

### 27. Putout

    <Putout s.FileNo e.Expr> == пусто

**Семантика.** Распечатывает объектное выражение в файл с указанным номером.
Преобразование в цепочку литер осуществляет точно также, как и `Prout`. Номер
файла определяется по формуле:

    file_no = s.FileNo % 40

Если файл с номером `file_no` не открыт, то открывается файл с именем
`REFAL<file_no>.DAT`, где `<file_no>` — десятичная запись `file_no` в режиме
(пере)записи (см. `'w'` у функции `Open`).

**Совместимость с Рефалом-5:** см. `Prout`.

### 30. Sub

    <Sub s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет разность двух чисел по модулю 2<super>N</super>
(см. `Add`). Если вычитаемое (назовём его `x`) меньше уменьшаемого (`y`),
то результатом будет `x − y + 2`<super>`N`</super>.

**Совместимость с Рефалом-5:** см. `Add`. В Рефале-5 при вычитании большего
из меньшего в результате получается отрицательное число — макроцифра
с предшествующей литерой `'-'`.

### 31. Symb

    <Symb e.Sign s.Number> == e.Sign s.CHAR+
    e.Sign ::= '+' | '-' | пусто

**Семантика.** Преобразует число в его десятичную запись. Если числу
предшествовала литера `'+'` или `'-'`, та же литера будет предшествовать
и результату. Поддержка знака была добавлена для совместимости с функцией
`System`.

**Совместимость с Рефалом-5.** Рефал-5 поддерживает длинную арифметику, поэтому
в аргументе может быть указано несколько чисел-макроцифр, таким образом,
функция `Symb` Рефала-05 обрабатывает помножество области определения функции
Рефала-5.

### 33. Type

    <Type e.AnyExpr> == s.Type s.SubType e.AnyExpr

    s.Type s.SubType ::=
        'Lu' — uppercase latin letter
      | 'Ll' — lowercase latin letter
      | 'D0' — decimal digit
      | 'Wi' — identifier (function)
      | 'N0' — number
      | 'Pu' — isprint() && isupper()
      | 'Pl' — isprint() && ! isupper()
      | 'Ou' — other && isupper()
      | 'Ol' — other && ! isupper()
      | 'B0' — brackets
      | '*0' — empty expression

**Семантика:** возвращает тип первого терма аргумента. Если аргумент пустой,
возвращает `'*0'`. Остальные типы и подтипы:

* `'L'` — литера, латинская буква. `'Lu'` — заглавная, `'Ll'` — строчная.
* `'D'` — литера, десятичная цифра. Подтип всегда `'0'`.
* `'W'` — функция. Подтип всегда `'i'`.
* `'N'` — число. Подтип всегда `'0'`.
* `'P'` — литера, печатный знак. Реализация повторяет семантику Рефала-5
  `PZ Oct 29 2004`: подтип `'u'`, если функция `isupper()` вернула истину,
  `'l'` в противном случае. Для локали `"C"` функция `isupper()` возвращает
  истину только для латинских букв, значит, для любого печатного знака, значит
  подтип всегда будет `'l'`.
* `'O'` — любая другая литера. Подтип — см. замечание к `'P'`.
* `'B'` — скобочный терм. Подтип всегда `'0'`.

Работа функции зависит от установленной локали (которая по умолчанию вроде
`"C"`), если локаль изменена (конфигурацией операционной системы или нативной
вставкой), то функция будет работать иначе. Лексический анализатор полагается
на эту функцию.

**Совместимость с Рефалом-5.** В Рефале-5 тип `'W'` используется для слов, подтип
`'i'` соответствует словам в «идентификаторной форме», подтип `'q'` — словам,
записываемым «в кавычках».

### 51. GetEnv

    <GetEnv e.EnvName> == e.EnvValue
    e.EnvName, e.EnvValue ::= s.CHAR*

**Семантика:** возвращает значение переменной среды с заданным именем. Если
переменная среды не установлена, возвращает пустую строку.

**Совместимость с Рефалом-5:** полная.

### 52. System

    <System e.Command> == e.RetCode
    e.Command ::= s.CHAR*
    e.RetCode ::= '-'? s.NUMBER

**Семантика.** Выполняет команду `e.Command` при помощи функции `system()`
языка Си.

На POSIX (если установлен ключ `-DR05_POSIX` компилятора Си), если запущенный
процесс успешно завершился, возвращает код его возврата, иначе возвращает
`'-' 1`. На Windows (т.е. когда не установлен `-DR05_POSIX`) возвращает то,
что вернула `system()` как есть.

Отрицательный код возврата представляется как число с предшествующей литерой
`'-'`.

**Совместимость с Рефалом-5:** полная.

### 53. Exit

    <Exit e.RetCode>
    e.RetCode ::= '-'? s.NUMBER

**Семантика.** Завершает программу с заданным кодом возврата. Отрицательное
значение записывается как литера `'-'` с последующим числом.

**Совместимость с Рефалом-5:** полная.

### 54. Close

    <Close s.FileNo> == пусто

**Семантика.** Закрывает открытый файл с номером `s.FileNo % 40`. Если файл
с этим номером не был открыт, функция ничего не делает.

**Совместимость с Рефалом-5:** полная.

### 55. ExistFile

    <ExistFile e.FileName> == True | False
    e.FileName ::= s.CHAR*

    $EENUM True, False;

**Семантика.** Функция пытается открыть файл с указанным именем для чтения
при помощи `fopen()`. Если удаётся — закрывает открытый файл и возвращает
`True`, в противном случае возвращает `False`. Функции `True` и `False`
не являются встроенными функциями, это значит, что их нужно явно подключать
при помощи `$EXTERN`. Так сделано из соображений простоты и переносимости.

**Совместимость с Рефалом-5.** Рефал-5 действует честнее — использует средства
операционной системы, чтобы понять, существует файл или нет. А это значит,
что если файл существует, но недоступен для чтения, функции `ExistFile` Рефала-5
и Рефала-05 увидят его по-разному.

### 61. Compare

    <Compare s.NUMBER s.NUMBER> == '-' | '0' | '+'

**Семантика.** Возвращает `'-'`, если первое число меньше второго, `'0'` — если
они равны и `'+'`, если первое больше второго. Иначе говоря, возвращает знак
разности этих двух чисел.

**Совместимость с Рефалом-5.** Рефал-5 поддерживает длинную арифметику и числа
со знаком, в том числе и для функции `Compare` (см. `Add`).

### 67. ListOfBuiltin

    <ListOfBuiltin> == (s.FuncNo s.Name s.BuiltinType)+

    s.FuncNo ::= s.NUMBER
    s.Name ::= s.FUNCTION
    s.BuiltinType ::= special | regular

    $EENUM special, regular;

**Семантика.** Выводит список встроенных функций в указанном формате. Величины
`s.FuncNo` и `s.BuiltinType` в данной реализации смысла не имеют, добавлены для
совместимости с Рефалом-5. Значения `s.FuncNo` и `s.BuiltinType` текущая
реализация возвращает те же, что и Рефал-5 версии `PZ Oct 29 2004`.

Список имён, возвращаемых этой функцией, используется компилятором, чтобы неявно
предобъявлять встроенные функции.

**Совместимость с Рефалом-5.** Закономерное отличие: `s.Name` и `s.BuiltinType`
являются символами-словами, кроме того, эта функция в Рефале-5 перечисляет
гораздо больше имён. Значения `s.FuncNo` и `s.BuiltinType` относятся
ко внутренней реализации интерпретатора.


Рефал-05 и Рефал-5: общее подмножество
--------------------------------------

Рефал-05 проектировался как язык, имеющий общее подмножество с Рефалом-5, притом
это подмножество должно быть удобным для программирования (сам компилятор должен
быть написан на нём). И действительно, при наложении небольших ограничений
на стиль кодирования можно писать программы, которые одинаково работают на обоих
диалектах.

Далее под фразой «общее подмножество» мы будем подразумевать общее подмножество
Рефала-5 и Рефала-05.

Некоторые ограничения достаточно очевидны, их можно описать одной строчкой,
другие потребуют более глубокого рассмотрения — о них в следующих двух
подразделах.

Итак, как надо писать на Рефале-05, чтобы полученная программа также работала
на Рефале-5:

* Нельзя определять функции, имена которых совпадают со встроенными функциями
  Рефала-5, не реализованными в Рефале-05, например, `Print`, `First`, `Lenw`.
* Нельзя писать функции, в которых отсутствуют предложения между фигурными
  скобками.
* При выполнении арифметических действий (включая функцию `Numb`) следует
  избегать переполнения.
* Литералы чисел должны быть меньше 2³².
* Если в имени функции есть `-` или `_`, то во всех точках его использования
  (`$EXTERN`, символы-имена) оно должно писаться также, как и в определении
  (обычном или `$ENUM`/`$EENUM`). Например, если в определении функции
  используется имя `Ab-cd_ef`, то в других местах недопустимо её писать как
  `Ab_cd-ef`, `Ab-cd-ef` или `Ab_cd_ef`.
* После `<` может быть записано только имя функции, причём эта функция не может
  быть определена при помощи ключевых слов `$ENUM` или `$EENUM`. Знак `<` и имя
  функции должны быть написаны слитно (без пробельного символа или комментария
  между ними). Для косвенного вызова следует использовать встроенную функцию
  `Mu` (с некоторыми тонкими ограничениями — послеследующий подраздел).
* Функции делятся на две категории: подлежащие вызову (непосредственно — имя
  записывается после `<` или косвенно — вызываются через `Mu`) и не подлежащие
  вызову (используются ради их имён). Первые функции определяются обычным
  образом, вторые — при помощи ключевых слов `$ENUM` и `$EENUM`
  (в псевдокомментариях).
* Определения функций при помощи `$ENUM` и `$EENUM` должны записываться только
  в псевдокомментариях (подробнее в следующем подразделе).
* Для других целей псевдокомментарии использовать нельзя за исключением
  объявлений (`$EXTERN`) пустых entry-функций. Писать или нет такие объявления
  псевдокомментариями — вопрос личных предпочтений.
* Если косвенный вызов функции осуществляется из другого файла, вызываемая
  функция должна быть определена как entry (подробнее — через один подраздел).
* Нельзя использовать нативные вставки.
* Если программа читает аргументы командной строки, они не должны начинаться
  со знака `-`, поскольку они игнорируются `refgo`.

И наоборот, как нужно писать программы на Рефале-5, чтобы они работали
в Рефале-05:

* Можно использовать только те встроенные функции, которые доступны в Рефале-05.
* Длинную арфиметику и отрицательные числа использовать нельзя. Длинная
  арифметика в Рефале-05 не поддерживается вообще, числа со знаком поддерживают
  функции `Symb` и частично `Exit` и `System`. Следует избегать вычислений,
  где результат может быть отрицательным или состоять из нескольких макроцифр.
* Литеры чисел должны быть меньше 2³², если используется Рефал-5,
  скомпилированный на платформе Linux x64 или macOS — в нём макроцифры
  64-разрядные.
* Символы-слова могут записываться только в идентификаторной форме, двойными
  кавычками пользоваться нельзя.
* Нельзя определять функции или использовать символы-слова, которые различаются
  знаками `-` и `_`, поскольку в Рефале-05 они взаимозаменяемы.
* Сокращённый синтаксис (`<+ …>`) для арифметических функций использовать нельзя.
* Для любого символа-слова в текущем файле должно быть или определение функции
  с этим именем, или определение в псевдокомментарии, или объявление `$EXTERN`
  (можно в псевдокомментарии), или оно должно быть именем встроенной функции,
  доступной в Рефале-5. Дополнительные ограничения описаны в следующем
  подразделе.
* Косвенный вызов функций (через `Mu`) должен подчиняться ограничениям,
  описанным в подразделе после следующего.
* Условиями и блоками пользоваться нельзя.
* Неиспользуемая локальная функция в Рефале-05 является синтаксической ошибкой.

Вообще, при программировании на Рефале-05 рекомендуется придерживаться общего
подмножества. По двум причинам:

* Программы становятся переносимыми. Если пишется компонент, то его можно
  подключать и к программам на Рефале-5, и к программам на Рефале-05. Пример
  такого компонента — библиотека `LibraryEx`. <!--TODO-->
* В выразительных возможностях программист почти ничего не теряет, но получает
  возможность пользоваться обоими инструментами, например, встроенной отладкой
  <!--TODO--> Рефала-05 и отладчиком `reftr` Рефала-5, не говоря уже
  о возможностях Рефала-5λ.
* По субъективному мнению автора программировать на общем подмножестве
  интереснее, чем на чистом Рефале-05.

Очевидное исключение, когда не нужно писать на подмножестве — написание модулей
с нативными вставками.

### Куда поместить `$ENUM` и `$EENUM`: псевдокомментарии

Рефал-5 ключевые слова `$ENUM` и `$EENUM` не понимает. Функции, у которых между
фигурными скобками нет ни одного предложения, тоже не понимает.

Что же делать?

Не использовать символические имена вообще? Плохая идея, символические имена
упрощают понимание программы.

Для символических имён писать функции, единственное предложение которых содержит
какую-нибудь глупость? Многословно и засоряет код.

Было принято решение ввести синтаксис псевдокомментариев — особых комментариев,
которые Рефал-5 игнорирует, а Рефал-05 понимает. Тогда псевдокомментарий,
содержащий определение пустой функции Рефал-5 проигнорирует (для него это будет
обычный комментарий), а Рефал-05 поймёт как обычное определение пустой функции.

_Псевдокомментарий_ — это однострочный комментарий, в котором непосредственно
после `*` следует корректное ключевое слово (`$ENUM`, `$EENUM`, `$ENTRY` или
`$EXTERN`. Текст данного комментария обрабатывается так, как если бы звёздочки
не было и в конце строки была бы точка с запятой. Если однострочный комментарий
не начинается с корректного ключевого слова, то он игнорируется.

Например, следующие строки

    *$ENUM start, middle, end

    *$EENUM Opened, Closed, World

    *$EXTERN printf, scanf

    *$EXTERNAL WriteLn, ReadLn

    *$ENTRY Hello { = World }

    *$FROM LibraryEx
    $EXTERN Success;

Рефал-05 проинтерпретирует также, как эти строки:

     $ENUM start, middle, end;

     $EENUM Opened, Closed, World;

     $EXTERN printf, scanf;



     $ENTRY Hello { = World };


    $EXTERN Success;

Т.е. для псевдокомментариев звёздочка будет эквивалентна пустому месту
(здесь это показано пробелом в начале), обычные комментарии или комментарии
с «неключевыми» словами (`*$EXTERNAL`, `*$FROM`) будут проигнорированы.

Рефал-5 увидит в том же тексте только одну строчку:

    $EXTERN Success;

поскольку псевдокомментариев он не понимает.

Ради единообразия и простоты реализации псевдокомментарии могут начинаться
с любого допустимого ключевого слова, следовательно, в них можно прятать
`$EXTERN`’ы и даже объявления `$ENTRY`-функций. Очевидно, что если в программе
вызывается такая спрятанная функция, то она не сможет быть откомпилирована
Рефалом-5 — будет синтаксическая ошибка. Поэтому в общем подмножестве можно
использовать псевдокомментарии только для таких вещей, которые Рефал-5 видеть
не должен (`$ENUM` и `$EENUM`) или видеть ему не обязательно (`$EXTERN`’ы для
функций, которые не вызываются).

**Примечание.** Можно объявить пустую entry-функцию и без ключевого слова
`$EENUM`, вот так:

    *$ENTRY EmptyFunction {}

Программа с таким определением пустой функции будет попадать в общее
подмножество, однако, такой подход более многословный и не идиоматичный.
С точки зрения хорошего стиля так лучше не делать.

#### Для программистов на **Рефале-05** — как писать на общем подмножестве

Повторимся. Чтобы программа на Рефале-05 была корректной программой на Рефале-5:

* Пустые функции определялись только в псевдокомментариях.
* Псевдокомментарии не использовались для объявления и определения функций,
  которые вызываются из программы.

Для объявления функций, которые не вызываются и используются только ради
символических имён, можно помещать `$EXTERN` внутрь псевдокомментария — это
вопрос личных предпочтений программиста. В исходных текстах Рефала-05
псевдокомментарии для таких объявлений не использовались.

#### Для программистов на **Рефале-5** — как писать на общем подмножестве

Чтобы программа на Рефале-5 была корректной программой на Рефале-05, нужно
помнить, что каждый используемый символ-слово является именем функции, и имена
функций сравниваются не по текстовому представлению, а по ссылке.

Это значит, что если в разных файлах одно и то же имя объявлено в комментарии
`*$ENUM`, то символы, порождённые в разных файлах, в Рефале-05 будут не равны.

А имя, описанное в псевдокомментарии `*$EENUM`, находится в глобальной области
видимости — в одной программе не может быть определён символ в двух разных
комментариях `*$EENUM`.

Можно сформулировать такие правила. Для того, чтобы программа на Рефале-5
была корректной программой на Рефале-05:

* У любого имени, используемого в качестве символа-слова, в текущем файле
  должно быть или определение функции с этим именем, или это имя должно
  находиться в списке `$EXTERN`, либо в комментариях, начинающихся на `*$ENUM`,
  `*$EENUM`, `*$EXTERN`, либо это слово должно быть именем встроенной функции
  Рефала-05.
* В комментариях, начинающихся со слова `*$ENUM`, `*$EENUM` или `*$EXTERN`
  перечисляются через запятую имена допустимых символов.
* Символ не может быть описан более чем в одном комментарии `*$ENUM` или
  `*$EENUM` в данном файле.
* Символ не может быть описан более чем в одном комментарии `*$EENUM` во всей
  программе.
* Если символ описывается как `*$EENUM` в одном из файлов исходного текста,
  то во всех остальных, где он используется, либо должна экспортироваться
  функция в списке `$EXTERN`, либо имя записано в комментарии `*$EXTERN`.
* Если имя описано в комментарии `*$ENUM`, то символы с этим именем не могут
  «покидать» данного файла.

Последние два правила можно нарушать, если понимать, что `*$ENUM` и `*$EENUM` —
это определения функций, которые сравниваются не по именам, а по ссылкам.

#### А вообще — пустые функции не нужны

Рефал — функциональный язык. Рефал-05 и Рефал-5 — функциональные языки
с ограниченной поддержкой функций высшего порядка (в Рефале-5 она более
ограничена). Поддержка высшего порядка есть и в общем подмножестве, тонкостям
которого посвящён следующий подраздел.

А пустые функции — костыль, упрощающий реализацию компилятора и рантайма.

Поэтому хорошей практикой при программировании и на Рефале-05, и на общем
подмножестве (можно и на обычном Рефале-5 при желании) является использование
_непустых_ функций для символических имён.

Обычно пустые функции пишутся целыми семействами — например, если пишется
компилятор, будут группы символических имён для токенов, будут группы имён
для элементов синтаксического дерева, будут группы имён для команд
промежуточного кода (что, например, можно наблюдать в исходниках настоящего
компилятора).

И с такими группами иногда можно связать какое-либо действие «по умолчанию».
Например, каждый токен должен уметь себя выводить в текстовой форме для
вывода сообщения об ошибке. Команда промежуточного кода компилируется в кусок
целевого кода.

Поэтому если действие «по умолчанию» найти можно, то его обработку можно
поместить не в функцию, которая выбирает операцию в зависимости от символа,
а в сам символ — определив его непустой функцией. А потом его можно вызвать
при помощи функции `Mu` (но есть много тонких нюансов — см. следующий
подраздел).

Например, пусть у нас есть синтаксическое дерево такого вида

    t.Expr ::=
        (ExNumber s.Number)
      | (ExVariable e.Name)
      | (ExAdd t.Left t.Right)
      | (ExSub t.Left t.Right)
      | (ExMul t.Left t.Right)
      | (ExDiv t.Left t.Rigth)
      | (ExMinus t.Expr)

    t.Left, t.Right ::= t.Expr

И есть функция вывода этого дерева в виде арифметического выражения:

    StrFromExpr {
      (ExNumber s.Number) = <Symb s.Number>;
      (ExVariable e.Name) = e.Name;
      (ExAdd t.Left t.Right) =
         '(' <StrFromExpr t.Left> '+' <StrFromExpr t.Rigth ')';
      ...
    }

Если выбрать действием по умолчанию печать, то имена узлов дерева можно
определить как функции:

    $ENTRY ExNumber {
      s.Number = <Symb s.Number>;
    }

    $ENTRY ExVariable {
      e.Name = e.Name;
    }

    $ENTRY ExAdd {
      (s.Left e.LeftVal) (s.Right e.RightVal) =
        '(' <Mu s.Left e.LeftVal> '+' <Mu s.Right e.RightVal> ')';
    }

    ...

Теперь функции с символическими именами не пустые, а уже имеют некоторе
осмысленное тело.

В самом компиляторе Рефала-05 токены, формируемые лексическим анализатором,
умеют печатать сами себя — для любого токена вида

    (s.TokType t.SrcPos e.Info)

можно вызвать

    <Mu s.TokType e.Info>

и получить текстовую строку. Аналогично ведёт себя синтаксическое дерево —
любой его узел при вызове печатает себя в виде кода на Рефале-05. Внутри
кодогенератора для команд промежуточного языка определены функции, формирующие
код на Си этой конструкции.

#### Лирическое отступление: ООП в Рефале-05

Вообще, это подход можно развить до идиоматической реализации ООП (без
наследования). Каждый объект — скобочный терм, начинающийся с символического
имени. Функция символического имени является виртуальной таблицей — может
обрабатывать различные сообщения. Методы эти сообщения посылают.

Выглядит это так. Фигуры «Прямоугольник» (`ORect`) и «Круг» (`OCircle`) могут
распечатать себя в текстовом виде (метод `MPrint`), сдвинуться (метод `MMove`)
и ответить, содержат ли они точку с заданными координатами (метод `MHasPoint`).
Точка (`OPoint`) тоже может себя печатать и двигаться:

    ORect {
      (ORect t.LeftTop t.RightBottom) MPrint =
        'Rectangle [' <MPrint t.LeftTop> '-' <MPrint t.RightBottom> ']';

      (ORect t.LeftTop t.RightBottm) MMove t.Offset =
        (ORect <MMove t.LeftTop t.Offset> <MMove t.RightBootom t.Offset>);

      (ORect (OPoint s.Left s.Top) (OPoint s.Right s.Bottom))
      MHasPoint (OPoint s.X s.Y)
        <And <InRange s.Left s.X s.Right> <InRange s.Bottom s.Y s.Top>>;
    }

    OCircle {
      (OCircle t.Center s.Radius) MPrint =
        'Circle [center: ' <MPrint t.Center> ', radius: ' <Symb s.Radius> ']';

      (OCircle t.Center s.Radius) MMove t.Offset =
        (OCircle <MMove t.Center> s.Radius);

      (OCircle (OPoint s.CX s.CY) s.Radius) MHasPoint (OPoint s.X s.Y) =
        <InRange
          0
          <Add <Square <Dist s.CX s.X>> <Square <Dist s.CY s.Y>>>
          <Square s.Radius>
        >;
    }

    OPoint {
      (OPoint s.X s.Y) MPrint = '(' <Symb s.X> ', ' <Symb s.Y> ')';

      (OPoint s.X s.Y) MMove (OPoint s.dX s.dY) =
        (OPoint <Add s.X s.dX> <Add s.Y s.dY>);
    }

    MPrint {
      t.Object = <Send t.Object MPrint>;
    }

    MMove {
      t.Object t.Offset = <Send t.Object MMove t.Offset>;
    }

    MHasPoint {
      t.Object t.Point = <Send t.Object MHasPoint t.Offset>;
    }

    Send {
      (s.VTable e.Data) s.Method e.Args =
        <Mu s.VTable (s.VTable e.Data) s.Method e.Args>;
    }

(Функции `InRange`, `Dist` и `Square` имеют очевидную, но громоздкую реализацию,
которая для краткости не приведена.)

И кто теперь скажет, что Рефал-05 не объектно-ориентированный язык 😉?
<!--Тут подмигивающий эмодзи-->

### Косвенный вызов в Рефале-5 и Рефале-05, разная семантика `Mu`

#### Косвенный вызов в Рефале-05: вызов по указателю

В Рефале-05 всё достаточно просто: имена функций — это указатели на сами
функции, когда имя функции оказывается справа от `<` — она вызывается.

Рассмотрим пример, пусть у нас есть такие четыре файла:

Файл `go.ref`:

    *$FROM a.ref
    $EXTERN IndirectA;

    *$FROM b.ref
    $EXTERN IndirectB;

    *$FROM c.ref
    $EXTERN IndirectC;

    $ENTRY Go {
      /* пусто */ =
        <IndirectA>
        <IndirectB>
        <IndirectC>;
    }

Файл `a.ref`:

    *$FROM b.ref
    $EXTERN Call;

    $ENTRY IndirectA { = <Call Callable> }

    Callable { = <Prout 'A'> }

Файл `b.ref`:

    $ENTRY IndirectB { = <Call Callable> }

    Callable { = <Prout 'B'> }

    $ENTRY Call {
      s.Func = </*Mu*/ s.Func>;
    *             ↑——— раскомментировать для Рефала-5
    }

Файл `c.ref`:

    *$FROM b.ref
    $EXTERN Call;

    $ENTRY IndirectC { = <Call CallableC> }

    /*$ENTRY*/ CallableC { = <Prout 'C'> }
    *    ↑——— раскомментировать для Рефала-5

(О комментариях будет сказано в следующем подпараграфе.)

Программа напечатает:

    A
    B
    C

Эта программа — программа на Рефале-05, которая, однако, не является корректной
программой на Рефале-5, очевидно, из-за того, что в функции `Call` косвенный
вызов записывается без `Mu`.

Косвенный вызов в Рефале-05 ничем: ни синтаксически, ни семантически
не отличается от прямого. После открывающей угловой скобки синтаксически может
располагаться всё, что угодно, главное, чтобы при активации этой скобки там
оказался символ-функция.

Различий между именами функций, которые пишутся непосредственно после `<`
и в любых других местах ни при компиляции, ни при выполнении нет.

Символы-функции содержат указатель на код, при активации этот код просто
выполняется.

Поэтому косвенный вызов в Рефале-05 не более чем приём программирования, когда
после `<` размещается не фиксированное имя, а переменная или даже результат
вызова другой функции.

Поэтому функция `IndirectA` поместит в поле зрения указатель на функцию
`Callable` из файла `a.ref`, и именно её «косвенно» вызовет функция `Call`.
В результате будет напечатана буква `A`. Аналогично будут вызываться
`Callable` из файла `b.ref` и `CallableC` из файла `c.ref`.

Функция `Mu` в Рефале-05 определена как

    $ENTRY Mu {
       s.Func e.Arg = <s.Func e.Arg>;
    }

т.е. она просто осуществляет косвенный вызов. Запись `<s.Func …>` и `<Mu
s.Func …>` семантически идентичны, просто во втором случае требуется ещё один
шаг рефал-машины.


#### Косвенный вызов в Рефале-5: вызов по имени

Если мы попробуем откомпилировать и запустить код из предыдущего подпараграфа,
то Рефал-5 даст нам по рукам два раза. Первый раз при компиляции — потребуется
заменить синтаксически некорректный косвенный вызов в функции `Call` на функцию
`Mu`. Второй раз во время выполнения — программа вылетит при вызове `Mu`
с аргументом `CallableC`. Чтобы это исправить, нужно сделать функцию `CallableC`
entry-функцией. (Правки, которые необходимо внести, отмечены комментариями.)

Тогда программа корректно отработает и напечатает

    B
    B
    C

С добавлением `Mu` в функцию `Call` всё понятно — синтаксис Рефала-5 требует,
чтобы открывающая угловая скобка буквально _содержала_ имя функции (скобка и имя
рассматриваются как единый токен, между ними даже нельзя поставить пробел).
А вот с `CallableC` и первой строчкой `B` всё не так очевидно.

Во время загрузки программы имена функций при открывающих скобках вызова
заменяются на адреса соответствующих функций, при их активации управление
передаётся на нужный адрес.

Косвенный вызов в Рефале-5 осуществляется при помощи функции `Mu` — она первым
термом принимает имя функции, остальная часть трактуется как аргумент. Имя может
быть записано либо как символ-слово, либо как последовательность литер в круглых
скобках:

    <Mu t.FuncName e.AnyExpr> == e.AnyExpr

    t.FuncName ::= s.WORD | (s.CHAR+)

Символы-слова в Рефале-5 никаких указателей на функции (адреса кода)
не содержат, а уж цепочки литер — и подавно.

Функция `Mu` находит выполняемую функцию _по её имени,_ причём поиск
осуществляется сначала в том файле, где _записан_ вызов функции `Mu`, а потом
(если имя не найдено) — среди всех entry-функций программы.

Иначе говоря, можно считать, что в каждом файле исходной программы неявно
определена своя _локальная_ функция `Mu`, имеющая по паре предложений для каждой
функции файла, каждой внешней функции и каждой встроенной функции. Например,
для файла `b.ref` функция `Mu` имела бы такой вид:

    Mu {
      /* все функции файла */
      IndirectB e.Arg = <IndirectB e.Arg>;
      ('IndirectB') e.Arg = <IndirectB e.Arg>;

      Callable e.Arg = <Callable e.Arg>;
      ('Callable') e.Arg = <Callable e.Arg>;

      Call e.Arg = <Call e.Arg>;
      ('Call') e.Arg = <Call e.Arg>;

      /* все entry-функции */
      Go e.Arg = <Go e.Arg>;
      ('Go') e.Arg = <Go e.Arg>;

      IndirectA e.Arg = <IndirectB e.Arg>;
      ('IndirectA') e.Arg = <IndirectB e.Arg>;

      IndirectB e.Arg = <IndirectB e.Arg>;
      ('IndirectB') e.Arg = <IndirectB e.Arg>;

      IndirectC e.Arg = <IndirectB e.Arg>;
      ('IndirectC') e.Arg = <IndirectB e.Arg>;

      CallableC e.Arg = <CallableC e.Arg>;
      ('CallableC') e.Arg = <CallableC e.Arg>;

      /* все встроенные функции */
      Mu e.Arg = <Mu e.Arg>;
      ('Mu') e.Arg = <Mu e.Arg>;

      Add e.Arg = <Add e.Arg>;
      ('Add') e.Arg = <Add e.Arg>;

      Arg e.Arg = <Arg e.Arg>;
      ('Arg') e.Arg = <Arg e.Arg>;

      ...
    }

**Примечание.** Поиск среди entry-функций не документирован в учебнике Турчина,
но о нём написано [в дополнениях к учебнику][Att].

Теперь рассмотрим, что происходит в нашем примере. Функция `IndirectA` помещает
в поле зрения вызов `<Call Callable>`, где `<Call` — вызов функции `Call`
из `b.ref` (прямые вызовы разрешаются при загрузке программы), а `Callable` —
это просто символ-слово. Заметим, что к функции `Callable` из файла `a.ref`
этот символ никакого отношения не имеет.

Функция `Call` определена в файле `b.ref` и она вызывает функцию `Mu`, которая
будет осуществлять поиск в файле, где её вызов записан. Т.е. в `b.ref`. А там
уже есть своя функция с именем `Callable` — она и будет вызвана. Поэтому первой
строчкой напечатается `B`.

Абсолютно аналогично будет выполняться вызов функции `IndirectB`.

С функцией `IndirectC` интереснее — в поле зрения будет помещён `<Call
CallableC>`, который раскроется в `<Mu CallableC>`. Функция `CallableC`
не определена в файле `b.ref`, поэтому функция `Mu` будет осуществлять поиск
среди entry-функций. `CallableC` — entry-функция, поэтому она будет вызвана
и напечатает `C`. До того, как мы добавили ключевое слово `$ENTRY`, программа
падала, поскольку функция `Mu` ничего не находила.

**Примечание.** Косвенный вызов в Рефале-5 может осуществляться также функциями
`Up`, `Ev-met` и недокументированной `Residue`, имеющей короткий синтаксис
`<? …>`, но для них поиск имени осуществляется точно так же.

Благодаря тому, что функция `Mu` может вызывать любые entry-функции программы,
на Рефале-5 можно писать библиотеки функций высшего порядка. Например, можно
написать функцию `Map` такого вида:

    $ENTRY Map {
      s.Func t.Next e.Items = <Mu s.Func t.Next> <Map s.Func e.Items>;
      s.Func /* пусто */ = /* пусто */;
    }

(Функция `Map` в `LibraryEx` определена немного иначе). А чтобы `Mu` могла
находить вызываемую функцию по имени, её надо будет определять как entry:

    $EXTERN Map;

    $ENTRY Go {
      = <Map PrintLine ('One') ('Two') ('Three')>;
    }

    $ENTRY PrintLine {
      (e.Line) = <Prout e.Line>;
    }

При этом надо быть уверенным, что файл с определением `Map` сам не содержит
локальную функцию с именем `PrintLine`, поскольку в таком случае будет вызвана
не та функция.

#### Косвенный вызов в общем подмножестве

Механизмы косвенного вызова в Рефале-05 и Рефале-5 существенно различаются,
однако, для них можно найти общий знаменатель.

Очевидные синтаксические ограничения:

* В Рефале-05 для косвенного вызова нужно обязательно использовать функцию `Mu`.
* В Рефале-5 имя функции для `Mu` всегда должно передаваться символом-словом
  (а не цепочкой литер в скобках).

Тонкие семантические особенности:

* Если вызываемые функции определены в том же файле, где и их вызов при помощи
  функции `Mu`, то ничего делать не надо — программа уже находится в общем
  подмножестве.
* Если вызов функции `Mu` и косвенно вызываемая функция расположены в разных
  файлах, то вызываемая функция должна быть entry (как в примере с `PrintLine`
  выше). На Рефале-05 это ключевое слово будет избыточным, но в Рефале-5 оно
  необходимо.
* Следует помнить о том, что на Рефале-5 функция `Mu` сначала просматривает
  функции файла со своим вызовом, а уже потом — глобальное пространство
  entry-функций. А это значит, что надо остерегаться конфликта имён с обеих
  сторон: подбирать имя entry-функции таким образом, чтобы оно не было похоже
  на локальные функции модуля с косвенным вызовом и подбирать имена локальным
  функциям, чтобы избежать конфликта с возможными entry-функциями.

Да, в Рефале-5 локальные функции не такие локальные: если в файле есть вызов
`Mu`, можно извне вызвать любую из них.

Есть один важный стилевой момент. Основное предназначение ключевого слова
`$ENTRY` — отделять интерфейс модуля (набор входных точек) от его реализации,
внутренней кухни. Но в случае косвенного вызова в Рефале-5 и общем подмножестве
программист вынужден делать входными точками те функции, которые по смыслу
являются деталями реализации и в интерфейс не входят.

Как же избежать конфликта имён? В исходных текстах Рефала-05 принят такой
подход. Имена всех функций по умолчанию пишутся с большой буквы. Функций,
которые косвенно вызываются извне и должны быть entry, начинаются с префикса,
представляющего собой имя файла с маленькой буквы и прочерк. Такое странное
имя, во-первых, предотвращает возможный конфликт, если в разных файлах
потребуется определить entry-Функции с одинаковыми именами, во-вторых,
намекает, что эта entry-функция является деталью реализации и не входит
в интерфейс модуля. Пример такого имени: `generator_GenCommand`, которая
определена в файле `R05-Generator.ref`

С другой стороны — локальные функции часто являются частью алгоритма какой-то
другой entry-функции. Имена таких вспомогательных функций строятся из имени
entry-функции путём добавления либо префиксов `Sw` и `Do`, либо смысловых
суффиков вида `Функция-Подфункция` (см. [Приложение A](A-style-guide.md)).
Таким образом имена точек входа и имена вспомогательных функций заметно
различаются и тем самым минимизируется конфликт.

Подытожим. Чтобы программа на Рефале-05 была корректной программой на Рефале-5:

* косвенный вызов всегда должен осуществляться через `Mu`,
* функции, косвенно вызываемые в другом модуле, должны быть помечены ключевым
  словом entry,
* при написании нужно помнить о возможных конфликтах с локальными функциями
  в месте вызова.

Чтобы программа на Рефале-5 была корректной программой на Рефале-05:

* Имя вызываемой функции для функции `Mu` должно передаваться как символ-слово,
  а не скобочный терм с литерами.
* Символ-слово, который передаётся потом в функцию `Mu`, должен быть именем
  функции, видимой как в точке написания символа, так и в точке вызова функции
  `Mu` — причём должна быть видна одна и та же функция.

Для иллюстрации последнего правила рассмотрим следующий пример. Файл `go.ref`:

    $EXTERN CallA, CallB, Foo, Bar;

    $ENTRY Go {
      = <CallA Foo> <CallB Foo> <CallA Bar> <CallB Bar>
    }

Файл `a.ref`:

    $ENTRY CallA { s.Func = <Mu s.Func> }

    $ENTRY Foo { = <Prout 'A Foo'> }
    Bar { = <Prout 'A Bar'> }

    * В Рефале-05 неиспользуемая локальная функция является ошибкой синтаксиса
    $ENTRY A { = Bar }

Файл `b.ref`:

    $ENTRY CallB { s.Func = <Mu s.Func> }

    Foo { = <Prout 'B Foo'> }
    $ENTRY Bar { = <Prout 'B Bar'> }

    * В Рефале-05 неиспользуемая локальная функция является ошибкой синтаксиса
    $ENTRY B { = Foo }

Эта функция нарушает последнее правило, поскольку в вызове `<CallB Foo>` символ
`Foo` является именем функции `Foo` из файла `a.ref`, а в точке вызова функции
`Mu` (в теле функции `CallB`) видна локальная функция `Foo` файла `b.ref`. Та же
проблема и с вызовом `<CallA Bar>`. И действительно, не смотря на то, что эта
программа успешно компилируется и запускается обоими языками, результат выводится
разный:

    C:\…>refal05c.exe go.ref a.ref b.ref refal05rts Library
    *Compiling go.ref:
    *Compiling a.ref:
    *Compiling b.ref:
    +Linking C:\…\refal05rts.c
    *Compiling C:\…\Library.ref:
    *** Compilation successed ***

    C:\…>go.exe
    A Foo
    A Foo
    B Bar
    B Bar

    C:\…>refc go.ref a.ref b.ref
    Refal-5 Compiler. Version PZ Oct 29 2004
    Copyright: Refal Systems Inc.

    C:\…>refgo go+a+b
    A Foo
    B Foo
    A Bar
    B Bar

[Att]: ftp://ftp.botik.ru/pub/local/scp/refal5/book/attachment-to-refal-book_180214.zip
