Язык Рефал-05, его отличия от Рефала-5 и общее подмножество
===========================================================

Синтаксис Рефала-05
-------------------

Синтаксис внешне похож на классический Рефал-5 (версия `PZ Oct 29 2004`),
но с некоторыми тонкими отличиями. Программисты, знакомые с Рефалом-5, могут
пробежать глазами этот раздел, обращая лишь внимание на эти отличия (они будут
выделены **жирным** шрифтом).

Программа на Рефале-05 состоит из нескольких единиц трансляции — исходных
файлов на Рефале и на Си. Компилятор каждый исходный файл на Рефале транслирует
в файл на языке Си (сохраняя его в той же папке и с тем же именем), после
чего вызывает компилятор языка Си для сборки исполнимого файла (подробнее —
в руководстве пользователя <!--TODO-->). Каждая единица трансляции на Рефале
компилируется независимо.

Программа на Рефале записывается в свободном синтаксисе, т.е. переводы строк
являются обычными разделителями, наряду с пробелами и табуляциями. Пробельные
символы могут вставляться между любыми лексемами языка, обязательны лишь там,
где их отсутствие приведёт к склеиванию лексем (например, пара чисел `10 20`,
разделённая пробелом, склеится в одно число `1020`). Внутри цепочек литер
(см. далее) пробелы уже значимы — интерпретируются как литеры со значением
«пробел».

На месте любого пробельного символа можно записать комментарий. Комментарии
могут быть двух видов: однострочные и многострочные. Однострочные комментарии —
это строки программы, самым первым символом которой является знак `*`.
Многострочные комментарии такие же как в Си: начинаются с `/*` и заканчиваются
на `*/`. Многострочные комментарии не могут быть вложенными. Даже более того,
внутри многострочных комментариев запрещена последовательность символов `/*`
(чтобы предотвратить попытки закомментировать код, уже содержащий комментарий).

Компилятор обычно игнорирует содержимое комментариев, за исключением двух
случаев. Во-первых, как уже сказано, просматривается содержимое многострочных
комментариев — проверяется, что внутри них нет знаков `/*`. Во-вторых, есть
так называемые _псевдокомментарии,_ которые на самом деле комментариями
не являются. Но о них позже, в разделе об общем подмножестве.


### Имена функций, объявления и определения

Файл исходного текста на Рефале состоит из набора объявлений и определений
функций. Определение функции описывает саму функцию, объявление функции
говорит о том, что где-то в программе (как правило, в другой единице трансляции)
определена функция с этим именем. Объявление функции, определённой в том же
файле, совершенно бесполезно, однако, синтаксической ошибкой не является.

**Имена функций** имеют примерно тот же вид, что и в других языках
программирования: начинаются с латинской буквы и состоят из латинских букв,
цифр, знаков прочерка _и знаков минуса,_ при этом знаки минуса и прочерка
взаимозаменяемы, имена чувствительны к регистру. Примеры: `Go`, `fact`,
`R05-Generate-ToFile`, `findfile_AnalyzeFile-ByFolders`. Три разных имени
функции: `ABC`, `Abc` и `abc`, поскольку имена чувствительны к регистру.
Одно и то же имя функции: `A_b-c` и `A-b_c`, поскольку знаки `-` и `_`
взаимозаменяемы. Рефал-05 длину имён функций не ограничивает, однако,
нижележащий компилятор языка Си может рассматривать как значимые только
первые `N` символов (где величина `N` зависит от компилятора).

**Отличие от Рефала-5.** Знаки `-` и `_` в именах функций взаимозаменяемы.

Объявление функции имеет вид:

    $EXTERN Имя;

Здесь ключевое слово `$EXTERN` говорит о том, что эта функция определена где-то
ещё, после ключевого слова записывается имя функции.

Рефал-05 — динамически типизированный язык, все функции принимают и возвращают
произвольное объектное выражение (см. далее). Поэтому в объявлени ничего, кроме
имени, указывать не надо.

После ключевого слова `$EXTERN` можно указывать несколько имён функций:

    $EXTERN Имя1, Имя2, Имя3;

Это то же самое, что и

    $EXTERN Имя1;
    $EXTERN Имя2;
    $EXTERN Имя3;

**Отличие от Рефала-5.** В Рефале-5 можно использовать ключевые слова `$EXTERN`,
`$EXTRN` и `$EXTERNAL`. В Рефале-05 — только `$EXTERN`.

Определение функции в общем случае имеет вид:

    ИмяФункции {
      тело-функции
    }

или

    $ENTRY ИмяФункции {
      тело-функции
    }

Если функция определена без ключевого слова `$ENTRY`, то её область видимости
ограничена тем файлом, где она находится — _по имени_ к ней обратиться можно
только в текущем файле. Если функция определена с использованием ключевого
слова `$ENTRY`, то она находится в _глобальной области видимости_ — на неё
можно сослаться из других файлов при помощи ключевого слова `$EXTERN`. Будем
говорить об области видимости файла как о _локальной области видимости,_
функции, помеченные словом `$ENTRY` будем называть _entry-функциями,_ без этого
ключевого слова — _локальными функциями._ Entry-функции одновременно находятся
и в глобальной области видимости всей программы, и в локальной области видимости
файла, где они определены.

Теперь можно точнее сформулировать семантику ключевого слова `$EXTERN`: оно
используется для того, чтобы добавить указанные имена функций из глобальной
области видимости в локальную.

В коде на языке Си локальные функции соответствуют определениям, записанным
с использованием ключевого слова `static`, entry-функции — определениям без
ключевого слова `static`. Объявления внешних функций (но только тех, которые
используются), компилируются в `extern`’ы. Тонкости кодогенерации мы рассмотрим
в одной из следующих глав. <!--TODO-->


### Синтаксис функций: предложения, объектные выражения, образцы, результаты

Функция в Рефале-05 может быть написана как на Рефале, так и на языке Си (при
помощи синтаксиса _нативных вставок)._ В этом разделе мы будем рассматривать
только функции, написанные на Рефале.

**Отличие от Рефала-5.** Тело функции может быть записано на языке Си, см. одну
из следующих глав. <!--TODO-->

_Тело функции_ представляет собой набор из нескольких предложений — правил
вычисления функции:

    ИмяФункции {
      предложение1;
      предложение2;
      …
      предложениеN;
    }

В конце каждого предложения пишется точка с запятой, при этом в конце последнего
предложения точку с запятой допустимо не ставить.

_Предложение_ состоит из двух частей — образца и результата, которые разделяются
знаком равенства:

    образец = результат;

_Образец_ описывает подмножество значений аргумента, для которого применимо
данное предложение, _результат_ — как должна вычисляться функция на данном
подмножестве. Образец также называют _образцовым выражением_ или _левой частью,_
результат — _результатным выражением_ или _правой частью._

Объединение множеств значений аргумента, описываемых каждым из образцов,
образует область определения функции с учётом вызовов других функций в правых
частях.

Аргумент сопоставляется с образцами сверху вниз, срабатывает правая часть
у первого образца с которым удалось _отождествить_ аргумент функции. Если
такого образца не нашлось, программа аварийно останавливается с выдачей ошибки
_«отождествление невозможно»_ (recognition impossible).

Рефал-05 допускает функции с пустым телом — когда между фигурными скобками
не записано ни одного предложения. Такие функции аварийно останавливаются
при любом аргументе. Просто потому, что нет подходящего предложения, потому что
предложений вообще нет.

**Отличие от Рефала-5.** Рефал-5 не допускает функции без предложений, Рефал-05
допускает.

На первый взгляд может показаться, что такие функции бесполезны. Но, как будет
показано ниже, такие функции в Рефале-05 на столько часто нужны, что для их
записи предусмотрен синтаксический сахар. Ключевое слово `$ENUM` определяет
пустые локальные функции с заданными именами, `$EENUM` (entry enum) —
entry-функции. Запись

    $ENUM One, Two, Three;
    $EENUM Four, Five, Six;

эквивалентна

    One { }
    Two { }
    Three { }
    $ENTRY Four { }
    $ENTRY Five { }
    $ENTRY Six { }

**Отличие от Рефала-5.** В Рефале-5 нет ни пустых функций, ни сокращённого
синтаксиса для них.

Прежде, чем описать вид образца и результата, нужно обсудить, какие данные Рефал
обрабатывает, что именно является аргументом функции.

Данные, обрабатываемые Рефалом, называются _объектными выражениями._ Объектное
выражение — это последовательность символов (неделимых элементов данных, атомов)
и _круглых скобок,_ причём круглые скобки должны быть сбалансированы.

_Символы_ делятся на три вида:

* символы-литеры — ASCII-символы: буквы, цифры, знаки препинания и арифметики,
  пробелы, переводы строк и прочие,
* символы-числа — неотрицательные числа меньше чем 2<super>N</super>, где N —
  число, зависящее от используемой платформы,
* символы-функции — имена функций из области видимости файла.

**Символы-литеры** записываются в одинарных кавычках: `'a'`, `'R'`, `'7'`,
`'+'`, `':'` и т.д. Несколько литер, записанных подряд, могут быть записаны
слитно под одними кавычками: `'O' 'n' 'e'` эквивалентно `'One'`. Допустимы
escape-последовательности

Последовательность |              Означает
-------------------|------------------------------------
      `'\n'`       | новая строка
      `'\r'`       | возврат каретки
      `'\t'`       | табуляция
      `'\''`       | одинарная кавычка
      `'\\'`       | символ обратной косой черты
     `'\xHH'`      | символ с шестнадцатеричным кодом HH

Также поддерживаются последовательности `'\"'`, `'\<'`, `'\>'`, `'\('`, `\)'`,
означающие, соответственно, `'"'`, `'<'`, `'>'`, `'('`, `')'`. Формально они
не нужны, но добавлены для совместимости с Рефалом-5.

_Символы-числа_ — целые числа в диапазоне от 0 до 2<super>N</super>−1,
величина N равна числу бит в типе `unsigned long` используемого компилятора Си.
Записываются они как последовательности десятичных цифр, причём переполнение
не проверяется — если записанное число не входит в допустимый диапазон, то оно
будет молча проинтерпретировано как остаток от деления этого числа
на 2<super>N</super>. Например, если `unsigned long` содержит 32 двоичных
разряда, число `99999999999999999999999999999999` будет проинтерпретировано
как `4294967295`, если 64 — как `9632337040368467967`.

**Отличие от Рефала-5.** В Рефале-5 символы-числа называются макроцифрами,
поскольку встроенные арифметические функции поддерживают длинную арифметику.
Ещё в Рефале-5 компилятор всё-таки контролирует переполнение.

_Символы-функции_ — это имена функций, видимых в текущем файле (т.е. функция
с этим именем должна быть определена, либо объявлена как `$EXTERN`). Функции
в Рефале-05 используются с двумя целями: собственно, как вызываемые функции,
и только как их имена.

Часто при программировании на Рефале возникает потребность выразить одно
из нескольких значений. Например, встроенная функция `ExistFile`, проверяющая
существование файла, должна вернуть некий признак истины или лжи. Можно
возвращать литеры, например, `'T'` или `'F'`, можно возвращать числа, например,
`1` или `0`, можно возвращать слова из литер: `'True'`, `'False'`.

Одиночные литеры или цифры малопонятны, строчки из литер избыточны — значение
можно передать одним знаком. В Рефале-05 для выражения таких признаков
используются имена функций, например, функция `ExistFile` возвращает функцию
`True` или `False`. Такие функции обычно не вызываются, а используются ради
их имён, поэтому их обычно определяют как пустые функции.

Функции сравниваются не по имени, а по ссылке. Это значит, что если в разных
файлах определены две одноимённые функции (обе локальные, или одна из них
entry), то они будут не равны не смотря на одинаковое имя. Например, символы
`True` и `False` определены в стандартной библиотеке `Library` (как `$EENUM`),
поэтому если пользователь определит эти же имена как `$ENUM` — новые функции
будут не равны, хоть и будут иметь то же имя.

Следовательно, чтобы не возникало недоразумений, пустые функции должны или
определяться как `$EENUM` в одной единице трансляции, а в остальных поключаться
как `$EXTERN`, или определяться как `$ENUM`, но при этом использоваться только
внутри текущей единицы трансляции.

**Отличие от Рефала-5.** В Рефале-5 нет символов-функций, есть символы-слова.
Слова могут записываться как произвольные строки символов, окружённые двойными
кавычками. Если слово удовлетворяет ограничениям на идентификатор Рефала-5
(начинается с буквы и состоит из букв, цифр, прочерков и минусов), то его
можно записывать без кавычке. Слова не являются указателями на функции, т.е.
слово `False` не требует, чтобы где-нибудь в программе была объявлена функция
`False`. Символы-слова в Рефале-5 сравниваются по их текстовому представлению.

_Круглые скобки_ не являются символами, они служат для задания структуры
объектному выражению, поэтому их также называют _структурными скобками._
Выражение, записанное в круглых скобках, образует _скобочный терм_ — объект,
в некоторых случаях интерпретируемый как единое целое.

_Термом_ объектного выражения называется либо символ, либо скобочный терм,
таким образом, можно дать альтернативное определение объектному выражению:

_Объектное выражение_ — последовательность термов.
_Терм_ — символ или выражение в круглых скобках (скобочный терм).

Теперь уже можно рассмотреть, чем являются образцовые и результатные выражения.

_Образец_ состоит из символов, круглых скобок (которые должны быть спаренными)
и переменных. Переменные имеют вид `тип.имя`, где `тип` — буква `s`, `t` или
`e`, `имя` — последовательность латинских букв, цифр, прочерков и минусов,
причём прочерки и минусы взаимозаменяемы (как и в именах функций).

**Отличие от Рефала-5:** в именах переменных символы `_` и `-` взаимозаменяемы.

Тип переменной определяет множество значений:

* s-переменные могут принимать значения произвольного символа,
* t-переменные могут принимать значение произвольного терма (символ или
  выражение в скобках),
* e-переменные могут принимать значение произвольного выражения, в том числе
  и пустого.

Таким образом, образец описывает некоторое множество объектных выражений,
которые можно построить из образца путём замены переменных на некоторые
значения соответствующего типа. При этом, если некоторая переменная входит
в образец несколько раз, все её вхождения должны заменяться на одинаковые
значения. Примеры образцов:

* `s.1 s.2 s.3` — три произвольных символа,
* `s.1 s.1 s.1` — три одинаковых символа,
* `(TkError (s.Row s.Col) e.Message) e.Tokens` — выражение, начинающееся
  со скобочного терма, содержимое самого скобочного терма начинается на имя
  функции `TkError`, за которым следует скобочный терм, содержащий два
  произвольных символа.
* `t.ErrorList (e.References) t.Unexpected e.Tail` — выражение, которое
  начинается с трёх термов, причём второй — скобочный.

Проверка на то, входит ли аргумент функции во множество объектных выражений,
описываемым образцом, осуществляется в ходе процедуры сопоставления с образцом
(pattern matching).

_Сопоставлением_ объектного выражения `E` _с образцом_ `P` (обозначается как
`E : P`) называется процедура поиска таких значений переменных из `P`, что
их подстановка обращает `P` в `E`. Если такая подстановка существует, значит
объектное выражение `E` удалось _сопоставить или отождествить с_ `P`.

Сопоставление может быть неоднозначным — могут существовать несколько
подстановок, переводящих `P` в `E`. Например, для сопоставления

    ('error') ('lexer') : (e.1 s.X e.2) (e.3 s.X e.4)

получатся следующие подстановки:

    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'l' ← e.3, 'xer' ← e.4
    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'lex' ← e.3, 'r' ← e.4
    'e' ← e.1, 'r' ← s.X, 'ror' ← e.2, 'lexe' ← e.3, ε ← e.4
    'er' ← e.1, 'r' ← s.X, 'or' ← e.2, 'lexe' ← e.3, ε ← e.4
    'erro' ← e.1, 'r' ← s.X, ε ← e.2, 'lexe' ← e.3, ε ← e.4

Здесь знаком `ε` обозначено пустое выражение.

Из всех допустимых подстановок выбирается та, где самая левая e-переменная
принимает кратчайшее (в термах) значение. Если это не разрешает неоднозначности,
рассматривается следующая e-переменная и т.д.

В примере самая левая e-переменная — это `e.1`, она принимает кратчайшее
значение (ноль термов) в первых двух подстановках:

    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'l' ← e.3, 'xer' ← e.4
    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'lex' ← e.3, 'r' ← e.4

Неоднозначность осталась. Следующая e-переменная, `e.2`, принимает
в подстановках одинаковое значение, поэтому смотрим дальше. `e.3` в первой
подстановке имеет длину 1, во второй — 3. Поэтому выбирается первая подстановка.

_Результатное выражение_ состоит символов, переменных, круглых (структурных)
скобок и _угловых скобок_ — _скобок вызова функции._ Угловые скобки часто
называются _скобками активации_ или _скобками конкретизации._ При этом круглые
и угловые скобки должны быть правильно сбалансированы — для каждой открывающей
должна быть своя закрывающая, пары круглых и угловых скобок не могут
накладываться друг на друга.

Иначе говоря — результатное выражение есть последовательность результатных
термов, а _результатный терм_ — это либо символ, либо переменная, либо
результатное выражение в круглых или угловых скобках.

**Отличие от Рефала-5.** Синтаксис Рефала-5 требует, чтобы после знака `<`
обязательно располагалось имя функции, фактически, `<ИмяФункции` рассматривается
как монолитный объект. В Рефале-05 такого требования нет, наличие имени функции
после `<` проверяется во время выполнения.

**Отличие от Рефала-5.** Рефал-5 имеет сокращённый синтаксис для вызова
встроенных функций арифметики: можно писать `<+ …>` вместо `<Add …>`, `<* …>`
вместо `<Mul …>` и т.д. Рефал-05 такой синтаксис не поддерживает.


Пример результатного выражения:

    <ParseSentence-Aux
      (e.Sentences)
      <ParsePattern t.ErrorList (e.References) e.Tokens>
    >

При этом в правой части предложения могут использоваться только те переменные,
которые есть в левой части.

Семантика результатного выражения проще, чем образцового: подстановка, найденная
при сопоставлении аргумента с образцом, применяется к правой части.

А как же вычисления? Об этом в следующем разделе.


### Рефал-машина и поле зрения

Семантика Рефала-05 описывается в терминах рефал-машины — абстрактного
исполнителя программ на Рефале. Рефал-машина имеет две области памяти: поле
программ, где хранятся определения функций, и поле зрения, хранящее текущее
состояние вычисления.

Содержимое поля программ заполняется при запуске и остаётся неизменным всё
время работы рефал-машины, поэтому его рассматривать не интересно. К тому же
в актуальной реализации оно явным образом не выделено — все определения функций
скомпилированы в машинный код и загружаются операционной системой.

В поле зрения рефал-машины хранится объектное выражение, дополненное скобками
вызова функций — так называемое _активное выражение._

Рефал-машина работает по шагам. На каждом шаге она находит _первичное активное
подвыражение_ — самую левую пару скобок активации, не содержащую внутри себя
других скобок активации.

После чего рефал-машина смотрит, что находится справа от открывающей угловой
скобки. Если там находится имя функции, т.е. первичное активное подвыражение
имеет вид `<F E>`, то функция `F` вызывается, а выражение между именем функции
и закрывающей угловой скобкой `E` передаётся ей в качестве аргумента.

Если справа от `<` имени функции не нашлось — сразу за `<` следует `>` или
там находится что-то другое — круглая скобка, число или литера — рефал-машина
останавливается с ошибкой невозможности отождествления (recognition impossible).

**Отличие от Рефала-5.** Такая ситуация в Рефале-5 невозможна, поскольку имя
вызываемой функции неотделимо от открывающей угловой скобки.

Функция при успешном выполнении заменяет первичное активное подвыражение
на некоторое новое активное выражение. Функции, написанные на Рефале заменяют
свой вызов на результатное выражение с подстановкой переменных из левой части,
как написано в предыдущем разделе. Функции, написанные на Си, формируют новое
выражение на месте своего вызова в соответствии со своим алгоритмом.

Например, встроенная функция `ExistFile` ожидает, что её аргументом будет
последовательность литер — имя файла, существование которого надо проверить.
Если аргумент — не последовательность литер, функция завершает программу
с ошибкой невозможности отождествления. Если аргумент является цепочкой
литер, то функция пытается открыть файл с этим именем для чтения. Если открыть
файл удалось, то функция его закрывает и заменяет свой вызов (первичное
активное подвыражение) на имя функции `True`, в противном случае — на `False`.

Рефал-машина продолжает выполнение программы до тех пор, пока в поле зрения
есть скобки активации. Если скобок активации нет (поле зрения пассивно),
рефал-машина останавливается.

Предположим, мы имеем программу

    CheckFiles {
      e.Files = <Map CheckFile e.Files>;
    }

    Map {
      s.Func t.Next e.Tail = <s.Func t.Next> <Map s.Func e.Tail>;

      s.Func /* пусто */ = /* пусто */;
    }

    CheckFile {
      (e.FileName) = <ExistFile e.FileName>;
    }

поле зрения имеет вид

    <CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>

и файлы `foo.txt` и `baz.ref` существуют, а `bar.lisp` — нет.

На первом шаге рефал-машина найдёт единственный вызов функции, он будет
первичным активным подвыражением:

    <CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Подходящим предложением функции `CheckFiles` будет самое первое, переменная
`e.Files` свяжется со всем аргументом функции. Первичное активное подвыражение
будет заменено на правую часть:

    <Map CheckFile ('foo.txt') ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Подходящим будет первое предложение функции `Map`, при сопотавлении аргумента
с первым образцом будет получена следующая подстановка:

    CheckFile ← s.Func, ('foo.txt') ← t.Next, ('bar.lisp') ('baz.ref') ← e.Tail

Вызов функции `Map` будет заменён на результатное выражение первого предложения:

    <CheckFile ('foo.txt')> <Map CheckFile ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^

Первичным активным подвыражением (подчёркнуто) будет вызов `CheckFile`, он
заменится на вызов `ExistFile`:

    <ExistFile 'foo.txt'> <Map CheckFile ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^

Файл существует, поэтому встроенная функция `ExistFile` будет заменена на `True`:

    True <Map CheckFile ('bar.lisp') ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Последующие шаги будут иметь вид:

    True <Map CheckFile ('bar.lisp') ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    True <CheckFile ('bar.lisp')> <Map CheckFile ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^
    True <ExistFile 'bar.lisp'> <Map CheckFile ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^
    True False <Map CheckFile ('baz.ref')>
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^

Первое предложение функции `Map` будет подходящим, будет найдена подстановка

    CheckFile ← s.Func, ('baz.ref') ← t.Next, ε ← e.Tail

Т.е. переменная `e.Tail` примет значение пустого выражения. Идём дальше:

    True False <CheckFile ('baz.ref')> <Map CheckFile>
               ^^^^^^^^^^^^^^^^^^^^^^^
    True False <ExistFile 'baz.ref'> <Map CheckFile>
               ^^^^^^^^^^^^^^^^^^^^^
    True False True <Map CheckFile>
                    ^^^^^^^^^^^^^^^

Сопоставить `CheckFile` с левой частью первого предложения невозможно, но можно
с левой частью второго предложения:

    CheckFile ← s.Func

Правая часть второго предложения пустая, поэтому вызов функции заменяется
на пустое выражение:

    True False True

Вызовов функций нет, рефал-машина корректно останавливается.

Другой пример. Имеем программу

    Map {
      s.Func t.Next e.Tail = <s.Func t.Next> <Map s.Func e.Tail>;

      s.Func /* пусто */ = /* пусто */;
    }

и выражение в поле зрения `<Map 1 2 3 4 5>`:

    <Map 1 2 3 4 5>
    ^^^^^^^^^^^^^^^

Первое предложение применимо, существует подстановка:

    1 ← s.Func, 2 ← t.Next, 3 4 5 ← e.Tail

Заменяем на правую часть:

    <1 2> <Map 1 3 4 5>
    ^^^^^

В первичном активном подвыражении после `<` находится не имя функции, а число —
рефал-машина останавливается с ошибкой невозможности отождествления.

Поле программ такое же, как в первом примере, поле зрения содержит выражение:

    <<CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>>

Рефал-машина выполнит следующие шаги:

    <<CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <<Map CheckFile ('foo.txt') ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <<CheckFile ('foo.txt')> <Map CheckFile ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^
    <<ExistFile 'foo.txt'> <Map CheckFile ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^
    <True <Map CheckFile ('bar.lisp') ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <True <CheckFile ('bar.lisp')> <Map CheckFile ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^^^
    <True <ExistFile 'bar.lisp'> <Map CheckFile ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^
    <True False <Map CheckFile ('baz.ref')>>
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <True False <CheckFile ('baz.ref')> <Map CheckFile>>
                ^^^^^^^^^^^^^^^^^^^^^^^
    <True False <ExistFile 'baz.ref'> <Map CheckFile>>
                ^^^^^^^^^^^^^^^^^^^^^
    <True False True <Map CheckFile>>
                     ^^^^^^^^^^^^^^^
    <True False True>
    ^^^^^^^^^^^^^^^^^

Рефал-машина вызывает функцию `True`, передавая ей аргументом `False True`.
Но функция `True` пустая — в ней ноль предложений. А это значит, что применимого
предложения нет. Программа останавливается с ошибкой невозможности отождествления.

Поле зрения и рефал-машина, работающая по шагам — это не просто математическая
абстракция, используемая для описания семантики. Рассматриваемая реализация
Рефала-05 действительно моделирует поле зрения в виде двусвязного списка
и действительно оно меняется по шагам — на каждом шаге обнаруживается следующий
вызов функции и эта функция вызывается. Подробнее об этом в разделе, посвящённом
интерфейсу с языком Си. <!--TODO-->


Библиотека встроенных функций
-----------------------------

Выше по тексту упоминались некие «встроенные функции» и даже приводился пример
одной из них — `ExistFile`. Любая функция, используемая в файле должна быть
описана — либо определена, либо объявлена как внешняя при помощи ключевого
слова `$EXTERN`. В Рефале-05 _встроенные функции_ — это функции, которые
компилятор неявно объявляет сам в каждой единице трансляции. Т.е. для встроенных
функций в каждом файле есть неявный невидимый `$EXTERN`, который их объявляет.

Но на деле эти функции должны быть где-то определены. В текущей реализации
они определены в библиотечном файле `Library.ref`, большинство из них написаны
на Си.

**Отличие от Рефала-5.** В Рефале-5 встроенные функции буквально встроены
в язык — жёстко зашиты в исходники компилятора и интерпретатора. Для них
действуют определённые правила — нельзя в файле объявить или определить
функцию, имя которой совпадает со встроенной, даже локальную. В Рефале-05
таких ограничений нет, встроенные функции — это просто функции, которые
неявно объявляются компилятором.

Далее мы перечислим встроенные функции в том порядке и с теми номерами,
в каком их перечисляет встроенная функция `ListOfBuiltin`.


### Нотация для записи типов функций

Для описания типов функций будем использовать следующие обозначения.

_Тип функции:_

    <ИмяФункции тип-аргумента>
      == тип-результата

Здесь `тип-аргумента` — описание области определения функции, `тип-результата` —
описание области значений. Оба типа — типы выражений

_Именованный тип:_

    переменная-типа ::= тип-выражения1 | тип-выражения2 | … | тип-выраженияN

Переменная типа записывается как обычная переменная Рефала, через вертикальную
черту перечисляются различные альтернативы.

Несколько именованных типов могут иметь одинаковое описание:

    перем1, перем2, перем3 ::= тип-выражения

_Тип выражения_ записывается как образцовое выражение, где после термов
(включая переменные) могут использоваться квантификаторы `*` (0 и более раз),
`+` (1 и более раз) и `?` (0 или 1 раз).

Переменные `s.CHAR`, `s.NUMBER` и `s.FUNCTION` описывают, соответственно,
произвольную литеру, число и функцию.

**Примеры.** Произвольное выражение, произвольный терм и произвольный символ:

    e.AnyExpr ::= t.AnyTerm*
    t.AnyTerm ::= s.AnySymbol | (e.AnyExpr)
    s.AnySymbol ::= s.CHAR | s.NUMBER | s.FUNCTION

Входная точка лексического анализатора (длинный список лексем сокращён):

    <R05-LexScan-File e.SourceName>
      == e.Tokens
    e.Tokens ::= (s.TokType t.SrcPos e.Info)
    t.SrcPos ::= (s.Row s.Col)

    s.TokType e.Info ::=
        TkChar s.CHAR
      | TkClose s.Bracket
      | TkCloseBlock
        …
      | TkError e.Message
      | TkExtern
      | TkName e.Name
      | TkNative (e.SourceName s.LineNo) (s.CHAR*)*
      | TkNumber s.NUMBER
      | TkOpen s.Bracket
      | TkOpenBlock
      | TkReplace
      | TkSemicolon
      | TkUnexpected e.BadCharacters
      | TkVariable s.Mode e.Index

    s.Bracket ::= Bracket | CallBracket
    e.Message, e.Name, e.SourceName, e.BadCharacters, e.Index ::= s.CHAR+
    s.LineNo ::= s.NUMBER
    s.Mode ::= 's' | 't' | 'e'

Входная точка синтаксического анализатора:

    <R05-Parse-File e.SourceFile>
      == Success e.Tree
      == Fails e.Errors

    e.Errors ::= ((s.Row s.Col) e.Message)*

Часть описания дерева:

    e.Tree ::= t.TreeItem*
    t.TreeItem ::=
        (Extern e.Name)
      | (Function s.Scope (e.Name) e.Body)
      | (Native e.Native)

    e.Name ::= s.CHAR+
    s.Scope ::= Entry | Local
    e.Body ::= Sentences t.Sentence* | Native e.Native
    e.Native ::= (e.SourceName s.Line) (s.CHAR*)*
    s.Line ::= s.NUMBER
    e.SourceName ::= s.CHAR+


### 1. Mu

    <Mu s.FUNCTION e.AnyExpr> == e.AnyExpr

**Семантика:** функция имеет следующую реализацию на Рефале

    $ENTRY Mu {
      s.Func e.Arg = <s.Func e.Arg>;
    }

Функция нужна для совместимости с Рефалом-5. Зачем она нужна, мы подробно
расскажем в следующем разделе.

**Совместимость с Рефалом-5** См. раздел «Совместимость с Рефалом-5 и общее
подмножество».

### 2. Add

    <Add s.NUMBER s.NUMBER> == s.NUMBER

**Семантика.** Вычисляет сумму двух чисел по модулю 2<super>N</super>, где
N — число двоичных разрядов типа `unsigned long` используемого компилятора
языка Си. Т.е. если сумма двух чисел превышает 2<super>N</super>, то результатом
этой функции будет число, образованное последними N битами.

**Совместимость с Рефалом-5.** В Рефале-5 поддерживаются длинная арифметика
и отрицательные числа. Поэтому аргументами `Add` могут быть длинные числа
со знаком. Для записи длинных чисел первый аргумент заворачивается в круглые
скобки: `<Add (e.X) e.Y>`. Рефал-05 не поддерживает скобки вокруг первого
аргумента, а также знаки и длинную арифметику.

### 3. Arg

    <Arg s.ArgNo> == e.Argument

    s.ArgNo ::= s.NUMBER
    e.Argument ::= s.CHAR*

**Семантика:** возвращает аргумент командной строки с указанным номером.
Нулевой аргумент — имя вызываемой программы. Если запрашиваемый аргумент
не существует — фактическое их число меньше, чем `s.ArgNo`, возвращается
пустая строка.

**Совместимость с Рефалом-5.** Интерпретатор Рефала-5 пропускает все аргументы,
начинающиеся на знак минус, поэтому в переносимых программах не рекомендуется
использовать ключи командной строки, начинающиеся на минус.

### 5. Card

    <Card> == s.CHAR* 0?

**Семантика.** Считывает ~~перфокарту~~ строчку со стандартного ввода. Если
встречен символ конца файла, в конец прочитанной строки добавляется число `0`.

**Совместимость с Рефалом-5.** Встроенные функции `Card` и `Get` некорректно
считывают строки, содержащие внутри себя символ с кодом нуля `\x00`, поэтому
переносимые программы не должны читать двоичные файлы.

### 6. Chr

    <Chr e.AnyExpr> == e.AnyExprChr

    e.AnyExprChr ::= t.AnyTermChr*
    t.AnyTermChr ::= s.CHAR | s.NUMBER | (e.AnyExprChr)

**Семантика:** функция заменяет в своём аргументе все числа на символы-литеры
с соответствующим ASCII-кодом (по модулю 256).

**Совместимость с Рефалом-5:** полностью совместима.

### 10. Div

    <Div s.NUMBER s.NUMBER> == s.NUMBER

**Семантика.** Выполняет целочисленное деление. Если делитель равен нулю,
программа аварийно останавливается выдачей дампа поля зрения и ошибки «деление
на ноль».

**Совместимость с Рефалом-5:** см. `Add`.

### 12. Explode

    <Explode s.FUNCTION> == s.CHAR+

**Семантика.** Для символа-функции возвращает её имя как последовательность
литер, вместо литеры `-` возвращается `_`. Пример:

    <Explode R05-Parse-File> → 'R05_Parse_File'
    <Explode findfile_AnalyzeFile-ByFolders> → 'findfile_AnalyzeFile_ByFolders'

**Совместимость с Рефалом-5.** Функция `Explode` в Рефале-5 применяется
к символам-словам, не заменяет знаки `-` на знаки `_`.

### 14. Get

    <Get s.FileNo> == s.CHAR* 0?

    s.FileNo ::= s.NUMBER

**Семантика.** Функция читает из файла с заданным номером. Номер файла
вычисляется как остаток от деления `s.FileNo` на `40`:

    file_no = s.FileNo % 40

Если величина `file_no` равна нулю, то читается стандартный ввод, т.е. вызов
`<Get 0>` (или `<Get 40>`, `<Get 80>` и т.д.) будет эквивалентен вызову
`<Card>`.

Если файл с указанным номером не был открыт при помощи функции `Open`,
то открывается файл с именем `REFAL<file_no>.DAT` в режиме «для чтения», где
вместо `<file_no>` означает запись `file_no` в десятичном виде. Например, если
файл с номером 33 не был открыт, то вызов `<Get 143>` откроет для чтения файл
`REFAL33.DAT`.

Точно также, как и функция `Card`, при достижении конца файла функция загружает
в поле зрения число `0`.

**Совместимость с Рефалом-5.** См. `Card`.

### 19. Mod

    <Mod s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет остаток от деления. При делении на нуль — см. `Div`.

**Совместимость с Рефалом-5:** см. `Add`.

### 20. Mul

    <Mul s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет произведение двух чисел по модулю 2<super>N</super>
(см. `Add`).

**Совместимость с Рефалом-5:** см. `Add`.

### 21. Numb

    <Numb s.CHAR*> == s.NUMBER

**Семантика.** Если аргумент начинается с последовательности цифр,
то возвращается число по модулю 2<super>N</super> (см. `Add`). В противном
случае возвращается `0`.

**Совместимость с Рефалом.** В Рефале-5 поддерживаются длинная арифметика
и знаки у чисел, поэтому у функции `Numb` аргумент может начинаться с `'+'`
или `'-'`, результат может содержать знак и несколько макроцифр.

### 22. Open

    <Open s.Mode s.FileNo e.FileName?> == пусто

    s.Mode ::=
        'r' | 'w' | 'a'
      |  r  |  w  |  a
      |  rb |  wb |  ab
    e.FileName ::= s.CHAR+

**Семантика.** Функция открывает файл с заданным номером в заданном режиме.
Номер файла вычисляется по формуле

    file_no = s.FileNo % 40

Если файл с номером `file_no` был открыт ранее, он закрывается. Если имя файла
не задано, то открывается файл с именем `REFAL<file_no>.DAT`, где `<file_no>` —
десятичная запись `file_no`.

Режим доступа может быть задан одной из трёх литер, либо любым именем функции.
Если режим задан функцией, то её имя напрямую передаётся во второй аргумент
`fopen` безо всякой проверки (аналогично Рефалу-5). В `Library.ref` заготовлены
пустые функции с именами `r`, `w`, `a`, `rb`, `wb`, `ab`, но пользователь можнет
создать и собственную функцию, а не экспортировать имеющиеся.

Режимы:

* `'r'`, `r` — открытие файла для чтения. Если файл не существует, программа
  аварийно останавливается с выдачей соответствующего сообщения об ошибке.
* `'w'`, `w` — открытие файла для (пере)записи — если файл существует,
  то усекается до нулевой длины, если файл не существует, то будет создан.
* `'a'`, `a` — открытие файла для дозаписи. Если файл существует, то запись
  будет осуществляться в конец, если не существует — будет создан.
* `rb`, `wb`, `ab` — двоичный ввод-вывод (зависит от платформы).

Файл с номером 39 используется в `LibraryEx` функциями `LoadFile` и `SaveFile`.

**Совместимость с Рефалом-5.** Функция полностью совместима. Рефал-5 использует
символы-слова, поэтому можно задавать режимы типа `"r+b"`, `"r,encoding=KOI8-R"`
(какие-то компиляторы такое поддерживают). В Рефале-05 такое не получится.

### 23. Ord

    <Ord e.AnyExpr> ::= AnyExprOrd

    e.AnyExprOrd ::= t.AnyTermOrd*
    t.AnyTermord ::= s.NUMBER | s.FUNCTION | (e.AnyExprOrd)

**Семантика:** заменяет в своём аргументе все литеры на их ASCII-коды.

**Совместимость с Рефалом-5:** полностью совместима.

### 25. Prout

    <Prout e.AnyExpr> == пусто

**Семантика.** Распечатывает объектное выражение. Литеры выводятся как есть,
числа выводятся в десятичном виде, для функций выводятся их имена (с заменой
`-` на `_`), структурные скобки распечатываются как `(` и `)` (при печати
неотличимы от `'('`, `')'`). После чисел и имён функций добавляется пробел,
чтобы при выводе нескольких чисел или функций подряд их образы не слипались.

**Совместимость с Рефалом-5:** полностью совместима за исключением вывода
имён функций (замены дефисов на прочерки).

### 27. Putout

    <Putout s.FileNo e.Expr> == пусто

**Семантика.** Распечатывает объектное выражение в файл с указанным номером.
Преобразование в цепочку литер осуществляет точно также, как и `Prout`. Номер
файла определяется по формуле:

    file_no = s.FileNo % 40

Если файл с номером `file_no` не открыт, то открывается файл с именем
`REFAL<file_no>.DAT`, где `<file_no>` — десятичная запись `file_no` в режиме
(пере)записи (см. `'w'` у функции `Open`).

**Совместимость с Рефалом-5:** см. `Prout`.

### 30. Sub

    <Sub s.NUMBER s.NUMBER> == s.NUMBER

**Семантика:** вычисляет разность двух чисел по модулю 2<super>N</super>
(см. `Add`). Если вычитаемое (назовём его `x`) меньше уменьшаемого (`y`),
то результатом будет `x − y + 2`<super>`N`</super>.

**Совместимость с Рефалом-5:** см. `Add`. В Рефале-5 при вычитании большего
из меньшего в результате получается отрицательное число — макроцифра
с предшествующей литерой `'-'`.

### 31. Symb

    <Symb e.Sign s.Number> == e.Sign s.CHAR+
    e.Sign ::= '+' | '-' | пусто

**Семантика.** Преобразует число в его десятичную запись. Если числу
предшествовала литера `'+'` или `'-'`, та же литера будет предшествовать
и результату. Поддержка знака была добавлена для совместимости с функцией
`System`.

**Совместимость с Рефалом-5.** Рефал-5 поддерживает длинную арифметику, поэтому
в аргументе может быть указано несколько чисел-макроцифр, таким образом,
функция `Symb` Рефала-05 обрабатывает помножество области определения функции
Рефала-5.

### 33. Type

    <Type e.AnyExpr> == s.Type s.SubType e.AnyExpr

    s.Type s.SubType ::=
        'Lu' — uppercase latin letter
      | 'Ll' — lowercase latin letter
      | 'D0' — decimal digit
      | 'Wi' — identifier (function)
      | 'N0' — number
      | 'Pu' — isprint() && isupper()
      | 'Pl' — isprint() && ! isupper()
      | 'Ou' — other && isupper()
      | 'Ol' — other && ! isupper()
      | 'B0' — brackets
      | '*0' — empty expression

**Семантика:** возвращает тип первого терма аргумента. Если аргумент пустой,
возвращает `'*0'`. Остальные типы и подтипы:

* `'L'` — литера, латинская буква. `'Lu'` — заглавная, `'Ll'` — строчная.
* `'D'` — литера, десятичная цифра. Подтип всегда `'0'`.
* `'W'` — функция. Подтип всегда `'i'`.
* `'N'` — число. Подтип всегда `'0'`.
* `'P'` — литера, печатный знак. Реализация повторяет семантику Рефала-5
  `PZ Oct 29 2004`: подтип `'u'`, если функция `isupper()` вернула истину,
  `'l'` в противном случае. Для локали `"C"` функция `isupper()` возвращает
  истину только для латинских букв, значит, для любого печатного знака, значит
  подтип всегда будет `'l'`.
* `'O'` — любая другая литера. Подтип — см. замечание к `'P'`.
* `'B'` — скобочный терм. Подтип всегда `'0'`.

Работа функции зависит от установленной локали (которая по умолчанию вроде
`"C"`), если локаль изменена (конфигурацией операционной системы или нативной
вставкой), то функция будет работать иначе. Лексический анализатор полагается
на эту функцию.

**Совместимость с Рефалом-5.** В Рефале-5 тип `'W'` используется для слов, подтип
`'i'` соответствует словам в «идентификаторной форме», подтип `'q'` — словам,
записываемым «в кавычках».

### 51. GetEnv

    <GetEnv e.EnvName> == e.EnvValue
    e.EnvName, e.EnvValue ::= s.CHAR*

**Семантика:** возвращает значение переменной среды с заданным именем. Если
переменная среды не установлена, возвращает пустую строку.

**Совместимость с Рефалом-5:** полная.

### 52. System

    <System e.Command> == e.RetCode
    e.Command ::= s.CHAR*
    e.RetCode ::= '-'? s.NUMBER

**Семантика.** Выполняет команду `e.Command` при помощи функции `system()`
языка Си.

На POSIX (если установлен ключ `-DR05_POSIX` компилятора Си), если запущенный
процесс успешно завершился, возвращает код его возврата, иначе возвращает
`'-' 1`. На Windows (т.е. когда не установлен `-DR05_POSIX`) возвращает то,
что вернула `system()` как есть.

Отрицательный код возврата представляется как число с предшествующей литерой
`'-'`.

**Совместимость с Рефалом-5:** полная.

### 53. Exit

    <Exit e.RetCode>
    e.RetCode ::= '-'? s.NUMBER

**Семантика.** Завершает программу с заданным кодом возврата. Отрицательное
значение записывается как литера `'-'` с последующим числом.

**Совместимость с Рефалом-5:** полная.

### 54. Close

    <Close s.FileNo> == пусто

**Семантика.** Закрывает открытый файл с номером `s.FileNo % 40`. Если файл
с этим номером не был открыт, функция ничего не делает.

**Совместимость с Рефалом-5:** полная.

### 55. ExistFile

    <ExistFile e.FileName> == True | False
    e.FileName ::= s.CHAR*

    $EENUM True, False;

**Семантика.** Функция пытается открыть файл с указанным именем для чтения
при помощи `fopen()`. Если удаётся — закрывает открытый файл и возвращает
`True`, в противном случае возвращает `False`. Функции `True` и `False`
не являются встроенными функциями, это значит, что их нужно явно подключать
при помощи `$EXTERN`. Так сделано из соображений простоты и переносимости.

**Совместимость с Рефалом-5.** Рефал-5 действует честнее — использует средства
операционной системы, чтобы понять, существует файл или нет. А это значит,
что если файл существует, но недоступен для чтения, функции `ExistFile` Рефала-5
и Рефала-05 увидят его по-разному.

### 61. Compare

    <Compare s.NUMBER s.NUMBER> == '-' | '0' | '+'

**Семантика.** Возвращает `'-'`, если первое число меньше второго, `'0'` — если
они равны и `'+'`, если первое больше второго. Иначе говоря, возвращает знак
разности этих двух чисел.

**Совместимость с Рефалом-5.** Рефал-5 поддерживает длинную арифметику и числа
со знаком, в том числе и для функции `Compare` (см. `Add`).

### 67. ListOfBuiltin

    <ListOfBuiltin> == (s.FuncNo s.Name s.BuiltinType)+

    s.FuncNo ::= s.NUMBER
    s.Name ::= s.FUNCTION
    s.BuiltinType ::= special | regular

    $EENUM special, regular;

**Семантика.** Выводит список встроенных функций в указанном формате. Величины
`s.FuncNo` и `s.BuiltinType` в данной реализации смысла не имеют, добавлены для
совместимости с Рефалом-5. Значения `s.FuncNo` и `s.BuiltinType` текущая
реализация возвращает те же, что и Рефал-5 версии `PZ Oct 29 2004`.

Список имён, возвращаемых этой функцией, используется компилятором, чтобы неявно
предобъявлять встроенные функции.

**Совместимость с Рефалом-5.** Закономерное отличие: `s.Name` и `s.BuiltinType`
являются символами-словами, кроме того, эта функция в Рефале-5 перечисляет
гораздо больше имён. Значения `s.FuncNo` и `s.BuiltinType` относятся
ко внутренней реализации интерпретатора.


Рефал-05 и Рефал-5: общее подмножество
--------------------------------------

Рефал-05 проектировался как язык, имеющий общее подмножество с Рефалом-5, притом
это подмножество должно быть удобным для программирования (сам компилятор должен
быть написан на нём). И действительно, при наложении небольших ограничений
на стиль кодирования можно писать программы, которые одинаково работают на обоих
диалектах.

Далее под фразой «общее подмножество» мы будем подразумевать общее подмножество
Рефала-5 и Рефала-05.

Некоторые ограничения достаточно очевидны, их можно описать одной строчкой,
другие потребуют более глубокого рассмотрения — о них в следующих двух
подразделах.

Итак, как надо писать на Рефале-05, чтобы полученная программа также работала
на Рефале-5:

* Нельзя писать функции, в которых отсутствуют предложения между фигурными
  скобками.
* При выполнении арифметических действий (включая функцию `Numb`) следует
  избегать переполнения.
* Литералы чисел должны быть меньше 2³².
* Если в имени функции есть `-` или `_`, то во всех точках его использования
  (`$EXTERN`, символы-имена) оно должно писаться также, как и в определении
  (обычном или `$ENUM`/`$EENUM`). Например, если в определении функции
  используется имя `Ab-cd_ef`, то в других местах недопустимо её писать как
  `Ab_cd-ef`, `Ab-cd-ef` или `Ab_cd_ef`.
* После `<` может быть записано только имя функции, причём эта функция не может
  быть определена при помощи ключевых слов `$ENUM` или `$EENUM`. Знак `<` и имя
  функции должны быть написаны слитно (без пробельного символа или комментария
  между ними). Для косвенного вызова следует использовать встроенную функцию
  `Mu` (с некоторыми тонкими ограничениями — послеследующий подраздел).
* Функции делятся на две категории: подлежащие вызову (непосредственно — имя
  записывается после `<` или косвенно — вызываются через `Mu`) и не подлежащие
  вызову (используются ради их имён). Первые функции определяются обычным
  образом, вторые — при помощи ключевых слов `$ENUM` и `$EENUM`
  (в псевдокомментариях).
* Определения функций при помощи `$ENUM` и `$EENUM` должны записываться только
  в псевдокомментариях (подробнее в следующем подразделе).
* Для других целей псевдокомментарии использовать нельзя за исключением
  объявлений (`$EXTERN`) пустых entry-функций. Писать или нет такие объявления
  псевдокомментариями — вопрос личных предпочтений.
* Если косвенный вызов функции осуществляется из другого файла, вызываемая
  функция должна быть определена как entry (подробнее — через один подраздел).
* Нельзя использовать нативные вставки.

И наоборот, как нужно писать программы на Рефале-5, чтобы они работали
в Рефале-05:

* Можно использовать только те встроенные функции, которые доступны в Рефале-05.
* Длинную арфиметику и отрицательные числа использовать нельзя. Длинная
  арифметика в Рефале-05 не поддерживается вообще, числа со знаком поддерживают
  функции `Symb` и частично `Exit` и `System`. Следует избегать вычислений,
  где результат может быть отрицательным или состоять из нескольких макроцифр.
* Литеры чисел должны быть меньше 2³², если используется Рефал-5, скомпилированный
  на платформе Linux x64 или macOS — в нём макроцифры 64-разрядные.
* Символы-слова могут записываться только в идентификаторной форме, двойными
  кавычками пользоваться нельзя.
* Нельзя определять функции или использовать символы-слова, которые различаются
  знаками `-` и `_`, поскольку в Рефале-05 они взаимозаменяемы.
* Сокращённый синтаксис (`<+ …>`) для арифметических функций использовать нельзя.
* Для любого символа-слова в текущем файле должно быть или определение функции
  с этим именем, или определение в псевдокомментарии, или объявление `$EXTERN`
  (можно в псевдокомментарии). Дополнительные ограничения описаны в следующем
  разделе.
* Косвенный вызов функций (через `Mu`) должен подчиняться ограничениям, описанным
  в разделе после следующего.
* Условиями и блоками пользоваться нельзя.

Вообще, при программировании на Рефале-05 рекомендуется придерживаться общего
подмножества. По двум причинам:

* Программы становятся переносимыми. Если пишется компонент, то его можно
  подключать и к программам на Рефале-5, и к программам на Рефале-05. Пример
  такого компонента — библиотека `LibraryEx`. <!--TODO-->
* В выразительных возможностях программист почти ничего не теряет, но получает
  возможность пользоваться обоими инструментами, например, встроенной отладкой
  <!--TODO--> Рефала-05 и отладчиком `reftr` Рефала-5, не говоря уже
  о возможностях Рефала-5λ.

Очевидное исключение, когда не нужно писать на подмножестве — написание модулей
с нативными вставками.

### Куда поместить `$ENUM` и `$EENUM`: псевдокомментарии

### Косвенный вызов в Рефале-5 и Рефале-05, разная семантика `Mu`
