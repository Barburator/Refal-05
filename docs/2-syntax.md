Язык Рефал-05, его отличия от Рефала-5 и общее подмножество
===========================================================

Синтаксис Рефала-05
-------------------

Синтаксис внешне похож на классический Рефал-5 (версия `PZ Oct 29 2004`),
но с некоторыми тонкими отличиями. Программисты, знакомые с Рефалом-5, могут
пробежать глазами этот раздел, обращая лишь внимание на эти отличия (они будут
выделены **жирным** шрифтом).

Программа на Рефале-05 состоит из нескольких единиц трансляции — исходных
файлов на Рефале и на Си. Компилятор каждый исходный файл на Рефале транслирует
в файл на языке Си (сохраняя его в той же папке и с тем же именем), после
чего вызывает компилятор языка Си для сборки исполнимого файла (подробнее —
в руководстве пользователя <!--TODO-->). Каждая единица трансляции на Рефале
компилируется независимо.

Программа на Рефале записывается в свободном синтаксисе, т.е. переводы строк
являются обычными разделителями, наряду с пробелами и табуляциями. Пробельные
символы могут вставляться между любыми лексемами языка, обязательны лишь там,
где их отсутствие приведёт к склеиванию лексем (например, пара чисел `10 20`,
разделённая пробелом, склеится в одно число `1020`). Внутри цепочек литер
(см. далее) пробелы уже значимы — интерпретируются как литеры со значением
«пробел».

На месте любого пробельного символа можно записать комментарий. Комментарии
могут быть двух видов: однострочные и многострочные. Однострочные комментарии —
это строки программы, самым первым символом которой является знак `*`.
Многострочные комментарии такие же как в Си: начинаются с `/*` и заканчиваются
на `*/`. Многострочные комментарии не могут быть вложенными. Даже более того,
внутри многострочных комментариев запрещена последовательность символов `/*`
(чтобы предотвратить попытки закомментировать код, уже содержащий комментарий).

Компилятор обычно игнорирует содержимое комментариев, за исключением двух
случаев. Во-первых, как уже сказано, просматривается содержимое многострочных
комментариев — проверяется, что внутри них нет знаков `/*`. Во-вторых, есть
так называемые _псевдокомментарии,_ которые на самом деле комментариями
не являются. Но о них позже.


### Имена функций, объявления и определения

Файл исходного текста на Рефале состоит из набора объявлений и определений
функций. Определение функции описывает саму функцию, объявление функции
говорит о том, что где-то в программе (как правило, в другой единице трансляции)
определена функция с этим именем. Объявление функции, определённой в том же
файле, совершенно бесполезно, однако, синтаксической ошибкой не является.

**Имена функций** имеют примерно тот же вид, что и в других языках
программирования: начинаются с латинской буквы и состоят из латинских букв,
цифр, знаков прочерка _и знаков минуса,_ при этом знаки минуса и прочерка
взаимозаменяемы, имена чувствительны к регистру. Примеры: `Go`, `fact`,
`R05-Generate-ToFile`, `findfile_AnalyzeFile-ByFolders`. Три разных имени
функции: `ABC`, `Abc` и `abc`, поскольку имена чувствительны к регистру.
Одно и то же имя функции: `A_b-c` и `A-b_c`, поскольку знаки `-` и `_`
взаимозаменяемы. Рефал-05 длину имён функций не ограничивает, однако,
нижележащий компилятор языка Си может рассматривать как значимые только
первые `N` символов (где величина `N` зависит от компилятора).

**Отличие от Рефала-5.** Знаки `-` и `_` в именах функций взаимозаменяемы.

Объявление функции имеет вид:

    $EXTERN Имя;

Здесь ключевое слово `$EXTERN` говорит о том, что эта функция определена где-то
ещё, после ключевого слова записывается имя функции.

Рефал-05 — динамически типизированный язык, все функции принимают и возвращают
произвольное объектное выражение (см. далее). Поэтому в объявлени ничего, кроме
имени, указывать не надо.

После ключевого слова `$EXTERN` можно указывать несколько имён функций:

    $EXTERN Имя1, Имя2, Имя3;

Это то же самое, что и

    $EXTERN Имя1;
    $EXTERN Имя2;
    $EXTERN Имя3;

**Отличие от Рефала-5.** В Рефале-5 можно использовать ключевые слова `$EXTERN`,
`$EXTRN` и `$EXTERNAL`. В Рефале-05 — только `$EXTERN`.

Определение функции в общем случае имеет вид:

    ИмяФункции {
      тело-функции
    }

или

    $ENTRY ИмяФункции {
      тело-функции
    }

Если функция определена без ключевого слова `$ENTRY`, то её область видимости
ограничена тем файлом, где она находится — _по имени_ к ней обратиться можно
только в текущем файле. Если функция определена с использованием ключевого
слова `$ENTRY`, то она находится в _глобальной области видимости_ — на неё
можно сослаться из других файлов при помощи ключевого слова `$EXTERN`. Будем
говорить об области видимости файла как о _локальной области видимости,_
функции, помеченные словом `$ENTRY` будем называть _entry-функциями,_ без этого
ключевого слова — _локальными функциями._ Entry-функции одновременно находятся
и в глобальной области видимости всей программы, и в локальной области видимости
файла, где они определены.

Теперь можно точнее сформулировать семантику ключевого слова `$EXTERN`: оно
используется для того, чтобы добавить указанные имена функций из глобальной
области видимости в локальную.

В коде на языке Си локальные функции соответствуют определениям, записанным
с использованием ключевого слова `static`, entry-функции — определениям без
ключевого слова `static`. Объявления внешних функций (но только тех, которые
используются), компилируются в `extern`’ы. Тонкости кодогенерации мы рассмотрим
в одной из следующих глав. <!--TODO-->


### Синтаксис функций: предложения, объектные выражения, образцы, результаты

Функция в Рефале-05 может быть написана как на Рефале, так и на языке Си (при
помощи синтаксиса _нативных вставок)._ В этом разделе мы будем рассматривать
только функции, написанные на Рефале.

**Отличие от Рефала-5.** Тело функции может быть записано на языке Си, см. одну
из следующих глав. <!--TODO-->

_Тело функции_ представляет собой набор из нескольких предложений — правил
вычисления функции:

    ИмяФункции {
      предложение1;
      предложение2;
      …
      предложениеN;
    }

В конце каждого предложения пишется точка с запятой, при этом в конце последнего
предложения точку с запятой допустимо не ставить.

_Предложение_ состоит из двух частей — образца и результата, которые разделяются
знаком равенства:

    образец = результат;

_Образец_ описывает подмножество значений аргумента, для которого применимо
данное предложение, _результат_ — как должна вычисляться функция на данном
подмножестве. Образец также называют _образцовым выражением_ или _левой частью,_
результат — _результатным выражением_ или _правой частью._

Объединение множеств значений аргумента, описываемых каждым из образцов,
образует область определения функции с учётом вызовов других функций в правых
частях.

Аргумент сопоставляется с образцами сверху вниз, срабатывает правая часть
у первого образца с которым удалось _отождествить_ аргумент функции. Если
такого образца не нашлось, программа аварийно останавливается с выдачей ошибки
_«отождествление невозможно»_ (recognition impossible).

Рефал-05 допускает функции с пустым телом — когда между фигурными скобками
не записано ни одного предложения. Такие функции аварийно останавливаются
при любом аргументе. Просто потому, что нет подходящего предложения, потому что
предложений вообще нет.

**Отличие от Рефала-5.** Рефал-5 не допускает функции без предложений, Рефал-05
допускает.

На первый взгляд может показаться, что такие функции бесполезны. Но, как будет
показано ниже, такие функции в Рефале-05 на столько часто нужны, что для их
записи предусмотрен синтаксический сахар. Ключевое слово `$ENUM` определяет
пустые локальные функции с заданными именами, `$EENUM` (entry enum) —
entry-функции. Запись

    $ENUM One, Two, Three;
    $EENUM Four, Five, Six;

эквивалентна

    One { }
    Two { }
    Three { }
    $ENTRY Four { }
    $ENTRY Five { }
    $ENTRY Six { }

**Отличие от Рефала-5.** В Рефале-5 нет ни пустых функций, ни сокращённого
синтаксиса для них.

Прежде, чем описать вид образца и результата, нужно обсудить, какие данные Рефал
обрабатывает, что именно является аргументом функции.

Данные, обрабатываемые Рефалом, называются _объектными выражениями._ Объектное
выражение — это последовательность символов (неделимых элементов данных, атомов)
и _круглых скобок,_ причём круглые скобки должны быть сбалансированы.

_Символы_ делятся на три вида:

* символы-литеры — ASCII-символы: буквы, цифры, знаки препинания и арифметики,
  пробелы, переводы строк и прочие,
* символы-числа — неотрицательные числа меньше чем 2<super>N</super>, где N —
  число, зависящее от используемой платформы,
* символы-функции — имена функций из области видимости файла.

**Символы-литеры** записываются в одинарных кавычках: `'a'`, `'R'`, `'7'`,
`'+'`, `':'` и т.д. Несколько литер, записанных подряд, могут быть записаны
слитно под одними кавычками: `'O' 'n' 'e'` эквивалентно `'One'`. Допустимы
escape-последовательности

Последовательность |              Означает
-------------------|------------------------------------
      `'\n'`       | новая строка
      `'\r'`       | возврат каретки
      `'\t'`       | табуляция
      `'\''`       | одинарная кавычка
      `'\\'`       | символ обратной косой черты
     `'\xHH'`      | символ с шестнадцатеричным кодом HH

Также поддерживаются последовательности `'\"'`, `'\<'`, `'\>'`, `'\('`, `\)'`,
означающие, соответственно, `'"'`, `'<'`, `'>'`, `'('`, `')'`. Формально они
не нужны, но добавлены для совместимости с Рефалом-5.

_Символы-числа_ — целые числа в диапазоне от 0 до 2<super>N</super>−1,
величина N равна числу бит в типе `unsigned long` используемого компилятора Си.
Записываются они как последовательности десятичных цифр, причём переполнение
не проверяется — если записанное число не входит в допустимый диапазон, то оно
будет молча проинтерпретировано как остаток от деления этого числа
на 2<super>N</super>. Например, если `unsigned long` содержит 32 двоичных
разряда, число `99999999999999999999999999999999` будет проинтерпретировано
как `4294967295`, если 64 — как `9632337040368467967`.

**Отличие от Рефала-5.** В Рефале-5 символы-числа называются макроцифрами,
поскольку встроенные арифметические функции поддерживают длинную арифметику.
Ещё в Рефале-5 компилятор всё-таки контролирует переполнение.

_Символы-функции_ — это имена функций, видимых в текущем файле (т.е. функция
с этим именем должна быть определена, либо объявлена как `$EXTERN`). Функции
в Рефале-05 используются с двумя целями: собственно, как вызываемые функции,
и только как их имена.

Часто при программировании на Рефале возникает потребность выразить одно
из нескольких значений. Например, встроенная функция `ExistFile`, проверяющая
существование файла, должна вернуть некий признак истины или лжи. Можно
возвращать литеры, например, `'T'` или `'F'`, можно возвращать числа, например,
`1` или `0`, можно возвращать слова из литер: `'True'`, `'False'`.

Одиночные литеры или цифры малопонятны, строчки из литер избыточны — значение
можно передать одним знаком. В Рефале-05 для выражения таких признаков
используются имена функций, например, функция `ExistFile` возвращает функцию
`True` или `False`. Такие функции обычно не вызываются, а используются ради
их имён, поэтому их обычно определяют как пустые функции.

Функции сравниваются не по имени, а по ссылке. Это значит, что если в разных
файлах определены две одноимённые функции (обе локальные, или одна из них
entry), то они будут не равны не смотря на одинаковое имя. Например, символы
`True` и `False` определены в стандартной библиотеке `Library` (как `$EENUM`),
поэтому если пользователь определит эти же имена как `$ENUM` — новые функции
будут не равны, хоть и будут иметь то же имя.

Следовательно, чтобы не возникало недоразумений, пустые функции должны или
определяться как `$EENUM` в одной единице трансляции, а в остальных поключаться
как `$EXTERN`, или определяться как `$ENUM`, но при этом использоваться только
внутри текущей единицы трансляции.

**Отличие от Рефала-5.** В Рефале-5 нет символов-функций, есть символы-слова.
Слова могут записываться как произвольные строки символов, окружённые двойными
кавычками. Если слово удовлетворяет ограничениям на идентификатор Рефала-5
(начинается с буквы и состоит из букв, цифр, прочерков и минусов), то его
можно записывать без кавычке. Слова не являются указателями на функции, т.е.
слово `False` не требует, чтобы где-нибудь в программе была объявлена функция
`False`. Символы-слова в Рефале-5 сравниваются по их текстовому представлению.

_Круглые скобки_ не являются символами, они служат для задания структуры
объектному выражению, поэтому их также называют _структурными скобками._
Выражение, записанное в круглых скобках, образует _скобочный терм_ — объект,
в некоторых случаях интерпретируемый как единое целое.

_Термом_ объектного выражения называется либо символ, либо скобочный терм,
таким образом, можно дать альтернативное определение объектному выражению:

_Объектное выражение_ — последовательность термов.
_Терм_ — символ или выражение в круглых скобках (скобочный терм).

Теперь уже можно рассмотреть, чем являются образцовые и результатные выражения.

_Образец_ состоит из символов, круглых скобок (которые должны быть спаренными)
и переменных. Переменные имеют вид `тип.имя`, где `тип` — буква `s`, `t` или
`e`, `имя` — последовательность латинских букв, цифр, прочерков и минусов,
причём прочерки и минусы взаимозаменяемы (как и в именах функций).

**Отличие от Рефала-5:** в именах переменных символы `_` и `-` взаимозаменяемы.

Тип переменной определяет множество значений:

* s-переменные могут принимать значения произвольного символа,
* t-переменные могут принимать значение произвольного терма (символ или
  выражение в скобках),
* e-переменные могут принимать значение произвольного выражения, в том числе
  и пустого.

Таким образом, образец описывает некоторое множество объектных выражений,
которые можно построить из образца путём замены переменных на некоторые
значения соответствующего типа. При этом, если некоторая переменная входит
в образец несколько раз, все её вхождения должны заменяться на одинаковые
значения. Примеры образцов:

* `s.1 s.2 s.3` — три произвольных символа,
* `s.1 s.1 s.1` — три одинаковых символа,
* `(TkError (s.Row s.Col) e.Message) e.Tokens` — выражение, начинающееся
  со скобочного терма, содержимое самого скобочного терма начинается на имя
  функции `TkError`, за которым следует скобочный терм, содержащий два
  произвольных символа.
* `t.ErrorList (e.References) t.Unexpected e.Tail` — выражение, которое
  начинается с трёх термов, причём второй — скобочный.

Проверка на то, входит ли аргумент функции во множество объектных выражений,
описываемым образцом, осуществляется в ходе процедуры сопоставления с образцом
(pattern matching).

_Сопоставлением_ объектного выражения `E` _с образцом_ `P` (обозначается как
`E : P`) называется процедура поиска таких значений переменных из `P`, что
их подстановка обращает `P` в `E`. Если такая подстановка существует, значит
объектное выражение `E` удалось _сопоставить или отождествить с_ `P`.

Сопоставление может быть неоднозначным — могут существовать несколько
подстановок, переводящих `P` в `E`. Например, для сопоставления

    ('error') ('lexer') : (e.1 s.X e.2) (e.3 s.X e.4)

получатся следующие подстановки:

    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'l' ← e.3, 'xer' ← e.4
    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'lex' ← e.3, 'r' ← e.4
    'e' ← e.1, 'r' ← s.X, 'ror' ← e.2, 'lexe' ← e.3, ε ← e.4
    'er' ← e.1, 'r' ← s.X, 'or' ← e.2, 'lexe' ← e.3, ε ← e.4
    'erro' ← e.1, 'r' ← s.X, ε ← e.2, 'lexe' ← e.3, ε ← e.4

Здесь знаком `ε` обозначено пустое выражение.

Из всех допустимых подстановок выбирается та, где самая левая e-переменная
принимает кратчайшее (в термах) значение. Если это не разрешает неоднозначности,
рассматривается следующая e-переменная и т.д.

В примере самая левая e-переменная — это `e.1`, она принимает кратчайшее
значение (ноль термов) в первых двух подстановках:

    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'l' ← e.3, 'xer' ← e.4
    ε ← e.1, 'e' ← s.X, 'rror' ← e.2, 'lex' ← e.3, 'r' ← e.4

Неоднозначность осталась. Следующая e-переменная, `e.2`, принимает
в подстановках одинаковое значение, поэтому смотрим дальше. `e.3` в первой
подстановке имеет длину 1, во второй — 3. Поэтому выбирается первая подстановка.

_Результатное выражение_ состоит символов, переменных, круглых (структурных)
скобок и _угловых скобок_ — _скобок вызова функции._ Угловые скобки часто
называются _скобками активации_ или _скобками конкретизации._ При этом круглые
и угловые скобки должны быть правильно сбалансированы — для каждой открывающей
должна быть своя закрывающая, пары круглых и угловых скобок не могут
накладываться друг на друга.

Иначе говоря — результатное выражение есть последовательность результатных
термов, а _результатный терм_ — это либо символ, либо переменная, либо
результатное выражение в круглых или угловых скобках.

**Отличие от Рефала-5.** Синтаксис Рефала-5 требует, чтобы после знака `<`
обязательно располагалось имя функции, фактически, `<ИмяФункции` рассматривается
как монолитный объект. В Рефале-05 такого требования нет, наличие имени функции
после `<` проверяется во время выполнения.

**Отличие от Рефала-5.** Рефал-5 имеет сокращённый синтаксис для вызова
встроенных функций арифметики: можно писать `<+ …>` вместо `<Add …>`, `<* …>`
вместо `<Mul …>` и т.д. Рефал-05 такой синтаксис не поддерживает.


Пример результатного выражения:

    <ParseSentence-Aux
      (e.Sentences)
      <ParsePattern t.ErrorList (e.References) e.Tokens>
    >

При этом в правой части предложения могут использоваться только те переменные,
которые есть в левой части.

Семантика результатного выражения проще, чем образцового: подстановка, найденная
при сопоставлении аргумента с образцом, применяется к правой части.

А как же вычисления? Об этом в следующем разделе.


### Рефал-машина и поле зрения

Семантика Рефала-05 описывается в терминах рефал-машины — абстрактного
исполнителя программ на Рефале. Рефал-машина имеет две области памяти: поле
программ, где хранятся определения функций, и поле зрения, хранящее текущее
состояние вычисления.

Содержимое поля программ заполняется при запуске и остаётся неизменным всё
время работы рефал-машины, поэтому его рассматривать не интересно. К тому же
в актуальной реализации оно явным образом не выделено — все определения функций
скомпилированы в машинный код и загружаются операционной системой.

В поле зрения рефал-машины хранится объектное выражение, дополненное скобками
вызова функций — так называемое _активное выражение._

Рефал-машина работает по шагам. На каждом шаге она находит _первичное активное
подвыражение_ — самую левую пару скобок активации, не содержащую внутри себя
других скобок активации.

После чего рефал-машина смотрит, что находится справа от открывающей угловой
скобки. Если там находится имя функции, т.е. первичное активное подвыражение
имеет вид `<F E>`, то функция `F` вызывается, а выражение между именем функции
и закрывающей угловой скобкой `E` передаётся ей в качестве аргумента.

Если справа от `<` имени функции не нашлось — сразу за `<` следует `>` или
там находится что-то другое — круглая скобка, число или литера — рефал-машина
останавливается с ошибкой невозможности отождествления (recognition impossible).

**Отличие от Рефала-5.** Такая ситуация в Рефале-5 невозможна, поскольку имя
вызываемой функции неотделимо от открывающей угловой скобки.

Функция при успешном выполнении заменяет первичное активное подвыражение
на некоторое новое активное выражение. Функции, написанные на Рефале заменяют
свой вызов на результатное выражение с подстановкой переменных из левой части,
как написано в предыдущем разделе. Функции, написанные на Си, формируют новое
выражение на месте своего вызова в соответствии со своим алгоритмом.

Например, встроенная функция `ExistFile` ожидает, что её аргументом будет
последовательность литер — имя файла, существование которого надо проверить.
Если аргумент — не последовательность литер, функция завершает программу
с ошибкой невозможности отождествления. Если аргумент является цепочкой
литер, то функция пытается открыть файл с этим именем для чтения. Если открыть
файл удалось, то функция его закрывает и заменяет свой вызов (первичное
активное подвыражение) на имя функции `True`, в противном случае — на `False`.

Рефал-машина продолжает выполнение программы до тех пор, пока в поле зрения
есть скобки активации. Если скобок активации нет (поле зрения пассивно),
рефал-машина останавливается.

Предположим, мы имеем программу

    CheckFiles {
      e.Files = <Map CheckFile e.Files>;
    }

    Map {
      s.Func t.Next e.Tail = <s.Func t.Next> <Map s.Func e.Tail>;

      s.Func /* пусто */ = /* пусто */;
    }

    CheckFile {
      (e.FileName) = <ExistFile e.FileName>;
    }

поле зрения имеет вид

    <CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>

и файлы `foo.txt` и `baz.ref` существуют, а `bar.lisp` — нет.

На первом шаге рефал-машина найдёт единственный вызов функции, он будет
первичным активным подвыражением:

    <CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Подходящим предложением функции `CheckFiles` будет самое первое, переменная
`e.Files` свяжется со всем аргументом функции. Первичное активное подвыражение
будет заменено на правую часть:

    <Map CheckFile ('foo.txt') ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Подходящим будет первое предложение функции `Map`, при сопотавлении аргумента
с первым образцом будет получена следующая подстановка:

    CheckFile ← s.Func, ('foo.txt') ← t.Next, ('bar.lisp') ('baz.ref') ← e.Tail

Вызов функции `Map` будет заменён на результатное выражение первого предложения:

    <CheckFile ('foo.txt')> <Map CheckFile ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^^^

Первичным активным подвыражением (подчёркнуто) будет вызов `CheckFile`, он
заменится на вызов `ExistFile`:

    <ExistFile 'foo.txt'> <Map CheckFile ('bar.lisp') ('baz.ref')>
    ^^^^^^^^^^^^^^^^^^^^^

Файл существует, поэтому встроенная функция `ExistFile` будет заменена на `True`:

    True <Map CheckFile ('bar.lisp') ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Последующие шаги будут иметь вид:

    True <Map CheckFile ('bar.lisp') ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    True <CheckFile ('bar.lisp')> <Map CheckFile ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^^^
    True <ExistFile 'bar.lisp'> <Map CheckFile ('baz.ref')>
         ^^^^^^^^^^^^^^^^^^^^^^
    True False <Map CheckFile ('baz.ref')>
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^

Первое предложение функции `Map` будет подходящим, будет найдена подстановка

    CheckFile ← s.Func, ('baz.ref') ← t.Next, ε ← e.Tail

Т.е. переменная `e.Tail` примет значение пустого выражения. Идём дальше:

    True False <CheckFile ('baz.ref')> <Map CheckFile>
               ^^^^^^^^^^^^^^^^^^^^^^^
    True False <ExistFile 'baz.ref'> <Map CheckFile>
               ^^^^^^^^^^^^^^^^^^^^^
    True False True <Map CheckFile>
                    ^^^^^^^^^^^^^^^

Сопоставить `CheckFile` с левой частью первого предложения невозможно, но можно
с левой частью второго предложения:

    CheckFile ← s.Func

Правая часть второго предложения пустая, поэтому вызов функции заменяется
на пустое выражение:

    True False True

Вызовов функций нет, рефал-машина корректно останавливается.

Другой пример. Имеем программу

    Map {
      s.Func t.Next e.Tail = <s.Func t.Next> <Map s.Func e.Tail>;

      s.Func /* пусто */ = /* пусто */;
    }

и выражение в поле зрения `<Map 1 2 3 4 5>`:

    <Map 1 2 3 4 5>
    ^^^^^^^^^^^^^^^

Первое предложение применимо, существует подстановка:

    1 ← s.Func, 2 ← t.Next, 3 4 5 ← e.Tail

Заменяем на правую часть:

    <1 2> <Map 1 3 4 5>
    ^^^^^

В первичном активном подвыражении после `<` находится не имя функции, а число —
рефал-машина останавливается с ошибкой невозможности отождествления.

Поле программ такое же, как в первом примере, поле зрения содержит выражение:

    <<CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>>

Рефал-машина выполнит следующие шаги:

    <<CheckFiles ('foo.txt') ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <<Map CheckFile ('foo.txt') ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <<CheckFile ('foo.txt')> <Map CheckFile ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^^^
    <<ExistFile 'foo.txt'> <Map CheckFile ('bar.lisp') ('baz.ref')>>
     ^^^^^^^^^^^^^^^^^^^^^
    <True <Map CheckFile ('bar.lisp') ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <True <CheckFile ('bar.lisp')> <Map CheckFile ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^^^
    <True <ExistFile 'bar.lisp'> <Map CheckFile ('baz.ref')>>
          ^^^^^^^^^^^^^^^^^^^^^^
    <True False <Map CheckFile ('baz.ref')>>
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^
    <True False <CheckFile ('baz.ref')> <Map CheckFile>>
                ^^^^^^^^^^^^^^^^^^^^^^^
    <True False <ExistFile 'baz.ref'> <Map CheckFile>>
                ^^^^^^^^^^^^^^^^^^^^^
    <True False True <Map CheckFile>>
                     ^^^^^^^^^^^^^^^
    <True False True>
    ^^^^^^^^^^^^^^^^^

Рефал-машина вызывает функцию `True`, передавая ей аргументом `False True`.
Но функция `True` пустая — в ней ноль предложений. А это значит, что применимого
предложения нет. Программа останавливается с ошибкой невозможности отождествления.

Поле зрения и рефал-машина, работающая по шагам — это не просто математическая
абстракция, используемая для описания семантики. Рассматриваемая реализация
Рефала-05 действительно моделирует поле зрения в виде двусвязного списка
и действительно оно меняется по шагам — на каждом шаге обнаруживается следующий
вызов функции и эта функция вызывается. Подробнее об этом в разделе, посвящённом
интерфейсу с языком Си. <!--TODO-->


Библиотека встроенных функций
-----------------------------

Выше по тексту упоминались некие «встроенные функции» и даже приводился пример
одной из них — `ExistFile`. Любая функция, используемая в файле должна быть
описана — либо определена, либо объявлена как внешняя при помощи ключевого
слова `$EXTERN`. В Рефале-05 _встроенные функции_ — это функции, которые
компилятор неявно объявляет сам в каждой единице трансляции. Т.е. для встроенных
функций в каждом файле есть неявный невидимый `$EXTERN`, который их объявляет.

Но на деле эти функции должны быть где-то определены. В текущей реализации
они определены в библиотечном файле `Library.ref`, большинство из них написаны
на Си.

**Отличие от Рефала-5.** В Рефале-5 встроенные функции буквально встроены
в язык — жёстко зашиты в исходники компилятора и интерпретатора. Для них
действуют определённые правила — нельзя в файле объявить или определить
функцию, имя которой совпадает со встроенной, даже локальную. В Рефале-05
таких ограничений нет, встроенные функции — это просто функции, которые
неявно объявляются компилятором.

Далее мы перечислим встроенные функции в том порядке и с теми номерами,
в каком их перечисляет встроенная функция `ListOfBuiltin`.


### Нотация для записи типов функций

Для описания типов функций будем использовать следующие обозначения.

_Тип функции:_

    <ИмяФункции тип-аргумента>
      == тип-результата

Здесь `тип-аргумента` — описание области определения функции, `тип-результата` —
описание области значений. Оба типа — типы выражений

_Именованный тип:_

    переменная-типа ::= тип-выражения1 | тип-выражения2 | … | тип-выраженияN

Переменная типа записывается как обычная переменная Рефала, через вертикальную
черту перечисляются различные альтернативы.

Несколько именованных типов могут иметь одинаковое описание:

    перем1, перем2, перем3 ::= тип-выражения

_Тип выражения_ записывается как образцовое выражение, где после термов
(включая переменные) могут использоваться квантификаторы `*` (0 и более раз),
`+` (1 и более раз) и `?` (0 или 1 раз).

Переменные `s.CHAR`, `s.NUMBER` и `s.FUNCTION` описывают, соответственно,
произвольную литеру, число и функцию.

**Примеры.** Произвольное выражение, произвольный терм и произвольный символ:

    e.AnyExpr ::= t.AnyTerm*
    t.AnyTerm ::= s.AnySymbol | (e.AnyExpr)
    s.AnySymbol ::= s.CHAR | s.NUMBER | s.FUNCTION

Входная точка лексического анализатора (длинный список лексем сокращён):

    <R05-LexScan-File e.SourceName>
      == e.Tokens
    e.Tokens ::= (s.TokType t.SrcPos e.Info)
    t.SrcPos ::= (s.Row s.Col)

    s.TokType e.Info ::=
        TkChar s.CHAR
      | TkClose s.Bracket
      | TkCloseBlock
        …
      | TkError e.Message
      | TkExtern
      | TkName e.Name
      | TkNative (e.SourceName s.LineNo) (s.CHAR*)*
      | TkNumber s.NUMBER
      | TkOpen s.Bracket
      | TkOpenBlock
      | TkReplace
      | TkSemicolon
      | TkUnexpected e.BadCharacters
      | TkVariable s.Mode e.Index

    s.Bracket ::= Bracket | CallBracket
    e.Message, e.Name, e.SourceName, e.BadCharacters, e.Index ::= s.CHAR+
    s.LineNo ::= s.NUMBER
    s.Mode ::= 's' | 't' | 'e'

Входная точка синтаксического анализатора:

    <R05-Parse-File e.SourceFile>
      == Success e.Tree
      == Fails e.Errors

    e.Errors ::= ((s.Row s.Col) e.Message)*

Часть описания дерева:

    e.Tree ::= t.TreeItem*
    t.TreeItem ::=
        (Extern e.Name)
      | (Function s.Scope (e.Name) e.Body)
      | (Native e.Native)

    e.Name ::= s.CHAR+
    s.Scope ::= Entry | Local
    e.Body ::= Sentences t.Sentence* | Native e.Native
    e.Native ::= (e.SourceName s.Line) (s.CHAR*)*
    s.Line ::= s.NUMBER
    e.SourceName ::= s.CHAR+


### 1. Mu

    <Mu s.FUNCTION e.AnyExpr> == e.AnyExpr

**Семантика:** функция имеет следующую реализацию на Рефале

    $ENTRY Mu {
      s.Func e.Arg = <s.Func e.Arg>;
    }

Функция нужна для совместимости с Рефалом-5. Зачем она нужна, мы подробно
расскажем в следующем разделе.

**Совместимость с Рефалом-5** См. раздел «Совместимость с Рефалом-5 и общее
подмножество».

### 2. Add

    <Add s.NUMBER s.NUMBER> == s.NUMBER

**Семантика.** Вычисляет сумму двух чисел по модулю 2<super>N</super>, где
N — число двоичных разрядов типа `unsigned long` используемого компилятора
языка Си. Т.е. если сумма двух чисел превышает 2<super>N</super>, то результатом
этой функции будет число, образованное последними N битами.

**Совместимость с Рефалом-5.** В Рефале-5 поддерживаются длинная арифметика
и отрицательные числа. Рефал-05 оперирует только беззнаковыми числами,
не контролирует переполнение в арифметических операциях.

### 3. Arg

    <Arg s.ArgNo> == e.Argument

    s.ArgNo ::= s.NUMBER
    e.Argument ::= s.CHAR*

**Семантика:** возвращает аргумент командной строки с указанным номером.
Нулевой аргумент — имя вызываемой программы. Если запрашиваемый аргумент
не существует — фактическое их число меньше, чем `s.ArgNo`, возвращается
пустая строка.

**Совместимость с Рефалом-5.** Интерпретатор Рефала-5 пропускает все аргументы,
начинающиеся на знак минус, поэтому в переносимых программах не рекомендуется
использовать ключи командной строки, начинающиеся на минус.

### 5. Card

    <Card> == s.CHAR* 0?

**Семантика.** Считывает ~~перфокарту~~ строчку со стандартного ввода. Если
встречен символ конца файла, в конец прочитанной строки добавляется число `0`.

**Совместимость с Рефалом-5.** Встроенные функции `Card` и `Get` некорректно
считывают строки, содержащие внутри себя символ с кодом нуля `\x00`, поэтому
переносимые программы не должны читать двоичные файлы.

### 6. Chr

    <Chr e.AnyExpr> == e.AnyExprChr

    e.AnyExprChr ::= t.AnyTermChr*
    t.AnyTermChr ::= s.CHAR | s.NUMBER | (e.AnyExprChr)

**Семантика:** функция заменяет в своём аргументе все числа на символы-литеры
с соответствующим ASCII-кодом (по модулю 256).

**Совместимость с Рефалом-5:** полностью совместима.

### 10. Div

    <Div s.NUMBER s.NUMBER> == s.NUMBER

**Семантика.** Выполняет целочисленное деление. Если делитель равен нулю,
программа аварийно останавливается выдачей дампа поля зрения и ошибки «деление
на ноль».

**Совместимость с Рефалом-5:** см. `Add`.

### 12. Explode

    <Explode s.FUNCTION> == s.CHAR+

**Семантика.** Для символа-функции возвращает её имя как последовательность
литер, вместо литеры `-` возвращается `_`. Пример:

    <Explode R05-Parse-File> → 'R05_Parse_File'
    <Explode findfile_AnalyzeFile-ByFolders> → 'findfile_AnalyzeFile_ByFolders'

**Совместимость с Рефалом-5.** Функция `Explode` в Рефале-5 применяется
к символам-словам, не заменяет знаки `-` на знаки `_`.







