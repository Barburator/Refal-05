Введение в язык, цели
=====================

**Рефал-05** — минималистичный самоприменимый компилятор минималистичного
диалекта Рефала, имеющий общее подмножество с классическим Рефалом-5.
На этом подмножестве он и написан.

Были поставлены следующие цели разработки:

* Это должен быть минималистичный, но при этом самоприменимый компилятор Рефала.
* Компилятор должен быть совместим с актуальной реализацией Рефала-5. При этом
  совместимость означает не точное подмножество, а достаточно выразительное
  общее подмножество обоих языков. Причём компилятор должен быть сам написан
  на этом общем подмножестве.

Второстепенными, но тоже важными целями были:

* Компилятор не должен быть ограничен только самоприменением, он должен быть
  и практическим инструментом — после установки его можно использовать для
  разработки программ на Рефале.
* Исходники компилятора должны быть понятными и прозрачными.

Пользуясь языком математиков, можно сказать, что основные цели — это
оптимизируемые параметры в задаче оптимизации, а второстепенные — граничные
условия.

Разработка велась не с нуля, а на основе старой версии компилятора Простого
Рефала, путём его подгонки под упомянутые цели. Поэтому Рефал-05 наследует
некоторые особенности своего предшественника, такие как архитектура компилятора,
подход «символы-слова есть имена функций», подход к генерации кода и наличие
библиотеки `LibraryEx`.

Рассмотрим цели подробнее.


Минималистичный самоприменимый компилятор Рефала
------------------------------------------------

Прежде всего это должен быть компилятор _Рефала._ Языка, оперирующего
объектными выражениями — строками символов со спаренными круглыми скобками,
анализирующего их при помощи рефальского сопоставления с образцом,
имеющего поле зрения и переписывающего в нём содержимое ведущей пары скобок
конкретизации (иначе это был бы AMBIT).

Поэтому в языке должны быть рефальские образцы, скобки вызова (конкретизации),
объектные выражения из символов и круглых скобок, поле зрения, содержащее
символы, круглые скобки и скобки вызова.

Это должен быть _самоприменимый компилятор_ — транслятор Рефала в некоторый
низкоуровневый язык, написанный на себе. А значит, реализуемый диалект Рефала
должен быть достаточно удобен и выразителен для написания самоприменимого
компилятора.

И наконец, компилятор должен быть _минималистичным._ Сокращение выразительных
возможностей входного языка, с одной стороны, сокращает код и компилятора,
и библиотеки поддержки времени выполнения (далее будем пользоваться жаргонизмом
«рантайм»). С другой стороны, компилятор самоприменимый, а значит, на бедном
языке его сложнее разрабатывать и кода, скорее всего, потребуется наоборот
больше. При этом есть граничное условие: язык должен оставаться Рефалом.

Таким образом, необходим компромисс в выразительных возможностях языка.

Вторая цель предписывает нам использовать синтаксис, _похожий_ на Рефал-5,
притом компилятор должен быть написан на общем подмножестве: он должен
транслироваться и собой, и Рефалом-5, и при этом одинаково работать в обоих
случаях.

Будем выбирать подмножество Рефала-5. Условия и блоки отбрасываем — они
Турчиным и так декларируются как расширения. Кроме того, в Простом Рефале,
на основе которого создавался Рефал-05, их и так нет. Остаётся базисное
подмножество. Что нам нужно в нём?

Символы-литеры — нужны. Ведь нужно как минимум читать исходный файл и писать
целевой.

Символы-числа — нужны. Для своей реализации они требуют сравнительно немного
кода, гораздо меньше, чем если реализовывать десятичную арифметику поверх
литер-цифр.

Символы-слова… С ними программировать объективно удобнее, поэтому они нужны.
Осталось выбрать их форму с оглядкой на реализацию.

В официальной реализации Рефала-5 (PZ) символы-слова представляются в виде
C-строк `const char *`. Сравнивать их при помощи `strcmp()` неэффективно,
поэтому реализация поддерживает их уникальность с помощью глобальной
хеш-таблицы.

В Простом Рефале (на основе которого реализован Рефал-05) одновременно
существуют две конкурирующие концепции. Это указатели на функции и метки.

Указатели на функцию (символы-функции) записываются просто как имя глобальной
функции, сравниваются по указателю (одноимённые локальные функции в разных
файлах не равны), их можно прямо или косвенно помещать после `<`. Прямо —
понятно, обычный вызов функции `<F …>`, косвенно — `<s.F …>`, где переменная
`s.F` связана с некоторым символом-функцией.

Реализованы символы-функции как пара указателей: указатель на функцию языка
Си++ и указатель на имя как `const char *`. В сравнении на равенство участвует
первый указатель.

Метки записываются как имя, предварённое знаком `#`, например `#Success`.
Исходно их надо было определять при помощи ключевого слова `$LABEL`, но позже
явное определение было сделано необязательным. За счёт хитрого трюка Си++
с шаблонами удалось обеспечить одновременно и глобальность указателей,
и раздельную трансляцию. Реализуются так:

    //$LABEL ИмяМетки
    template <typename T>
    struct ИмяМетки {
      static const char *name() {
        return "ИмяМетки";
      }
    };

В коде на них ссылаются как `&ИмяМетки<int>::name`. Тонкость в том, что
повторные определения шаблонных функций из разных объектных файлов линковщик
удаляет, а значит, для идентификатора `ИмяМетки` в исполнимом файле останется
только один экземпляр функции `ИмяМетки<int>::name()`, и все указатели на неё
станут идентичными. Равенство проверяется путём сравнения указателей.

Совместимость с Рефалом-5
-------------------------

Практический инструмент
-----------------------

Прозрачность исходников
-----------------------
