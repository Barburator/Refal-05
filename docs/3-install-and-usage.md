Установка и использование, конфигурирование, отладка
====================================================

Сборка компилятора
------------------

Готовых инсталляторов вроде setup.exe нет, компилятор нужно вручную собирать
из исходников и правильно настроить переменные окружения.

Исходные тексты можно загрузить со страницы репозитория на GitHub

<https://github.com/Mazdaywik/Refal-05>

кликнув по зелёной кнопке «Clone or download↓», либо, если у вас установлен
Git, склонировать его командой

    git clone https://github.com/Mazdaywik/Refal-05

Для дальнейшей раскрутки компилятора понадобятся установленные компиляторы
языка Си и [Рефала-5][PZ] или [Рефала-5λ][Lam].

Дальнейшие шаги зависят от операционной системы. На **POSIX-системах (Linux,
macOS)** достаточно запустить скрипт `./bootstrap.sh` (если установлен Рефал-5)
или `./bootstrap.sh lambda` (если установлен Рефал-5λ). После этого
автоматически будут созданы папка `bin` и файл `c-plus-plus.conf.sh`
с параметрами компилятора Си, используемого для раскрутки. По умолчанию
там указан компилятор `gcc` с опциями `-Wall -g`. При желании компилятор можно
поменять (по инструкциям в комментариях) и выполнить раскрутку ещё раз. Если
команда `gcc` в командной строке недоступна (используется какой-нибудь другой
компилятор Си), то раскрутка пройдёт неуспешно, нужно будет
в `c-plus-plus.conf.sh` вписать правильную команду для запуска компилятора Си.

**Примечание.** На macOS часто ставится только Clang, но при этом команда `gcc`
является псевдонимом для запуска Clang’а, поэтому никаких дополнительных
действий делать не требуется.

На **Windows** всё немного интереснее: компиляторов языка Си целый зоопарк,
а значит, некоторый «дефолтовый», который доступен почти везде, вписать
в конфигурационный файл нельзя. Поэтому установка выполняется в две стадии.
После первого запуска `bootstrap.bat` (если установлен Рефал-5) или
`bootstrap.bat lambda` (если установлен Рефал-5λ) установка завершится
заведомо с ошибкой и будет создан файл `c-plus-plus.conf.bat`. После этого
в него нужно вписать командную строку для запуска компилятора и вызвать
`bootstrap.bat`/`bootstrap.bat lambda` второй раз. В конфигурационном файле
уже есть закомментированные заготовки для запуска компиляторов BCC 5.5,
Visual C++, GCC, Clang и Watcom — их можно раскомментировать, уточнив пути
к папкам.

**Примечание.** Такой же механизм конфигурации для раскрутки (и не только
раскрутки) применяется в Рефале-5λ, только там используется компилятор C++.
Имя файла `c-plus-plus.conf.*` унаследовано оттуда. В следующих версиях
конфигурационный файл может быть переименован.


Установка и конфигурирование
----------------------------

После успешной раскрутки у Вас должна появиться папка `bin`, содержащая файл
`refal05c.exe` или `refal05c` со флагом исполнимости (в зависимости от ОС).
Этот файл и есть исполнимый файл компилятора — его уже (не выполняя следующих
шагов) можно использовать для трансляции исходников Рефала-05 в Си. Чтобы
его можно было запускать из любой папки, добавьте его в переменную окружения
`PATH` (настройка переменных окружения зависит от операционной системы,
поэтому мы не будем здесь давать подробных шагов).

Компилятор `refal05c` может не только выполнять трансляцию исходников в Си,
но и искать библиотеки по стандартным путям и вызывать компилятор Си для
получения готового исполнимого файла. Только его надо об этом
проинструктировать.

Для этого нужно установить следующие переменные окружения:

* `R05CCOMP` — префикс командной строки для запуска компилятора Си. Примеры:
  `gcc -Wall -g -O3`, `bcc32 -w`, `cl /EHcs /W3 /wd4996 /O2` и т.д.
* `R05PATH` — пути для поиска исходников, перечисляются через _точку с запятой._
  Ей нужно присвоить полные пути до каталогов `lib` и `src` этого репозитория.

В переменной `R05PATH` нужно указать полные пути к папкам `lib` и `src` данного
репозитория, причём они должны быть доступны на запись (ограничение текущей
версии). Папку `lib` нужно указывать обязательно, чтобы компилятор мог находить
пути к файлам библиотеки поддержки времени выполнения («рантайм») и библиотеке
встроенных функций. Папка `src` опциональная — там находится вспомогательная
библиотека `LibraryEx` и компоненты компилятора.

**Примечание.** На POSIX-системах (Linux или macOS) в переменную `R05CCOMP`
желательно добавлять `-DR05_POSIX` (например, `gcc -DR05_POSIX`) — в этом
случае функция `System` будет корректно возвращать код возврата. Без данного
флага работать всё равно всё будет, только `System` будет возвращать сырое
значение функции `system` языка Си, которое может отличаться от фактического
кода возврата (см. `man 2 wait` для более подробных сведений).

Если вы пользуетесь компилятором Рефал-5 и раскрутка Рефала-05 производилась
с его помощью, в папке `bin` будут располагаться `.rsl`-файлы для всех файлов
каталога `src`, в частности, весьма полезная библиотека `LibraryEx`. Путь
к папке `bin` можно добавить к переменной окружения `REF5RSL`.

**Пример.** Для операционной системы Windows 98, компилятора BCC 5.5 и данного
дистрибутива, расположенного в `C:\Refal-05` нужно в конец `autoexec.bat`
добавить следующие строчки:

    set PATH=%PATH%;C:\Refal-05\bin
    set R05CCOMP=bcc32 -w
    set R05PATH=C:\Refal-05\lib;C:\Refal-05\src
    set REF5RSL=%REF5RSL%;C:\Refal-05\bin

Настройка окружения завершена. Компилятором теперь можно пользоваться.


Использование компилятора
-------------------------

Синтаксис командной строки простой, компилятор может вызываться двумя
способами:

    refal05c имяфайла1 имяфайла2 имяфайла3...

или

    refal05c @списокфайлов

где `списокфайлов` — обычный текстовый файл, в каждой строке которого
должно быть записано имя файла.

Файлы, которые перечислены в командной строке, должны быть исходными текстами
либо на Рефале (расширение `.ref`), либо на Си (`.c`). Для каждого файла
последовательно проверяется его наличие в текущей папке, затем по каждому
из путей, перечисленных в `R05PATH`. Если расширение не указано, то по каждому
пути поиска (текущая папка и папки из `R05PATH`) проверяется наличие сначала
с расширением `.ref`, потом с расширением `.c`.

Каждый файл на Рефале компилируется в одноимённый файл с расширением `.c`,
который находится в той же папке, что и исходный. Отсюда и ограничение, что
пути поиска, перечисленные в `R05PATH` должны быть доступны для записи.

Если переменная `R05CCOMP` установлена и не пустая, то после компиляции
всех исходников имена сишных файлов (как заданных пользователем, так
и сгенерированных) передаются компилятору `R05CCOMP`. Для каждого пути
поиска в командную строку запуска компилятора добавляется опция `-I`
(include path) с путём до каждой папки в `R05PATH`.

Компилятор также понимает переменную среды `R05CFLAGS`, содержимое которой
(если она установлена) добавляется в командную строку компилятора Си. Эта
переменная используется для временного задания ключей для конкретного запуска,
например, для компилятора GCC можно задавать имя целевого файла при помощи
`-ofilename` (без этого ключа будет создан исполнимый файл с именем по умолчанию
вроде `a.exe` или `a.out`).

Если переменная `R05CCOMP` пустая, то Рефал-05 после компиляции исходных
файлов в Си ничего не делает.

Никакие исходные файлы в командную строку неявно не добавляются, поэтому
пользователь должен сам всегда явно указывать два вспомогательных файла:
_библиотеку поддержки времени выполнения_ (runtime support library, далее
будем называть её **рантайм)** `refal05rts.c` и _библиотеку встроенных
функций языка_ `Library.ref`.

Рантайм `refal05rts.c` содержит реализацию функций, вызываемых
из сгенерированного кода — элементарных команд сопоставления с образцом
и построения результата, имитацию абстрактной рефал-машины, средства отладки
(прежде всего, отладочный дамп) и функцию `main()` языка Си.

Библиотека встроенных функций `Library.ref` содержит реализации всех
встроенных функций языка, преимущественно, написанные на Си (в виде нативных
вставок<!--TODO-->).

Файлы `refal05rts.c` и `Library.ref`, а также `refal05rts.h`, содержащий
определения внутренних структур данных и прототипы функций, используемых
в сгенерированном коде, располагаются в каталоге `lib`. Поскольку для папок,
перечисленных в `R05PATH`, автоматически формируется опция `-Iпапка`,
файл `refal05rts.h` будет найден компилятором Си без каких-либо дополнительных
действий со стороны пользователя.

Каталог `src` содержит исходные тексты компилятора, выполненные как компоненты
повторного использования, и библиотеку `LibraryEx.ref`, целиком написанную
на Рефале. Библиотека содержит удобные вспомогательные функции, например, `Map`,
которая применяет функцию ко всем термам выражения, и `LoadFile`, которая
принимает имя текстового файла и возвращает последовательность строк в нём.
Подробнее о `LibraryEx` и других компонентах из `src` будет<!--TODO--> написано
в соответствующем разделе.

Таким образом, любой запуск компилятора требует указания `refal05rts`
и `Library`, большинство также потребует `LibraryEx`.

**Пример.** Пусть компилятор установлен правильно (настроены `R05CCOMP`
и `R05PATH`) и записана такая командная строка:

    refal05c myprogram refal05rts Library LibraryEx

Компилятор в этом случае найдёт `myprogram.ref` в текущей папке, `refal05rts.c`
и `Library.ref` в папке `lib`, `LibraryEx.ref` в папке `src`. Будут созданы
файлы `myprogram.c` в текущей папке, `Library.c` в папке `lib` и `LibraryEx.c`
в папке `src`. Если задана непустая переменная `R05CCOMP`, будет вызван
компилятор Си, которому будут переданы четыре сишных файла и ключи `-I`
с путями к папкам `lib` и `src`.


Средства отладки программ в Рефале-05
-------------------------------------

Программ без ошибок не бывает, поэтому любая практически применимая реализация
языка программирования должна предоставлять возможности для поиска и диагностики
ошибок. В этом разделе мы рассмотрим основные средства и приёмы отладки программ
на Рефале-05.

### Аварийный отладочный дамп

Основным средством поиска и диагностики ошибок является аварийный дамп. Если
для некоторого вызова функции не удалось сопоставить аргумент ни с одним
из образцов, выполнение программы прерывается и на `stderr` выводится ошибочное
первичное активное подвыражение и вслед за ним всё поле зрения. Похожий дамп
выводится, если программе не хватило памяти (в этом случае дамп может быть очень
длинным), либо если произошла ошибка при вызове встроенной функции (например,
деление на ноль в `Div` и `Mod` или файл для открытия в `Open` не существует).

Обычно отладочного дампа бывает достаточно — повторно вызываем программу,
перенаправив `stderr` в файл и пытаемся по дампу понять, что же тут не так. Либо
упавшей функции передаётся неправильный аргумент — в этом случае нужно искать
все вызовы этой функции, либо аргумент правильный, но ошибка уже в самой
функции.

### Средства отладки и диагностики рантайма

Библиотека поддержки времени выполнения содержит несколько простых средств для
вывода дополнительной диагностики и преждевременного аварийного прерывания
программы. Все эти средства по умолчанию отключены, включаются они установкой
макросов препроцессора языка Си.

В большинстве компиляторов макрос препроцессора устанавливается опцией `-Dимя` —
просто определяет макрос и `-Dимя=значение` — устанавливает заданное значение.

Например, следующий запуск

     gcc -DPLATFORM_WIN32 -DPAGE_SIZE=4096 myprogram.c

откомпилирует `myprogram.c` с установленными макросами `PLATFORM_WIN32`
и `PAGE_SIZE`, причём второй будет заменяться на значение `4096`.

При отладке программ на Рефале диагностические макросы можно непосредственно
задавать в `R05_CCOMP`, но рекомендуется эту переменную не трогать, вместо
чего использовать `R05_CFLAGS`.

**Пример.** Соберём программу с выводом статистики и лимитом по памяти
1000000 узлов. Командная строка для Windows:

    set R05_CFLAGS=-DR05_SHOW_STAT -DR05_MEMORY_LIMIT=1000000
    refal05c myprogram refal05rts Library LibraryEx

Командная строка для Bash:

    R05_CFLAGS="-DR05_SHOW_STAT -DR05_MEMORY_LIMIT=1000000"
    refal05c myprogram refal05rts Library LibraryEx

Далее мы перечислим все доступные макросы.

#### Макрос `R05_SHOW_STAT` — общий профиль работы программы

Если этот макрос установлен, программа после завершения своей работы выводит
на `stderr` информацию о времени работы, количестве шагов и использованной
памяти. Например:

    Total program time: 2.594 seconds (100.0 %).
    (Total refal time): 1.393 seconds (53.7 %).
    Builtin time: 1.201 seconds (46.3 %).
    Linear result time: 0.740 seconds (28.5 %).
    Linear pattern time: 0.653 seconds (25.2 %).
    Open e-loop time (clear): 0.142 seconds (5.5 %).
    t- and e-var copy time: 0.046 seconds (1.8 %).
    Repeated e-var match time (inside e-loops): 0.031 seconds (1.2 %).
    Step count 3610740
    Memory used 270327 nodes, 270327 * 16 = 4325232 bytes

Для времени работы программы отдельно выписываются различные виды затрат,
в скобках указывается процент от полного времени работы. Если затраты
времени на некоторую компоненту оказались равны нулю (меньше погрешности
измерения времени), соответствующая строчка не печатается.

Рассмотрим каждую из строчек подробнее:

* `Total program time` — общее время выполнения, от запуска до завершения.
* `Builtin time` — время выполнения функций, описанных при помощи нативных
  вставок. Это прежде всего встроенные функции.
* `(Total refal time)` — суммарное время выполнения функций, написанных
  на Рефале. В сумме с `Builtin time` должно давать 100 %.
* `Linear pattern time` — «линейное» время сопоставления с образцом. Это
  то время, которое зависит только от вида образца и не зависит от аргумента.
  Из него исключается время, затраченное на сопоставление с повторными
  t- и e-переменными, а также время внутри циклов удлинения открытых
  e-переменных.
* `Linear result time` — «линейное» время построения правой части. Тоже та
  его компонента, которая зависит только от вида образца и не зависит
  от значений переменных — исключается время копирования повторных переменных.
* `Open e-loop time (clear)` — время, затраченное на циклы удлинения открытых
  переменных без учёта сопоставления повторных t- и e-переменных внутри цикла.
* `Repeated ?-var match time (???? e-loops)` — время на сопоставление повторных
  t- и e-переменных. Вместо `?` записывается литера `t` или `e`, вместо `????` —
  слово `inside` или `outside`. Соответственно, это время выполнения внутри
  и вне цикла удлинения открытых e-переменных. В примере выше сопоставления
  с повторными e-переменными внутри циклов удлинения потребовали 0,031 секунду,
  сопоставления с t-переменными и с e-переменными вне циклов потребовали времени
  меньше погрешности измерения (формально — ноль секунд), поэтому
  не напечатались.
* `t- and e-var copy time` — время копирования переменных при построении
  правой части.
* `Step count` — количество шагов рефал-машины.
* `Memory used` — количество узлов, количество узлов × размер узла = объём
  затраченной памяти в байтах. Узел имеет размер 16 байт при компиляции
  в 32-разрядный код и 32 байта — в 64-разрядный.

«Линейное» время сопоставления с образцом и построения результата зависит только
от вида левых и правых частей, остальные компоненты — циклы удлинения, сравнение
на равенство повторных переменных, копирование переменных в правой части —
зависят и от входных данных. Подробнее эти компоненты мы обсудим при
рассмотрении деталей реализации<!--TODO-->.

#### Макрос `R05_SHOW_DEBUG=n`

Этот макрос должен содержать целое число — номер шага, начиная с которого нужно
распечатывать дамп.





[PZ]: http://www.botik.ru/pub/local/scp/refal5/
[Lam]: https://bmstu-iu9.github.io/refal-5-lambda/
