Реализация: списковое представление и интерфейс с языком Си
===========================================================

В этом разделе будет описано, как отображаются высокоуровневые конструкции
Рефала-05 (данные — объектные выражения, рефал-машина, сопоставление с образцом
и т.д.) на более низкоуровневые понятия компьютера, выраженные в терминах
языка Си.

В первой главе раздела мы рассмотрим списковое представление поля зрения —
способ построения данных Рефала в виде двусвязных списков, не опускаясь
в технические подрнобности. Эту главу рекомендуется прочитать всем,
поскольку изложенные в ней сведения нужны, чтобы писать эффективные программы
для данной реализации. Последующие главы будут необходимы лишь для разработки
нативных функций и для доработки самого компилятора.

Во второй главе будут обсуждаться структуры данных поля зрения уже в терминах
языка Си, реализация рефал-машины и идеология компиляции функций на Рефале
в целевой код. После прочтения этой главы содержимое порождаемых компилятором
файлов на Си станет частично понятным. В этой главе кратко и между делом
будут затронуты некоторые API-функции рантайма.

Третья глава является уже руководством по написанию нативных функций Рефала-05,
т.е. функций, тело которых описывается не на Рефале, а на Си. Будет описан
синтаксис для написания таких функций и детально описано API рантайма.


Что это значит — списковая реализация Рефала?
---------------------------------------------

### Представление поля зрения при помощи двусвязных списков

Как было сказано [в разделе 2][2], рассматриваемая реализация действительно
моделирует работу рефал-машины. Это значит, что в памяти программы на Рефале
представлено каким-то образом поле зрения, которое переписывается по шагам.
[В разделе 5][5], в частности, рассказывается, что содержимое поля зрения можно
увидеть при аварийной остановке программы, либо на каждом шаге, откомпилировав
программу с особыми ключами.

Актуальная реализация представляет поле зрения в виде двусвязного списка —
структуры данных, состоящих из узлов (звеньев), каждое из которых содержит
ссылки (указатели) на следующее звено и предыдущее. Каждое звено такого списка
представляет либо символ (литеру, число или функцию), либо скобку (`(`, `)`,
`<`, `>`). Узлы-символы хранят значения символов (соответственно, значение
литеры, число или указатель на представление функции), узлы-скобки хранят
указатели на другие узлы-скобки.

Узлы, соответствующие круглым скобкам, хранят указатели на сопряжённые скобки:
открывающая `(` содержит указатель на узел, содержащий парную ей `)` и наоборот.
Благодаря этому сопоставление выражения с образцом вида `(…) …` или `… (…)`
выполняется за константное время. Если образец начинается на круглую скобку,
то следуя по указателю в ней, легко найти парную скобку и затем продолжить
сопоставление частей образца внутри и после скобок.

С угловыми скобками хитрее. Как мы помним [из раздела 2][2], рефал-машина
должна находить на каждом шаге очередное первичное активное подвыражение —
самую левую пару угловых скобок, не содержащую внутри себя других скобок.
Указатели, хранимые в угловых скобках, позволяют находить его за небольшое
константное время, избегая полного просмотра поля зрения.

Что значит, найти первичное активное подвыражение? Это значит, что нужно
получить указатели на искомые угловые скобки — между ними будет находиться
имя функции и её аргумент.

Открывающие угловые скобки, также как и круглые, содержат ссылки на парные
им закрывающие. Это позволяет, найдя левую скобку, сразу зафиксировать парную
ей. Каждая закрывающая угловая скобка содержит указатель на ту открывающую
скобку, которая активируется после текущей. Указатель на левую угловую скобку
первичного активного подвыражения хранится в глобальной переменной рантайма
`s_stack_ptr`. Последняя правая угловая скобка ссылается на `NULL`. Таким
образом, скобки активации провязаны в односвязный список. Выглядит это так:


```
s_stack_ptr ────┐
  ┌─────────────┼───────────────────────────────────────────────────────┐
  │             │                    ┌───────────────────────────┐      │     NULL
  │             │             ┌──────┼─────────────┐             │      │      ↑
  ↓             ↓             │      ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ G ║←→║ > ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             │             ↑      ↑      ↑
  │             └─────────────┘      │             └─────────────┘      │      │
  │                                  └──────────────────────────────────┘      │
  └────────────────────────────────────────────────────────────────────────────┘
```

Первичное активное подвыражение в этом примере `<G>`, на его левую скобку
указывает глобальная переменная `g_stack_ptr`, правую угловую скобку
рефал-машина найдёт, если проследует по указателю из левой скобки. При вызове
функции `G` первичное активное подвыражение будет снято со стека (изъято
из односвязного списка) и переменная `s_stack_ptr` будет указывать на следующую
пару скобок вызова `<I>`. Если вызов `<G>` заменится на пустоту, то поле зрения
приобретёт следующий вид:


```
s_stack_ptr ──────────────────┐
  ┌───────────────────────────┼────────────────────┐     NULL
  │             ┌─────────────┼─────────────┐      │      ↑
  ↓             ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             │             ↑      ↑      ↑
  │             │             └─────────────┘      │      │
  │             └──────────────────────────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Допустим, вызов `<I>` тоже вычислился в пустоту:

```
s_stack_ptr ────┐
  ┌─────────────┼─────────────┐     NULL
  ↓             ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      ↑
  │             └─────────────┘      │
  └──────────────────────────────────┘
```

Если вызов функции заменяется на выражение с новыми скобками активации, то они
тоже добавляются в стек. Пусть вызов `<H>` заменяется на `<K> <L>`.

```
s_stack_ptr                                              NULL
  ↓                                                       ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │                                                       ↑
  └───────────────────────────────────────────────────────┘
```

На стек сначала будет положена пара скобок вокруг `L`, затем, вокруг `K`:

```
s_stack_ptr ────┐
  ┌─────────────┼──────────────────────────────────┐
  │             │             ┌──────┐             │     NULL
  ↓             ↓             │      ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             ↑      ↑
  │             └─────────────┘      └─────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Таким образом, ссылки в угловых скобках позволяют эффективно находить первичное
активное подвыражение в поле зрения.

### Зачем это нужно программисту: эффективность отдельных операций

Когда рефал-машина передаёт управление функции, она получает пару указателей
на угловые скобки, ограничивающие первичное активное подвыражение. Функция
должна будет выделить из этого выражения аргумент (отбросив скобки вызова
и своё имя), последовательно сопоставить аргумент с каждым из образцов, и для
первого подошедшего образца построить результат по шаблону в правой части.

**Примечание.** Из соображений минимализма текущая реализация Рефала-05
выполняет сопоставление аргумента с каждым из образцов независимо — при
переходе к следующему забывает о том, какие операции сопоставления в предыдущих
образцах уже выполнялись.

Сопоставление с образцом разбивается на последовательность элементарных
операций: сопоставления со скобками, символами, переменными. Общий принцип
следующий. В процессе сопоставления отслеживается один или несколько
_диапазонов_ — ещё не проанализированных участков аргумента и соответствующих
им участков образца. Сопоставление начинается с того, что единственным
диапазоном объявляется весь аргумент и весь образец. Действия в последующих
абзацах повторяются до тех пор, пока не останется ни одного диапазона.

Если есть диапазон, образец которого начинается или заканчивается символом,
проверяется, что этот участок аргумента не пустой и начинается или заканчивается
тем же символом. Символ вычёркивается из диапазона образца. Сопоставление
с символами выполняется за малое константное время.

Иначе, если есть диапазон, который начинается (заканчивается) скобочным термом,
проверяется, что аргумент начинается (заканчивается) на круглую скобку, по ссылке
находится парная ей скобка, из диапазона удаляется скобочный терм, создаётся
новый диапазон, соответствующий содержимому скобок. Сопоставление со скобочным
термом выполняется за константное время.

Иначе, если есть диапазон с пустым образцом — проверяется, что участок аргумента
тоже пустой. Диапазон удаляется. Сопоставление с пустотой выполняется
за константное время.

Иначе, если есть диапазон, который начинается (кончается) на переменную, которая
уже получила своё значение, проверяется, что участок аргумента тоже начинается
(заканчивается) на это же значение. Переменная вычёркивается из диапазона.
Переменные, сопоставляемые в таких случаях, называются _повторными._
Сопоставления с s-переменными выполняются за константное время, не зависящее
от значения переменной, поскольку значением может быть либо литера (`char`),
либо число (`long int`), либо имя функции (указатель). Сопоставление с t- и
e-переменными выполняются за время, пропорциональное числу узлов в их значениях.

**Интересное примечание.** Заметим, что значением t- и e-переменной является
плоский двусвязный список, поэтому для сравнения на равенство достаточно
последовательного просмотра в простом цикле. Рекурсивных вызовов для сравнения
содержимого скобок не нужно, а это значит, что глубина вложенности скобок
ограничена лишь размером поля зрения. В других реализациях Рефала сравнение
на равенство может требовать рекурсию, а значит, и системный стек.

Иначе, если есть диапазон, состоящий из одной e-переменной, ещё не получившей
своего значения, переменная связывается с соответствующим участком аргумента.
Такая e-переменная называется _закрытой._ Диапазон удаляется. Сопоставление
с закрытой переменной всегда успешно и выполняется за константное время.

Иначе, если есть диапазон, начинающийся (заканчивающийся) на s- или
t-переменную, то от участка аргумента отделяется символ или терм и связывается
с переменной (переменная здесь ещё не связана, поскольку проверка на повторные
переменные выполняется раньше). Переменная вычёркивается из диапазона.
Связывание новой s- или t-переменной выполняется за константное время.

Если ни одно из перечисленных условий не выполнилось, то или не осталось
ни одного диапазона, или все диапазоны имеют вид `e.X … e.Y`, где e-переменные
ещё не получили своего значения. Самая первая несвязанная e-переменная в записи
левой части предложения (она же первая переменная самого левого диапазона)
объявляется _открытой._ Она последовательно связывается с префиксом участка
аргумента длиной 0, 1, 2… терма и для каждого её значения продолжается
сопоставление с образцом до тех пор, пока не найдётся первое удачное
сопоставление. Иначе говоря, остальная часть образца помещается _в цикл_ по всем
допустимым длинам открытой e-переменной. Переменная вычёркивается из диапазона.
Выбор каждого следующего значения выполняется за константное время (просто
сдвигается указатель на начало следующего терма), но надо понимать, что все
последующие операции выполняются в этом цикле.

Таким образом, если в образце есть одна открытая переменная — время
сопоставления со всем образцом будет линейно зависеть от длины (в термах)
соответствующего участка аргумента, две открытые переменные дадут квадратичные
затраты времени (произведение количества удлинений первой переменной
на количество для второй).

**Пример.** Рассмотрим сопоставление с образцом

    (e.Name) e.Values-B ( (e.Name) e.Value ) e.Values-E
    1 2    3  4         5 6 7    8  9     10  11

Элементы образца пронумерованы для того, чтобы ссылаться на них в тексте.
Перечислим операции сопоставления, которые будут выполняться для этого образца
(если о временны́х затратах не говорится, то подразумевается константа).

* Сопоставление с парой скобок 1, 3.
* Сопоставление с закрытой переменной `e.Name` (2).
* Мы имеем диапазон вида `e.Values-B … e.Values-E`. Переменная `e.Values-B` (4)
  объявляется открытой. Последующие операции выполняются в цикле для всех
  возможных длин `e.Values-B` (числу термов диапазона):
  * Сопоставление со скобочным термом 5, 10.
  * Сопоставление со скобочным термом 6, 8.
  * Сопоставление с повторной переменной `e.Name` (7) слева. От диапазона внутри
    скобок 6, 8 отделяется префикс, равный значению переменной `e.Name` (2).
    Время сопоставления пропорционально длине совпадающей части известного
    значения переменной и диапазона, сверху ограничено длиной `e.Name` (2)
    в узлах списка.
  * Сопоставление диапазона между `e.Name` (7) и закрывающей скобкой 8
    с пустотой.
  * Сопоставление с закрытой переменной `e.Value` (9).
  * Сопоставление с закрытой переменной `e.Values-E` (11).

Время сопоставления с этим образцом пропорционально произведению длины в узлах
переменной `e.Name` и длины участка `e.Values-B … e.Values-E` в термах. Вернее,
ограничено сверху этой величиной.

**Пример.** Рассмотрим сопоставление с образцом

    (e.Set1-B t.Common e.Set1-E) (e.Set2-B t.Common e.Set2-E)
    1 2        3        4      5 6 7        8        9     10

Операции сопоставления:

* Сопоставление со скобочным термом 1, 5.
* Сопоставление со скобочным термом 6, 10.
* Сопоставление с пустым диапазоном.
* Цикл по открытой переменной `e.Set1-B` (2):
  * Сопоставление с переменной `t.Common` (3), переменная получает значение.
  * Сопоставление с закрытой переменной `e.Set1-E` (4).
  * Цикл по открытой переменной `e.Set2-B` (7):
    * Сопоставление с повторной переменной `t.Common` (8). Время сопоставления
      пропорционально длине `t.Common` (3) в узлах списка.
    * Сопоставление с закрытой переменной `e.Set2-E` (9).

Время сопоставления пропорционально произведению длин (в термах) содержимого
обоих скобочных термов и длины повторной переменной `t.Common` (в узлах списка).

**Важный вывод.** Если образец содержит открытые переменные или повторные t-
и e-переменные, то время сопоставления с ним зависит от значений этих переменных.
В остальных случаях время сопоставления зависит только от вида образца.

**Кстати,** образцы без открытых переменных и повторных t- и e-переменных
в теории метавычислений над Рефалом называются _L-выражениями._ Для функций,
все предложения которых являются L-выражениями, можно определить простую
и выразительную систему эквивалентных преобразований (см. например,
[здесь][alushta]).

**Примечание.** Можно придумать реализации, в которых эти операции сопоставления
были бы гораздо быстрее. Например, если для всех скобочных термов хранить
глобальную хеш-таблицу, и при создании нового терма проверять, есть ли такой же
в таблице, то сравнение одноимённых t-переменных будет выполняться
за константное время. Если для каждого объектного выражения, которое строится
в программе, поддерживать суффиксное дерево, то поиск по открытым переменным
также мог быть эффективнее линейного просмотра. Идея использования суффиксных
деревьев в Рефале предложена Скоробогатовым С. Ю. \[частное сообщение].

В результате успешного сопоставления с образцом переменные предложения
получают свои значения. E-переменные представляются парой указателей на начало
и конец (для пустых переменных они оба равны нулю), s-переменные представляются
указателем на узел, t-переменные — на первое звено значения (символ или левую
круглую скобку). Если переменная входит в образец несколько раз (является
_повторной,)_ то для неё запоминаются все вхождения. Например, если переменная
`e.X` входила в образец 3 раза, то все её вхождения будут сохранены в трёх
парах указателей.

Построить результат — это значит, построить двусвязный список, на который
следует заменить первичное активное подвыражение в поле зрения,
и, собственно, выполнить эту замену. При этом, само первичное активное
подвыражение уже становится ненужным, а это значит, что оттуда можно взять
готовые фрагменты результата. Текущая реализация, однако, берёт оттуда только
значения e- и t-переменных (s-переменные дешевле построить заново).

Но в некоторых случаях e- и t-переменные приходится копировать — без копии
не обойтись, если в правой части предложения некоторая переменная имеет больше
вхождений, чем в левую. Например, для предложения

    t.SymTable (e.Name) e.Name =
      <Lookup t.SymTable e.Name> '+' <Lookup t.SymTable e.Name>

переменную `t.SymTable` придётся скопировать, в то время как `e.Name` — нет.

Копирование t- или e-переменной требует времени, пропорционального длине
значения переменной в узлах списка. Для правильного связывания между собой
парных круглых скобок в копии дополнительная память не требуется — как стек
используются поля связи узлов ещё не спаренных скобок. Псевдокод:

    bracket_stack = NULL

    for (p ← очередной узел оригинала) {
      q = alloc_node();
      if (p — открывающая скобка) {
        q->tag = открывающая_скобка;
        q->link = bracket_stack;
        bracket_stack = q;
      } else if (p — закрывающая скобка) {
        q->tag = закрывающая_скобка;

        парная = bracket_stack;
        bracket_stack = парная->link;

        парная->link = q;
        q->link = парная;
        q->link = bracket_stack;
      } else {
        /* p — символ */
        скопировать значение p в q;
      }
    }

    Здесь снова должен быть bracket_stack == NULL

Таким образом, копирование, как и сравнение на равенство, не требует рекурсии
и вообще не зависит от глубины вложенности скобок. А значит, глубина вложенности
ограничена лишь размером поля зрения.

После построения результата функция возвращает выполнение рефал-машине, а та
ищет следующее первичное активное подвыражение.

Время выполнения нативной функции (т.е. функции, написанной не на Рефале,
а на Си) зависит уже от семантики и реализации самой функции.

### Подытожим

* Рефал-машина ищет первичное активное подвыражение за константное время.
* Время сопоставления с образцом зависит от вида образца. Повторные
  t- и e-переменные требуют времени, пропорционального длине их значения
  в термах. Открытые переменные приводят к неявному циклу удлинения этих
  переменных — последующие операции сопоставления повторяются на каждом цикле.
* Если t- или e-переменная имеет больше вхождений в правую часть, чем в левую,
  то каждое такое дополнительное вхождение требует копирования значения этой
  переменной — времени, пропорционального длине значения в узлах.
* Если копируемых переменных нет, то время построения результата определяется
  только видом этого результата и не зависит от значений переменных.
* Время выполнения нативных функций определяется семантикой этих функций.
* ДРУГИХ СКРЫТЫХ ЗАТРАТ ВРЕМЕНИ НЕТ. В частности, нет сборки мусора.
  В некотором смысле, Рефал со списковой реализацией — язык реального
  времени 😉.

### Ещё раз о встроенном профилировщике

Как сказано в [разделе про реализацию][3], Рефал-05 содержит встроенный
профилировщик, выводящий затраты времени на отдельные операции. Вернёмся
к этим метрикам в свете новых знаний.

* `Total program time` — общее время выполнения программы.
* `Builtin time` — время выполнения нативных функций.
* `(Total refal time)` — суммарное время выполнения функций, написанных
  на Рефале. В сумме с `Builtin time` должно давать 100 %.
* `Linear pattern time` — время сопоставления с образцом до цикла по открытой
  переменной и без учёта сопоставления с повторными t- и e-переменными.
* `Linear result time` — время построения правой части без учёта времени
  копирования t- и e-переменных.
* `Open e-loop time (clear)` — время, затраченное на циклы удлинения открытых
  переменных без учёта сопоставления повторных t- и e-переменных внутри цикла.
* `Repeated ?-var match time (???? e-loops)` — время на сопоставление повторных
  t- и e-переменных. Вместо `?` записывается литера `t` или `e`, вместо `????` —
  слово `inside` или `outside`. Соответственно, это время выполнения внутри
  и вне цикла удлинения открытых e-переменных.
* `t- and e-var copy time` — время копирования переменных при построении
  правой части.
* `Step count` — количество шагов рефал-машины.
* `Memory used` — наибольшая длина поля зрения в узлах. Поскольку актуальная
  реализация выделенную память не освобождает до завершения программы, то после
  достижения пика объём используемой памяти останется равным наибольшему
  значению.


### А бывает по-другому?

Бывает. Помимо реализации Рефала на плоских двусвязных списках, есть ещё
и представления объектных выражений двусвязными списками с подвешенными
скобками (Рефал-6, [FLAC][flac]), односвязными списками ([Рефал-2
Эйсымонта][eisymont]), представление объектных выражений массивами (или
векторами) ([Рефал Плюс][plus], [Рефал-Java][refalj]) и даже
«векторно-списковое» — массивное, но с отложенной конкатенацией,
предложенное Скоробогатовым (рукопись, нигде не опубликовано).

Все эти реализации отличаются затратами времени на базовые операции.

Списковое представление с подвешенными скобками отличается тем, что в нём
каждый узел списка соответствует не знаку записи объектного выражения
(символ или одна из двух скобок), а целому терму. Узел скобочного терма
содержит указатель на список узлов, соответствующий содержимому скобок.
Выражения, представленные таким образом, копируются дешевле — не нужно
создавать полную копию содержимого скобок, достаточно создать новый узел,
содержащий указатель на тот же подсписок. Недостаток — гораздо менее очевидно,
когда значение переменной копируется, а когда — переносится.

Односвязные списки в реализации Эйсымонта эффективнее расходуют память, узлы
содержат не два указателя, а только один. Это было актуально на старых ЭВМ
с небольшой памятью, может быть актуально и сейчас, поскольку такие программы
могут эффективнее использовать кэш. Недостаток заключается в том, что
сопоставление справа-налево выполняется не за константное, а за линейное время.
Т.е. для образца вида `e.X s.Y` придётся просмотреть весь аргумент в поисках
последнего звена, чтобы его связать с `s.Y`, а весь предшествующий участок —
с `e.X`. В остальном временны́е затраты похожи на представление с подвешенными
скобками.

Массивовое представление облегчает копирование переменных — e-переменная
представляется парой индексов на начало и конец массива, t-переменная — индексом
самого элемента. Недостаток — затраты времени на конкатенацию. При выполнении
предложения

    (e.X) (e.Y) = e.X e.Y;

потребуется выделить новый участок массива длиной, равной сумме длин переменных
`e.X` и `e.Y` и скопировать туда их содержимое. Следующая функция

    Fab {
      'A' e.Rest = 'B' <Fab e.Rest>;
      s.Other e.Rest = s.Other <Fab e.Rest>;
      /* пусто */ = /* пусто */;
    }

требует в списковой реализации линейного времени, в наивной массивной —
квадратичного. Менее наивные реализации могут выделять память с запасом, дабы
на следующей итерации не выделять новый кусок, а копировать значения рядом
с имеющимся. Например, для того же

    (e.X) (e.Y) = e.X e.Y;

если значению `e.Y` предшествует свободный участок более длинный, чем `e.X`,
значение `e.X` может быть скопировано туда. В случае функции `Fab` такая
стратегия может обеспечить и линейную сложность (но это не гарантируется).

Векторно-списковое представление Скоробогатова откладывает конкатенацию
до того момента, когда содержимое скобок (круглых или угловых) не станет
полностью пассивным. Функции в таком представлении принимают вектор (массив),
но возвращают список фрагментов вектора. Например, для правой части

    … = <F <G> 10 <H> 20>;

функции `G` и `H` сформируют некоторые списоки фрагментов вектора, которые
к моменту вызова `F` будут объединены (вместе с константами `10` и `20`)
в один сплошной массив. Рассмотренная выше функция `Fab` в векторно-списковой
реализации однозначно будет иметь линейное время работы.

Также можно представить себе реализации, использующие ropes ([раз][rope-habr],
[два][rope-ifmo]) — в них стоимость копирования и конкатенации будет равна
логарифму от длины выражений в термах, либо даже деки с конкатенацией,
предложенные Крисом Окасаки (см. [его книгу «Чисто функциональные структуры
данных», перевод gogabr’а][pdfs], последняя глава) — для них все операции имеют
амортизированное константное время (копирование, конкатенация, сопоставление
справа и слева). Но таких реализаций пока не создано, автор надеется
когда-нибудь провести такие исследования.


Компиляция Рефала-05 в Си и реализация рефал-машины
---------------------------------------------------

### Структуры данных поля зрения

Звено двусвязного списка выглядит так:

    enum r05_datatag {
      R05_DATATAG_ILLEGAL = 0,
      R05_DATATAG_CHAR,
      R05_DATATAG_FUNCTION,
      R05_DATATAG_NUMBER,

      R05_DATATAG_OPEN_BRACKET,
      R05_DATATAG_CLOSE_BRACKET,
      R05_DATATAG_OPEN_CALL,
      R05_DATATAG_CLOSE_CALL,
    };

    struct r05_node {
      struct r05_node *prev;
      struct r05_node *next;
      enum r05_datatag tag;
      union {
        char char_;
        struct r05_function *function;
        r05_number number;
        struct r05_node *link;
      } info;
    };

Структура узла состоит из четырёх полей: две ссылки вперёд (`next`) и назад
(`prev`), тип узла (`tag`) и поле информации (`info`), которое является
объединением. Актуальное поле объединения зависит от типа. Рассмотрим типы
подробнее.

* `R05_DATATAG_ILLEGAL` означает, что узел не инициализирован никак. Ни одно
  из полей `info` не актуально. Такие узлы могут встречаться в списке свободных
  узлов (см. далее), но их не может быть в поле зрения.
* `R05_DATATAG_CHAR` — литера, поле `info.char_`.
* `R05_DATATAG_FUNCTION` — указатель на функцию, `info.function`. Структуру
  `r05_function` мы рассмотрим ниже.
* `R05_DATATAG_NUMBER` — числов, `info.number`.
* `R05_DATATAG_OPEN_BRACKET`, `R05_DATATAG_CLOSE_BRACKET`,
  `R05_DATATAG_OPEN_CALL`, `R05_DATATAG_CLOSE_CALL` — соответственно, это
  `(`, `)`, `<`, `>`, актуальное поле `info.link`. О том, как оно используется,
  подробно написано выше.

Описатель функции — это структура, содержащая указатель на функцию и её имя:

    struct r05_function {
      r05_function_ptr ptr;
      const char *name;
    };

Значение числа — беззнаковое и длинное:

    typedef unsigned long r05_number;

Функция принимает первичное активное подвыражение — указатели на открывающую
и закрывающую скобки вызова функции, функция ничего не возвращает.

    typedef void (*r05_function_ptr) (
      struct r05_node *begin, struct r05_node *end
    );

Подробнее о функциях — в следующем параграфе.

В памяти программы на Рефале-05 присутствует два глобальных связанных списка.
Первый — это уже известное нам поле зрения, второй — список свободных узлов.
Поле зрения ограничено двумя глобальными (статическими) переменными

    static struct r05_node s_begin_view_field;
    static struct r05_node s_end_view_field;

Список свободных узлов ограничен

     static struct r05_node s_begin_free_list;
     static struct r05_node s_end_free_list;

Теги этих граничных узлов — `R05_DATATAG_ILLEGAL`. Узлы списков между этими
границами распределяются в динамической памяти во время выполнения программы.

На вершину стека угловых скобок поля зрения указывает переменная `s_stack_ptr`:

    static struct r05_node *s_stack_ptr;

В списке свободных узлов распределяется память для строящегося результатного
выражения, прежде чем попасть в поле зрения. Также, после завершения очередного
шага остатки первичного активного подвыражения наоборот переносятся из поля
зрения в список свободных узлов.

Новые элементы, как правило, распределяются в списке свободных узлов путём
переинициализации старых узлов, если старых узлов не хватает, новые
распределяются в динамической памяти, после чего помещаются в этот список.

Для просмотра содержимого списка свободных узлов в дампе нужно установить
макрос препроцессора Си `R05_DUMP_FREE_LIST` — см. [третий раздел][3].
Наблюдаемые в списке скобки обоих видов обычно не сбалансированы, ссылки
внутри них могут указывать на произвольные узлы поля зрения или списка
свободных узлов. Этот список — мусор, подлежащий переработке.

### Функции в сгенерированном коде

Каждая функция Рефала-05 компилируется в функцию на языке Си (с сигнатурой
`r05_function_ptr`) и описатель функции — структуру `r05_function`. Например,
функция

    $ENTRY Extern {
      e.Name = '$EXTERN ' e.Name ';\n';
    }

будет скомпилирована в

    static void r05c_Extern(struct r05_node *arg_begin, struct r05_node *arg_end) {
      r05_this_is_generated_function();

      do {
        struct r05_node *eName_b_1;
        struct r05_node *eName_e_1;
        struct r05_node *bb[1] = { 0 };
        struct r05_node *be[1] = { 0 };
        struct r05_node *n[1] = { 0 };
        r05_prepare_argument(bb+0, be+0, arg_begin, arg_end);
        /* e.Name */
        eName_b_1 = bb[0];
        eName_e_1 = be[0];

        r05_reset_allocator();
        r05_alloc_chars("$EXTERN ", 8);
        r05_alloc_insert_pos(n+0);
        r05_alloc_chars(";\n", 2);
        r05_splice_evar(n[0], eName_b_1, eName_e_1);
        r05_splice_from_freelist(arg_begin);
        r05_splice_to_freelist(arg_begin, arg_end);
        return;
      } while (0);
    }
    struct r05_function r05f_Extern = { r05c_Extern, "Extern" };

Имя функции на Си и описателя получается из имени исходной функции путём
замены в нём всех минусов `-` на прочерки `_` и добавлением префикса: `r05c_`
для функций и `r05f_` для описателей.

Компилируемая функция всегда имеет статическую область видимости, описатель
статический для локальных функций и нестатический для entry-функций.

И вообще, описатель первичен.

Очевидно, у всех пустых функций тело будет идентичным. Поэтому для них
применена оптимизация — тело функции не генерируется, описатель содержит
указатель на их общую реализацию. Так например,

    *$EENUM Success, Fails

будет скомпилировано в

    struct r05_function r05f_Success = { r05_enum_function_code, "Success" };
    struct r05_function r05f_Fails = { r05_enum_function_code, "Fails" };

Функция `r05_enum_function_code` при вызове вызывает ошибку отождествления
(recognition impossible) — всегда завершает выполнение программы с дампом поля
зрения.

Для каждой функции в исходном файле и для каждой используемой внешней функции
(включая и встроенные), в начале файла добавляется объявление её дескриптора:

    extern struct r05_function r05f_Mu;
    extern struct r05_function r05f_Div;
    extern struct r05_function r05f_Mod;
    extern struct r05_function r05f_Ord;
    extern struct r05_function r05f_Symb;
    extern struct r05_function r05f_Compare;
    extern struct r05_function r05f_R05_TextFromTree;
    extern struct r05_function r05f_Extern;
    extern struct r05_function r05f_Function;
    extern struct r05_function r05f_Entry;
    extern struct r05_function r05f_Local;
    extern struct r05_function r05f_Sentences;
    static struct r05_function r05f_TextFromSentence;
    extern struct r05_function r05f_Native;
    static struct r05_function r05f_FlatLines;
    extern struct r05_function r05f_Symbol;
    extern struct r05_function r05f_Char;
    extern struct r05_function r05f_Number;
    extern struct r05_function r05f_Name;
    extern struct r05_function r05f_Variable;
    extern struct r05_function r05f_Brackets;
    extern struct r05_function r05f_CallBrackets;
    extern struct r05_function r05f_TextFromExpr;
    static struct r05_function r05f_TextFromExpr_Char;
    static struct r05_function r05f_TextFromTerm;
    extern struct r05_function r05f_EscapeChar;
    static struct r05_function r05f_EscapeChar_Aux;
    static struct r05_function r05f_EscapeChar_SwCompare;
    static struct r05_function r05f_CharFromHex;

В отличие от C++, язык Си допускает многократное объявление статических
переменных в одном файле, важно только, чтобы инициализатор был только у одной
из них.

Символы-функции сравниваются на равенство по значению `info.function` —
указатели на дескрипторы должны совпадать. Поле `ptr` дескриптора используется
для вызова функции рефал-машиной, поле `name` для вывода имени функции функциями
вывода (`Prout`, `Putout`) или в дампе поля зрения.

### Компиляция предложений, общий вид

Непустые функции компилируются по следующему шаблону:

    static void r05c_FuncName(struct r05_node *arg_begin, struct r05_node *arg_end) {
      r05_this_is_generated_function();

      do {
        …
        код предложения 1
        …
        return;
      } while (0);

      do {
        …
        код предложения 2
        …
        return;
      } while (0);

      …

      r05_recognition_impossible();  /* может отсутствовать */
    }
    struct r05_function r05f_FuncName = { r05c_FuncName, "FuncName" };

Вызов `r05_this_is_generated_function();` добавляется в начало каждой функции,
написанной на Рефале — он сообщает профилировщику о том, что функция не нативная
(см. далее).

Вызов `r05_recognition_impossible();` в конце завершает программу с выдачей
сообщения об ошибке отождествления (recognition impossible) и аварийным дампом.
На него передаётся управление, если не было выполнено ни одно из предложений.
Если последнее предложение имеет вид `e.VarName = …;` то вызов
`r05_recognition_impossible();` в конце будет отсутствовать, поскольку в таком
предложении образец не может не сопоставиться (см. выше пример функции
`Extern`).

Каждое предложение состоит из трёх этапов:

1. **Сопоставление с образцом.** Если сопоставление выполнилось успешно,
   управление передаётся на следующий этап, если не успешно — на код, следующий
   за текущим предложением (следующее предложение или вызов
   `r05_recognition_impossible()`, если предложение было последним).
   При выполнении первого этапа поле зрения не изменяется.
2. **Распределение памяти.** В списке свободных узлов конструируется новое
   результатное выражение (за исключением переменных, которые переносятся,
   а не копируются). Если памяти не достаточно для конструирования результата,
   функции распределения памяти останавливают программу с выдачей сообщения
   `NO MEMORY` и аварийным дампом. При построении нового результатного выражения
   поле зрения также не меняется, поэтому в дампе будет виден неискажённый
   вызов упавшей функции.
3. **Сборка результатного выражения** всегда выполняется успешно, ничем
   не прерывается:
   * в сконструированное на втором этапе возвращаемое значение переносятся
     t- и e-переменные из вызова функции,
   * круглые скобки спариваются,
   * угловые скобки кладутся на стек в правильном порядке,
   * результат работы функции переносится из списка свободных узлов в поле
     зрения,
   * остатки первичного активного подвыражения переносятся в список свободных
     узлов,
   * выполняется возврат из функции (оператором `return;`).

Таким образом, в случае ошибки отождествления поле зрения и список свободных
узлов остаются неизменными. При ошибке распределения памяти поле зрения
неизменно, в списке свободных узлов может быть частично создан результат
работы функции. Когда поле зрения перестраивается, выполнение функции с выдачей
дампа прерваться не может. Такое соглашение упрощает для пользователя отладку
программы.

Встроенные функции Рефала-05, написанные на Си, тоже следуют этому соглашению:
если они прерывают программу с выдачей ошибки, поле зрения неизменно, когда
они перекраивают поле зрения, формируя возвращаемое значение, они прерваться
не могут. При написании собственных нативных функций рекомендуется поступать
также.

Псевдокод предложения без открытых переменных имеет вид

    do {
      объявления переменных
      /* сопоставление с образцом */
      if (! элементарное сопоставление)
        continue;
      if (! элементарное сопоставление)
        continue;
      …

      r05_reset_allocator();
      распределение памяти
      сборка результата
      return;
    } while (0);

Если одно из элементарных сопоставлений не удалось, оператор `continue;`
передаёт управление на следующую операцию с проверкой постусловия. Поскольку
в условии записан константный `0`, выполнение предложения прерывается.

Вызов `r05_reset_allocator();` подготавливает список свободных узлов
к распределению памяти (подробности далее) и уведомляет профилировщик,
что сопоставление с образцом закончилось и надо считать время построения
результатного выражения.

Каждая открытая переменная образует вложенный цикл:

    do {
      объявления переменных
      /* сопоставление с образцом */
      if (! элементарное сопоставление)
        continue;
      …
      /* цикл по открытой переменной e.X */
      e.X ← пустая
      r05_start_e_loop();
      do {
        сохранение диапазонов
        if (! элементарное сопоставление)
          continue;
        if (! элементарное сопоставление)
          continue;
        …
        /* цикл по другой открытой переменной e.Y */
        e.Y ← пустая
        r05_start_e_loop();
        do {
          сохранение диапазонов
          if (! элементарное сопоставление)
            continue;
          …

          r05_reset_allocator();
          распределение памяти
          сборка результата
          return;
        } while (r05_open_evar_advance(e.Y, её диапазон));
        r05_stop_e_loop();
      } while(r05_open_evar_advance(e.X, её диапазон));
      r05_stop_e_loop();
    } while (0);

Позже роль сохранения диапазонов будет рассмотрена подробнее, сейчас нам важно
другое. В тело цикла по e-переменной помещается весь остаток предложения. Если
последующие сопоставления выполняются успешно, цикл вместе со всем предложением
и всей функцией завершается оператором `return;`. Если одно из элементарных
сопоставлений не выполнилось, то оператор `continue;` перебрасывает на проверку
условия цикла, которая содержит вызов `r05_open_evar_andvance(…)`. Эта функция
пытается удлинить e-переменную на один терм. Если удаётся (возвращается истина),
выполняется следующая итерация, иначе — цикл завершается. Если завершился самый
внутренний цикл открытой переменной (в примере `e.Y`), управление передаётся
на условие внешнего цикла (в примере `e.X`), которая точно также пытается
удлиниться. Если завершился внешний цикл, то завершается и всё предложение.

Функция `r05_start_e_loop()`, вызов которой добавляется перед каждым циклом,
уведомляет профилировщик, что линейная часть сопоставления кончилась, и время
сопоставления с повторными переменными нужно считать отдельно.

Вызов `r05_stop_e_loop()` наоборот, сообщает профилировщику, что цикл
удлинения открытой переменной закончился: если образец, содержащий открытую
переменную не сопоставился, то время выполнения образца следующего предложения
должно будет считаться как линейное.

### Компиляция сопоставления с образцом

Код для сопоставления с образцом генерируется в терминах диапазонов, в точности,
как было описано в первой главе. Каждый диапазон описывается парой указателей
на первый и последний узел участка аргумента, если диапазон пустой, то оба
указателя равны нулю. Команды сопоставления приводят к сдвигу одного из них.

Если сопоставление внутри цикла по открытой переменной терпит неудачу,
то на следующей итерации границы диапазонов должны вернуться к исходному
положению. Чтобы этого достичь, в начале каждой итерации создаются копии
диапазонов и меняются именно они.

В примерах ниже команды сопоставления мы будем обозначать как `Bn → Bn X`
или `Bn → X Bn`, где `Bn` — это диапазон с номером `n`, `X` — сопоставляемый
элемент. Команды сохранения диапазонов будем обозначать как `Bj ← Bi`, где
`Bj` — новый, а `Bi` — старый диапазон. Цикл по открытой переменной в диапазоне
`n` будем обозначать как `CYCLE(Bn → e.X Bn)`.

**Пример.** Рассмотрим тот же пример, что и в предыдущей главе:

    (e.Name) e.Values-B ((e.Name) e.Value) e.Values-E

Инициализируем нулевой диапазон:

    0:[(e.Name) e.Values-B ((e.Name) e.Value) e.Values-E]

Диапазон начинается скобочным термом. Порождаем команду сопоставления и создаём
новый диапазон:

    B0 → (B1) B0
    1:[e.Name], 0:[e.Values-B ((e.Name) e.Value) e.Values-E]

Есть диапазон, состоящий из одной e-переменной. Генерируем команду сопоставления
с закрытой переменной, вычёркиваем диапазон:

    B1 → e.Name
    0:[e.Values-B ((e.Name) e.Value) e.Values-E]

Есть диапазон, который начинается с открытой переменной, генерируем заголовок
цикла, сохраняем диапазоны внутри цикла:

    CYCLE(B0 → e.Values-B B0)
    0:[((e.Name) e.Value) e.Values-E]

    B2 ← B0
    2:[((e.Name) e.Value) e.Values-E]

Есть диапазон, который начинается со скобочного терма:

    B2 → (B3) B2
    3:[(e.Name) e.Value], 2:[e.Values-E]

Опять есть диапазон, который начинается со скобочного терма:

    B3 → (B4) B3
    4:[e.Name], 3:[e.Value], 2:[e.Values-E]

Есть диапазон, который начинается с повтороной переменной:

    B4 → e.Name B4 /* повторная */
    4:[ε], 3:[e.Value], 2:[e.Values-E]

Есть пустой диапазон, строим команду сопоставления, удаляем диапазон:

    B4 → ε
    3:[e.Value], 4:[e.Values-E]

Два диапазона с закрытыми переменными:

    B3 → e.Value
    4:[e.Values-E]

    B4 → e.Values-E
    нет диапазонов

Диапазоны кончились, мы построли последовательность команд отождествления:

    B0 → (B1) B0
    B1 → e.Name
    CYCLE(B0 → e.Values-B B0) {
      B2 ← B0
      B2 → (B3) B2
      B3 → (B4) B3
      B4 → e.Name B4 /* повторная */
      B4 → ε
      B3 → e.Value
      B4 → e.Values-E

      построение правой части
      return;
    }

**Пример.** Другой пример из предыдущей главы, с двумя циклами:

    (e.Set1-B t.Common e.Set1-E) (e.Set2-B t.Common e.Set2-E)

Строим нулевой диапазон и начинаем отождествление:

    0:[(e.Set1-B t.Common e.Set1-E) (e.Set2-B t.Common e.Set2-E)]

    B0 → (B1) B0
    1:[e.Set1-B t.Common e.Set1-E], 0:[(e.Set2-B t.Common e.Set2-E)]

    B0 → (B2) B0
    1:[e.Set1-B t.Common e.Set1-E], 2:[e.Set2-B t.Common e.Set2-E], 0:[ε]

    B0 → ε
    1:[e.Set1-B t.Common e.Set1-E], 2:[e.Set2-B t.Common e.Set2-E]

Есть два диапазона, оба начинаются на e-переменную. Выбираем ту переменную,
которая в записи левой части левее, по ней строим цикл. В цикле сохраняем
позиции диапазонов:

    CYCLE(B1 → e.Set1-B B1)
    1:[t.Common e.Set1-E], 2:[e.Set2-B t.Common e.Set2-E]

    B3 ← B1
    3:[t.Common e.Set1-E], 2:[e.Set2-B t.Common e.Set2-E]

    B4 ← B2
    3:[t.Common e.Set1-E], 4:[e.Set2-B t.Common e.Set2-E]

T-переменная слева, закрытая переменная:

    B3 → t.Common B3
    3:[e.Set1-E], 4:[e.Set2-B t.Common e.Set2-E]

    B3 → e.Set1-E
    4:[e.Set2-B t.Common e.Set2-E]

Открытая переменная `e.Set2-B`, повторная t-переменная, закрытая переменная:

    CYCLE(B4 → e.Set2-B B4)
    4:[t.Common e.Set2-E]

    B5 ← B4
    5:[t.Common e.Set2-E]

    B5 → t.Common B5 /* повторная */
    5:[e.Set2-E]

    B5 → e.Set2-E

Сопоставление завершено. Получается такая последовательность элементарных
команд сопоставления:

    B0 → (B1) B0
    B0 → (B2) B0
    B0 → ε
    CYCLE(B1 → e.Set1-B B1) {
      B3 ← B1
      B4 ← B2
      B3 → t.Common B3
      B3 → e.Set1-E
      CYCLE(B4 → e.Set2-B B4) {
        B5 ← B4
        B5 → t.Common B5 /* повторная */
        B5 → e.Set2-E

        постороение правой части
        return;
      }
    }

На этом примере становится видно, зачем же нужно сохранять диапазоны.
С сохранением `B1` и `B4` более-менее понятно — они участвуют в управлении
циклом, поэтому к ним может быть какое-то особое отношение. Но зачем сохранять
`B2`? Затем, что для каждого возможного удлинения `e.Set1-B` мы должны
перебрать все возможные удлинения и `e.Set2-B`, а значит, диапазон, по которой
она «движется» на начало следующей итерации должен быть тем же, что
и на предыдущей.

Следующий пример нагляднее демонстрирует необходимость сохранения диапазонов.

**Пример.** Построим код для отождествления с образцом

    e.Begin (e.Inner) e.End (e.Left 'X' e.Inner)

Вводим нулевой диапазон, видим скобки справа:

    0:[e.Begin (e.Inner) e.End (e.Left 'X' e.Inner)]

    B0 → B0 (B1)
    0:[e.Begin (e.Inner) e.End], 1:[e.Left 'X' e.Inner]

Оба диапазона начинаются на e-переменную. Самую левую из них `e.Begin`
назначаем открытой и строим цикл её удлинения:

    CYCLE(B0 → e.Begin)
    0:[(e.Inner) e.End], 1:[e.Left 'X' e.Inner]

    B2 ← B0
    2:[(e.Inner) e.End], 1:[e.Left 'X' e.Inner]

    B3 ← B1
    2:[(e.Inner) e.End], 3:[e.Left 'X' e.Inner]

    B2 → (B4) B2
    4:[e.Inner], 2:[e.End], 3:[e.Left 'X' e.Inner]

    B4 → e.Inner /* закрытая */
    2:[e.End], 3:[e.Left 'X' e.Inner]

    B2 → e.End /* закрытая */
    3:[e.Left 'X' e.Inner]

Переменная `e.Inner` уже получила значение, а значит, здесь не цикл.

    B3 → B3 e.Inner /* повторная */
    3:[e.Left 'X']

    B3 → B3 'X'
    3:[e.Left 'X']

    B3 → e.Left /* закрытая */
    нет диапазонов

Запишем код сопоставления полностью:

    B0 → B0 (B1)
    CYCLE(B0 → e.Begin) {
      B2 ← B0
      B3 ← B1
      B2 → (B4) B2
      B4 → e.Inner /* закрытая */
      B2 → e.End /* закрытая */
      B3 → B3 e.Inner /* повторная */
      B3 → B3 'X'
      B3 → e.Left /* закрытая */

      построение результата
      return;
    }

Посмотрим, что бы было бы, если бы диапазон `B3 ← B1` не сохранялся:

    /* ЗДЕСЬ ОШИБКА */
    B0 → B0 (B1)
    CYCLE(B0 → e.Begin) {
      B2 ← B0
      /* диапазон B1 не сохраняется */
      B2 → (B4) B2
      B4 → e.Inner /* закрытая */
      B2 → e.End /* закрытая */
      B1 → B1 e.Inner /* повторная */
      B1 → B1 'X'
      B1 → e.Left /* закрытая */

      построение результата
      return;
    }

Допустим, на первой итерации сопоставление `B1 → B1 e.Inner` выполнилось
успешно, но `B1 → B1 'X'` не удалось. Тогда на следующем витке цикла диапазон
`B1` имел бы не исходное значение, а видоизменённое. Сопоставление выражения

    ('er') ('super') ('super') ('abba' 'X' 'super')

с

    e.Begin (e.Inner) e.End (e.Left 'X' e.Inner)

успешно, получаем подстановку

    ('er') ← e.Begin
    'super' ← e.Inner
    ('super') ← e.End
    'abba' ← e.Left

Если проследить выполнение правильного варианта, то такую подстановку и получим.
Если проследить выполнение ошибочного варианта (без сохранения `B1`), то получим
невозможность отождествления.

**Примечание.** В самой первой версии Простого Рефала 001 была такая ошибка —
сохранялся только диапазон, от которого отделяется открытая переменная. Пример
выше с `('er') ('super') ('super') ('abba' 'X' 'super')` был тестом, который
демонстрировал эту ошибку. Ошибка была исправлена в следующей версии, 002.
На эту ошибку есть автотест `evar-loops-nested.ref`.


[2]: 2-syntax.md
[3]: 3-install-and-usage.md
[5]: 5-implementation.md
[alushta]: https://pat.keldysh.ru/~roman/doc/Turchin/1972-Turchin--E'kvivalentnye_preobrazovaniya_rekursivnyx_funkcij__opisannyx_na_yazyke_Refal--facsimile--ru.pdf
[flac]: http://www.botik.ru/pub/local/scp/flac/fl_impl.pdf
[eisymont]: https://pat.keldysh.ru/~roman/doc/Turchin/1987-Mansurov_Eisymont--Realizaciya_rasshirennogo_yazyka_Refal_na_odnosvyaznyx_spiskax.pdf
[plus]: https://pat.keldysh.ru/~roman/doc/2006-Gurin_Romanenko--Yazyk_programmirovaniya_Refal_Plyus--ru.pdf
[refalj]: http://refal.ru/~arklimov/refal6/refal-j.htm
[rope-habr]: https://habr.com/post/144736/
[rope-ifmo]: http://neerc.ifmo.ru/wiki/index.php?title=Rope
[pfds]: https://github.com/gogabr/pfds
