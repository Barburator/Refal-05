Реализация: списковое представление и интерфейс с языком Си
===========================================================

В этом разделе будет описано, как отображаются высокоуровневые конструкции
Рефала-05 (данные — объектные выражения, рефал-машина, сопоставление с образцом
и т.д.) на более низкоуровневые понятия компьютера, выраженные в терминах
языка Си.

В первой главе раздела мы рассмотрим списковое представление поля зрения —
способ построения данных Рефала в виде двусвязных списков, не опускаясь
в технические подрнобности. Эту главу рекомендуется прочитать всем,
поскольку изложенные в ней сведения нужны, чтобы писать эффективные программы
для данной реализации. Последующие главы будут необходимы лишь для разработки
нативных функций и для доработки самого компилятора.

Во второй главе будут обсуждаться структуры данных поля зрения уже в терминах
языка Си, реализация рефал-машины и идеология компиляции функций на Рефале
в целевой код. После прочтения этой главы содержимое порождаемых компилятором
файлов на Си станет частично понятным. В этой главе кратко и между делом
будут затронуты некоторые API-функции рантайма.

Третья глава является уже руководством по написанию нативных функций Рефала-05,
т.е. функций, тело которых описывается не на Рефале, а на Си. Будет описан
синтаксис для написания таких функций и детально описано API рантайма.


Что это значит — списковая реализация Рефала?
---------------------------------------------

Как было сказано [в разделе 2][2], рассматриваемая реализация действительно
моделирует работу рефал-машины. Это значит, что в памяти программы на Рефале
представлено каким-то образом поле зрения, которое переписывается по шагам.
[В разделе 5][5], в частности, рассказывается, что содержимое поля зрения можно
увидеть при аварийной остановке программы, либо на каждом шаге, откомпилировав
программу с особыми ключами.

Актуальная реализация представляет поле зрения в виде двусвязного списка —
структуры данных, состоящих из узлов (звеньев), каждое из которых содержит
ссылки (указатели) на следующее звено и предыдущее. Каждое звено такого списка
представляет либо символ (литеру, число или функцию), либо скобку (`(`, `)`,
`<`, `>`). Узлы-символы хранят значения символов (соответственно, значение
литеры, число или указатель на представление функции), узлы-скобки хранят
указатели на другие узлы-скобки.

Узлы, соответствующие круглым скобкам, хранят указатели на сопряжённые скобки:
открывающая `(` содержит указатель на узел, содержащий парную ей `)` и наоборот.
Благодаря этому сопоставление выражения с образцом вида `(…) …` или `… (…)`
выполняется за константное время. Если образец начинается на круглую скобку,
то следуя по указателю в ней, легко найти парную скобку и затем продолжить
сопоставление частей образца внутри и после скобок.

С угловыми скобками хитрее. Как мы помним [из раздела 2][2], рефал-машина
должна находить на каждом шаге очередное первичное активное подвыражение —
самую левую пару угловых скобок, не содержащую внутри себя других скобок.
Указатели, хранимые в угловых скобках, позволяют находить его за небольшое
константное время, избегая полного просмотра поля зрения.

Что значит, найти первичное активное подвыражение? Это значит, что нужно
получить указатели на искомые угловые скобки — между ними будет находиться
имя функции и её аргумент.

Открывающие угловые скобки, также как и круглые, содержат ссылки на парные
им закрывающие. Это позволяет, найдя левую скобку, сразу зафиксировать парную
ей. Каждая закрывающая угловая скобка содержит указатель на ту открывающую
скобку, которая активируется после текущей. Указатель на левую угловую скобку
первичного активного подвыражения хранится в глобальной переменной рантайма
`s_stack_ptr`. Последняя правая угловая скобка ссылается на `NULL`. Таким
образом, скобки активации провязаны в односвязный список. Выглядит это так:


```
s_stack_ptr ────┐
  ┌─────────────┼───────────────────────────────────────────────────────┐
  │             │                    ┌───────────────────────────┐      │     NULL
  │             │             ┌──────┼─────────────┐             │      │      ↑
  ↓             ↓             │      ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ G ║←→║ > ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             │             ↑      ↑      ↑
  │             └─────────────┘      │             └─────────────┘      │      │
  │                                  └──────────────────────────────────┘      │
  └────────────────────────────────────────────────────────────────────────────┘
```

Первичное активное подвыражение в этом примере `<G>`, на его левую скобку
указывает глобальная переменная `g_stack_ptr`, правую угловую скобку
рефал-машина найдёт, если проследует по указателю из левой скобки. При вызове
функции `G` первичное активное подвыражение будет снято со стека (изъято
из односвязного списка) и переменная `s_stack_ptr` будет указывать на следующую
пару скобок вызова `<I>`. Если вызов `<G>` заменится на пустоту, то поле зрения
приобретёт следующий вид:


```
s_stack_ptr ──────────────────┐
  ┌───────────────────────────┼────────────────────┐     NULL
  │             ┌─────────────┼─────────────┐      │      ↑
  ↓             ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             │             ↑      ↑      ↑
  │             │             └─────────────┘      │      │
  │             └──────────────────────────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Допустим, вызов `<I>` тоже вычислился в пустоту:

```
s_stack_ptr ────┐
  ┌─────────────┼─────────────┐     NULL
  ↓             ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      ↑
  │             └─────────────┘      │
  └──────────────────────────────────┘
```

Если вызов функции заменяется на выражение с новыми скобками активации, то они
тоже добавляются в стек. Пусть вызов `<H>` заменяется на `<K> <L>`.

```
s_stack_ptr                                              NULL
  ↓                                                       ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │                                                       ↑
  └───────────────────────────────────────────────────────┘
```

На стек сначала будет положена пара скобок вокруг `L`, затем, вокруг `K`:

```
s_stack_ptr ────┐
  ┌─────────────┼──────────────────────────────────┐
  │             │             ┌──────┐             │     NULL
  ↓             ↓             │      ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             ↑      ↑
  │             └─────────────┘      └─────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Таким образом, ссылки в угловых скобках позволяют эффективно находить первичное
активное подвыражение в поле зрения.



[2]: 2-syntax.md
[5]: 5-implementation.md
