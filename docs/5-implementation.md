Реализация: списковое представление и интерфейс с языком Си
===========================================================

В этом разделе будет описано, как отображаются высокоуровневые конструкции
Рефала-05 (данные — объектные выражения, рефал-машина, сопоставление с образцом
и т.д.) на более низкоуровневые понятия компьютера, выраженные в терминах
языка Си.

В первой главе раздела мы рассмотрим списковое представление поля зрения —
способ построения данных Рефала в виде двусвязных списков, не опускаясь
в технические подрнобности. Эту главу рекомендуется прочитать всем,
поскольку изложенные в ней сведения нужны, чтобы писать эффективные программы
для данной реализации. Последующие главы будут необходимы лишь для разработки
нативных функций и для доработки самого компилятора.

Во второй главе будут обсуждаться структуры данных поля зрения уже в терминах
языка Си, реализация рефал-машины и идеология компиляции функций на Рефале
в целевой код. После прочтения этой главы содержимое порождаемых компилятором
файлов на Си станет частично понятным. В этой главе кратко и между делом
будут затронуты некоторые API-функции рантайма.

Третья глава является уже руководством по написанию нативных функций Рефала-05,
т.е. функций, тело которых описывается не на Рефале, а на Си. Будет описан
синтаксис для написания таких функций и детально описано API рантайма.


Что это значит — списковая реализация Рефала?
---------------------------------------------

### Представление поля зрения при помощи двусвязных списков

Как было сказано [в разделе 2][2], рассматриваемая реализация действительно
моделирует работу рефал-машины. Это значит, что в памяти программы на Рефале
представлено каким-то образом поле зрения, которое переписывается по шагам.
[В разделе 5][5], в частности, рассказывается, что содержимое поля зрения можно
увидеть при аварийной остановке программы, либо на каждом шаге, откомпилировав
программу с особыми ключами.

Актуальная реализация представляет поле зрения в виде двусвязного списка —
структуры данных, состоящих из узлов (звеньев), каждое из которых содержит
ссылки (указатели) на следующее звено и предыдущее. Каждое звено такого списка
представляет либо символ (литеру, число или функцию), либо скобку (`(`, `)`,
`<`, `>`). Узлы-символы хранят значения символов (соответственно, значение
литеры, число или указатель на представление функции), узлы-скобки хранят
указатели на другие узлы-скобки.

Узлы, соответствующие круглым скобкам, хранят указатели на сопряжённые скобки:
открывающая `(` содержит указатель на узел, содержащий парную ей `)` и наоборот.
Благодаря этому сопоставление выражения с образцом вида `(…) …` или `… (…)`
выполняется за константное время. Если образец начинается на круглую скобку,
то следуя по указателю в ней, легко найти парную скобку и затем продолжить
сопоставление частей образца внутри и после скобок.

С угловыми скобками хитрее. Как мы помним [из раздела 2][2], рефал-машина
должна находить на каждом шаге очередное первичное активное подвыражение —
самую левую пару угловых скобок, не содержащую внутри себя других скобок.
Указатели, хранимые в угловых скобках, позволяют находить его за небольшое
константное время, избегая полного просмотра поля зрения.

Что значит, найти первичное активное подвыражение? Это значит, что нужно
получить указатели на искомые угловые скобки — между ними будет находиться
имя функции и её аргумент.

Открывающие угловые скобки, также как и круглые, содержат ссылки на парные
им закрывающие. Это позволяет, найдя левую скобку, сразу зафиксировать парную
ей. Каждая закрывающая угловая скобка содержит указатель на ту открывающую
скобку, которая активируется после текущей. Указатель на левую угловую скобку
первичного активного подвыражения хранится в глобальной переменной рантайма
`s_stack_ptr`. Последняя правая угловая скобка ссылается на `NULL`. Таким
образом, скобки активации провязаны в односвязный список. Выглядит это так:


```
s_stack_ptr ────┐
  ┌─────────────┼───────────────────────────────────────────────────────┐
  │             │                    ┌───────────────────────────┐      │     NULL
  │             │             ┌──────┼─────────────┐             │      │      ↑
  ↓             ↓             │      ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ G ║←→║ > ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             │             ↑      ↑      ↑
  │             └─────────────┘      │             └─────────────┘      │      │
  │                                  └──────────────────────────────────┘      │
  └────────────────────────────────────────────────────────────────────────────┘
```

Первичное активное подвыражение в этом примере `<G>`, на его левую скобку
указывает глобальная переменная `g_stack_ptr`, правую угловую скобку
рефал-машина найдёт, если проследует по указателю из левой скобки. При вызове
функции `G` первичное активное подвыражение будет снято со стека (изъято
из односвязного списка) и переменная `s_stack_ptr` будет указывать на следующую
пару скобок вызова `<I>`. Если вызов `<G>` заменится на пустоту, то поле зрения
приобретёт следующий вид:


```
s_stack_ptr ──────────────────┐
  ┌───────────────────────────┼────────────────────┐     NULL
  │             ┌─────────────┼─────────────┐      │      ↑
  ↓             ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             │             ↑      ↑      ↑
  │             │             └─────────────┘      │      │
  │             └──────────────────────────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Допустим, вызов `<I>` тоже вычислился в пустоту:

```
s_stack_ptr ────┐
  ┌─────────────┼─────────────┐     NULL
  ↓             ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      ↑
  │             └─────────────┘      │
  └──────────────────────────────────┘
```

Если вызов функции заменяется на выражение с новыми скобками активации, то они
тоже добавляются в стек. Пусть вызов `<H>` заменяется на `<K> <L>`.

```
s_stack_ptr                                              NULL
  ↓                                                       ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │                                                       ↑
  └───────────────────────────────────────────────────────┘
```

На стек сначала будет положена пара скобок вокруг `L`, затем, вокруг `K`:

```
s_stack_ptr ────┐
  ┌─────────────┼──────────────────────────────────┐
  │             │             ┌──────┐             │     NULL
  ↓             ↓             │      ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             ↑      ↑
  │             └─────────────┘      └─────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Таким образом, ссылки в угловых скобках позволяют эффективно находить первичное
активное подвыражение в поле зрения.

### Зачем это нужно программисту: эффективность отдельных операций

Когда рефал-машина передаёт управление функции, она получает пару указателей
на угловые скобки, ограничивающие первичное активное подвыражение. Функция
должна будет выделить из этого выражения аргумент (отбросив скобки вызова
и своё имя), последовательно сопоставить аргумент с каждым из образцов, и для
первого подошедшего образца построить результат по шаблону в правой части.

**Примечание.** Из соображений минимализма текущая реализация Рефала-05
выполняет сопоставление аргумента с каждым из образцов независимо — при
переходе к следующему забывает о том, какие операции сопоставления в предыдущих
образцах уже выполнялись.

Сопоставление с образцом разбивается на последовательность элементарных
операций: сопоставления со скобками, символами, переменными. Общий принцип
следующий. В процессе сопоставления отслеживается один или несколько
_диапазонов_ — ещё не проанализированных участков аргумента и соответствующих
им участков образца. Сопоставление начинается с того, что единственным
диапазоном объявляется весь аргумент и весь образец. Действия в последующих
абзацах повторяются до тех пор, пока не останется ни одного диапазона.

Если есть диапазон, образец которого начинается или заканчивается символом,
проверяется, что этот участок аргумента не пустой и начинается или заканчивается
тем же символом. Символ вычёркивается из диапазона образца. Сопоставление
с символами выполняется за малое константное время.

Иначе, если есть диапазон, который начинается (заканчивается) скобочным термом,
проверяется, что аргумент начинается (заканчивается) на круглую скобку, по ссылке
находится парная ей скобка, из диапазона удаляется скобочный терм, создаётся
новый диапазон, соответствующий содержимому скобок. Сопоставление со скобочным
термом выполняется за константное время.

Иначе, если есть диапазон с пустым образцом — проверяется, что участок аргумента
тоже пустой. Диапазон удаляется. Сопоставление с пустотой выполняется
за константное время.

Иначе, если есть диапазон, который начинается (кончается) на переменную, которая
уже получила своё значение, проверяется, что участок аргумента тоже начинается
(заканчивается) на это же значение. Переменная вычёркивается из диапазона.
Переменные, сопоставляемые в таких случаях, называются _повторными._
Сопоставления с s-переменными выполняются за константное время, не зависящее
от значения переменной, поскольку значением может быть либо литера (`char`),
либо число (`long int`), либо имя функции (указатель). Сопоставление с t- и
e-переменными выполняются за время, пропорциональное числу узлов в их значениях.

**Интересное примечание.** Заметим, что значением t- и e-переменной является
плоский двусвязный список, поэтому для сравнения на равенство достаточно
последовательного просмотра в простом цикле. Рекурсивных вызовов для сравнения
содержимого скобок не нужно, а это значит, что глубина вложенности скобок
ограничена лишь размером поля зрения. В других реализациях Рефала сравнение
на равенство может требовать рекурсию, а значит, и системный стек.

Иначе, если есть диапазон, состоящий из одной e-переменной, ещё не получившей
своего значения, переменная связывается с соответствующим участком аргумента.
Такая e-переменная называется _закрытой._ Диапазон удаляется. Сопоставление
с закрытой переменной всегда успешно и выполняется за константное время.

Иначе, если есть диапазон, начинающийся (заканчивающийся) на s- или
t-переменную, то от участка аргумента отделяется символ или терм и связывается
с переменной (переменная здесь ещё не связана, поскольку проверка на повторные
переменные выполняется раньше). Переменная вычёркивается из диапазона.
Связывание новой s- или t-переменной выполняется за константное время.

Если ни одно из перечисленных условий не выполнилось, то или не осталось
ни одного диапазона, или все диапазоны имеют вид `e.X … e.Y`, где e-переменные
ещё не получили своего значения. Самая первая несвязанная e-переменная в записи
левой части предложения (она же первая переменная самого левого диапазона)
объявляется _открытой._ Она последовательно связывается с префиксом участка
аргумента длиной 0, 1, 2… терма и для каждого её значения продолжается
сопоставление с образцом до тех пор, пока не найдётся первое удачное
сопоставление. Иначе говоря, остальная часть образца помещается _в цикл_ по всем
допустимым длинам открытой e-переменной. Переменная вычёркивается из диапазона.
Выбор каждого следующего значения выполняется за константное время (просто
сдвигается указатель на начало следующего терма), но надо понимать, что все
последующие операции выполняются в этом цикле.

Таким образом, если в образце есть одна открытая переменная — время
сопоставления со всем образцом будет линейно зависеть от длины (в термах)
соответствующего участка аргумента, две открытые переменные дадут квадратичные
затраты времени (произведение количества удлинений первой переменной
на количество для второй).

**Пример.** Рассмотрим сопоставление с образцом

    (e.Name) e.Values-B ( (e.Name) e.Value ) e.Values-E
    1 2    3  4         5 6 7    8  9     10  11

Элементы образца пронумерованы для того, чтобы ссылаться на них в тексте.
Перечислим операции сопоставления, которые будут выполняться для этого образца
(если о временны́х затратах не говорится, то подразумевается константа).

* Сопоставление с парой скобок 1, 3.
* Сопоставление с закрытой переменной `e.Name` (2).
* Мы имеем диапазон вида `e.Values-B … e.Values-E`. Переменная `e.Values-B` (4)
  объявляется открытой. Последующие операции выполняются в цикле для всех
  возможных длин `e.Values-B` (числу термов диапазона):
  * Сопоставление со скобочным термом 5, 10.
  * Сопоставление со скобочным термом 6, 8.
  * Сопоставление с повторной переменной `e.Name` (7) слева. От диапазона внутри
    скобок 6, 8 отделяется префикс, равный значению переменной `e.Name` (2).
    Время сопоставления пропорционально длине совпадающей части известного
    значения переменной и диапазона, сверху ограничено длиной `e.Name` (2)
    в узлах списка.
  * Сопоставление диапазона между `e.Name` (7) и закрывающей скобкой 8
    с пустотой.
  * Сопоставление с закрытой переменной `e.Value` (9).
  * Сопоставление с закрытой переменной `e.Values-E` (11).

Время сопоставления с этим образцом пропорционально произведению длины в узлах
переменной `e.Name` и длины участка `e.Values-B … e.Values-E` в термах. Вернее,
ограничено сверху этой величиной.

**Пример.** Рассмотрим сопоставление с образцом

    (e.Set1-B t.Common e.Set1-E) (e.Set2-B t.Common e.Set2-E)
    1 2        3        4      5 6 7        8        9     10

Операции сопоставления:

* Сопоставление со скобочным термом 1, 5.
* Сопоставление со скобочным термом 6, 10.
* Сопоставление с пустым диапазоном.
* Цикл по открытой переменной `e.Set1-B` (2):
  * Сопоставление с переменной `t.Common` (3), переменная получает значение.
  * Цикл по открытой переменной `e.Set2-B` (7):
    * Сопоставление с повторной переменной `t.Common` (8). Время сопоставления
      пропорционально длине `t.Common` (3) в узлах списка.
    * Сопоставление с закрытой переменной `e.Set1-E` (4).
    * Сопоставление с закрытой переменной `e.Set2-E` (9).

Время сопоставления пропорционально произведению длин (в термах) содержимого
обоих скобочных термов и длины повторной переменной `t.Common` (в узлах списка).

**Важный вывод.** Если образец содержит открытые переменные или повторные t-
и e-переменные, то время сопоставления с ним зависит от значений этих переменных.
В остальных случаях время сопоставления зависит только от вида образца.

**Кстати,** образцы без открытых переменных и повторных t- и e-переменных
в теории метавычислений над Рефалом называются _L-выражениями._ Для функций,
все предложения которых являются L-выражениями, можно определить простую
и выразительную систему эквивалентных преобразований (см. например,
[здесь][alushta]).

**Примечание.** Можно придумать реализации, в которых эти операции сопоставления
были бы гораздо быстрее. Например, если для всех скобочных термов хранить
глобальную хеш-таблицу, и при создании нового терма проверять, есть ли такой же
в таблице, то сравнение одноимённых t-переменных будет выполняться
за константное время. Если для каждого объектного выражения, которое строится
в программе, поддерживать суффиксное дерево, то поиск по открытым переменным
также мог быть эффективнее линейного просмотра. Идея использования суффиксных
деревьев в Рефале предложена Скоробогатовым С. Ю. \[частное сообщение].

В результате успешного сопоставления с образцом переменные предложения
получают свои значения. E-переменные представляются парой указателей на начало
и конец (для пустых переменных они оба равны нулю), s-переменные представляются
указателем на узел, t-переменные — на первое звено значения (символ или левую
круглую скобку). Если переменная входит в образец несколько раз (является
_повторной,)_ то для неё запоминаются все вхождения. Например, если переменная
`e.X` входила в образец 3 раза, то все её вхождения будут сохранены в трёх
парах указателей.

Построить результат — это значит, построить двусвязный список, на который
следует заменить первичное активное подвыражение в поле зрения,
и, собственно, выполнить эту замену. При этом, само первичное активное
подвыражение уже становится ненужным, а это значит, что оттуда можно взять
готовые фрагменты результата. Текущая реализация, однако, берёт оттуда только
значения e- и t-переменных (s-переменные дешевле построить заново).

Но в некоторых случаях e- и t-переменные приходится копировать — без копии
не обойтись, если в правой части предложения некоторая переменная имеет больше
вхождений, чем в левую. Например, для предложения

    t.SymTable (e.Name) e.Name =
      <Lookup t.SymTable e.Name> '+' <Lookup t.SymTable e.Name>

переменную `t.SymTable` придётся скопировать, в то время как `e.Name` — нет.



[2]: 2-syntax.md
[5]: 5-implementation.md
[alushta]: https://pat.keldysh.ru/~roman/doc/Turchin/1972-Turchin--E'kvivalentnye_preobrazovaniya_rekursivnyx_funkcij__opisannyx_na_yazyke_Refal--facsimile--ru.pdf
