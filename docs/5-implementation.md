Реализация: списковое представление и интерфейс с языком Си
===========================================================

В этом разделе будет описано, как отображаются высокоуровневые конструкции
Рефала-05 (данные — объектные выражения, рефал-машина, сопоставление с образцом
и т.д.) на более низкоуровневые понятия компьютера, выраженные в терминах
языка Си.

В первой главе раздела мы рассмотрим списковое представление поля зрения —
способ построения данных Рефала в виде двусвязных списков, не опускаясь
в технические подрнобности. Эту главу рекомендуется прочитать всем,
поскольку изложенные в ней сведения нужны, чтобы писать эффективные программы
для данной реализации. Последующие главы будут необходимы лишь для разработки
нативных функций и для доработки самого компилятора.

Во второй главе будут обсуждаться структуры данных поля зрения уже в терминах
языка Си, реализация рефал-машины и идеология компиляции функций на Рефале
в целевой код. После прочтения этой главы содержимое порождаемых компилятором
файлов на Си станет частично понятным. В этой главе кратко и между делом
будут затронуты некоторые API-функции рантайма.

Третья глава является уже руководством по написанию нативных функций Рефала-05,
т.е. функций, тело которых описывается не на Рефале, а на Си. Будет описан
синтаксис для написания таких функций и детально описано API рантайма.


Что это значит — списковая реализация Рефала?
---------------------------------------------

### Представление поля зрения при помощи двусвязных списков

Как было сказано [в разделе 2][2], рассматриваемая реализация действительно
моделирует работу рефал-машины. Это значит, что в памяти программы на Рефале
представлено каким-то образом поле зрения, которое переписывается по шагам.
[В разделе 5][5], в частности, рассказывается, что содержимое поля зрения можно
увидеть при аварийной остановке программы, либо на каждом шаге, откомпилировав
программу с особыми ключами.

Актуальная реализация представляет поле зрения в виде двусвязного списка —
структуры данных, состоящих из узлов (звеньев), каждое из которых содержит
ссылки (указатели) на следующее звено и предыдущее. Каждое звено такого списка
представляет либо символ (литеру, число или функцию), либо скобку (`(`, `)`,
`<`, `>`). Узлы-символы хранят значения символов (соответственно, значение
литеры, число или указатель на представление функции), узлы-скобки хранят
указатели на другие узлы-скобки.

Узлы, соответствующие круглым скобкам, хранят указатели на сопряжённые скобки:
открывающая `(` содержит указатель на узел, содержащий парную ей `)` и наоборот.
Благодаря этому сопоставление выражения с образцом вида `(…) …` или `… (…)`
выполняется за константное время. Если образец начинается на круглую скобку,
то следуя по указателю в ней, легко найти парную скобку и затем продолжить
сопоставление частей образца внутри и после скобок.

С угловыми скобками хитрее. Как мы помним [из раздела 2][2], рефал-машина
должна находить на каждом шаге очередное первичное активное подвыражение —
самую левую пару угловых скобок, не содержащую внутри себя других скобок.
Указатели, хранимые в угловых скобках, позволяют находить его за небольшое
константное время, избегая полного просмотра поля зрения.

Что значит, найти первичное активное подвыражение? Это значит, что нужно
получить указатели на искомые угловые скобки — между ними будет находиться
имя функции и её аргумент.

Открывающие угловые скобки, также как и круглые, содержат ссылки на парные
им закрывающие. Это позволяет, найдя левую скобку, сразу зафиксировать парную
ей. Каждая закрывающая угловая скобка содержит указатель на ту открывающую
скобку, которая активируется после текущей. Указатель на левую угловую скобку
первичного активного подвыражения хранится в глобальной переменной рантайма
`s_stack_ptr`. Последняя правая угловая скобка ссылается на `NULL`. Таким
образом, скобки активации провязаны в односвязный список. Выглядит это так:


```
s_stack_ptr ────┐
  ┌─────────────┼───────────────────────────────────────────────────────┐
  │             │                    ┌───────────────────────────┐      │     NULL
  │             │             ┌──────┼─────────────┐             │      │      ↑
  ↓             ↓             │      ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ G ║←→║ > ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             │             ↑      ↑      ↑
  │             └─────────────┘      │             └─────────────┘      │      │
  │                                  └──────────────────────────────────┘      │
  └────────────────────────────────────────────────────────────────────────────┘
```

Первичное активное подвыражение в этом примере `<G>`, на его левую скобку
указывает глобальная переменная `g_stack_ptr`, правую угловую скобку
рефал-машина найдёт, если проследует по указателю из левой скобки. При вызове
функции `G` первичное активное подвыражение будет снято со стека (изъято
из односвязного списка) и переменная `s_stack_ptr` будет указывать на следующую
пару скобок вызова `<I>`. Если вызов `<G>` заменится на пустоту, то поле зрения
приобретёт следующий вид:


```
s_stack_ptr ──────────────────┐
  ┌───────────────────────────┼────────────────────┐     NULL
  │             ┌─────────────┼─────────────┐      │      ↑
  ↓             ↓             ↓             │      │      │
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ < ║←→║ I ║←→║ > ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             │             ↑      ↑      ↑
  │             │             └─────────────┘      │      │
  │             └──────────────────────────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Допустим, вызов `<I>` тоже вычислился в пустоту:

```
s_stack_ptr ────┐
  ┌─────────────┼─────────────┐     NULL
  ↓             ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ H ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      ↑
  │             └─────────────┘      │
  └──────────────────────────────────┘
```

Если вызов функции заменяется на выражение с новыми скобками активации, то они
тоже добавляются в стек. Пусть вызов `<H>` заменяется на `<K> <L>`.

```
s_stack_ptr                                              NULL
  ↓                                                       ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝  ╚═══╝
  │                                                       ↑
  └───────────────────────────────────────────────────────┘
```

На стек сначала будет положена пара скобок вокруг `L`, затем, вокруг `K`:

```
s_stack_ptr ────┐
  ┌─────────────┼──────────────────────────────────┐
  │             │             ┌──────┐             │     NULL
  ↓             ↓             │      ↓             │      ↑
╔═══╗  ╔═══╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═══╗  ╔═══╗  ╔═╧═╗  ╔═╧═╗
║ < ║←→║ F ║←→║ < ║←→║ K ║←→║ > ║←→║ < ║←→║ L ║←→║ > ║←→║ > ║
╚═╤═╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═╤═╝  ╚═══╝  ╚═══╝  ╚═══╝
  │             │             ↑      │             ↑      ↑
  │             └─────────────┘      └─────────────┘      │
  └───────────────────────────────────────────────────────┘
```

Таким образом, ссылки в угловых скобках позволяют эффективно находить первичное
активное подвыражение в поле зрения.

### Зачем это нужно программисту: эффективность отдельных операций

Когда рефал-машина передаёт управление функции, она получает пару указателей
на угловые скобки, ограничивающие первичное активное подвыражение. Функция
должна будет выделить из этого выражения аргумент (отбросив скобки вызова
и своё имя), последовательно сопоставить аргумент с каждым из образцов, и для
первого подошедшего образца построить результат по шаблону в правой части.

**Примечание.** Из соображений минимализма текущая реализация Рефала-05
выполняет сопоставление аргумента с каждым из образцов независимо — при
переходе к следующему забывает о том, какие операции сопоставления в предыдущих
образцах уже выполнялись.

<!-- TODO: про открытые переменные, написать, что реализация на суффиксных
деревьях может быть быстрее, чем O(n) -->

В результате успешного сопоставления с образцом переменные предложения
получают свои значения. E-переменные представляются парой указателей на начало
и конец (для пустых переменных они оба равны нулю), s-переменные представляются
указателем на узел, t-переменные — на первое звено значения (символ или левую
круглую скобку). Если переменная входит в образец несколько раз (является
_повторной,)_ то для неё запоминаются все вхождения. Например, если переменная
`e.X` входила в образец 3 раза, то все её вхождения будут сохранены в трёх
парах указателей.

Построить результат — это значит, построить двусвязный список, на который
следует заменить первичное активное подвыражение в поле зрения,
и, собственно, выполнить эту замену. При этом, само первичное активное
подвыражение уже становится ненужным, а это значит, что оттуда можно взять
готовые фрагменты результата. Текущая реализация, однако, берёт оттуда только
значения e- и t-переменных (s-переменные дешевле построить заново).

Но в некоторых случаях e- и t-переменные приходится копировать — без копии
не обойтись, если в правой части предложения некоторая переменная имеет больше
вхождений, чем в левую. Например, для предложения

    t.SymTable (e.Name) e.Name =
      <Lookup t.SymTable e.Name> '+' <Lookup t.SymTable e.Name>

переменную `t.SymTable` придётся скопировать, в то время как `e.Name` — нет.



[2]: 2-syntax.md
[5]: 5-implementation.md
