//FROM Library
$EXTERN WriteLine, System;

//FROM LibraryEx
$EXTERN ArgList, Map;

//FROM FileScanner
$EXTERN CreateFileList;

//FROM ParseCmdLine
$EXTERN ParseCommandLine, NoCompile, CompileCommand, CmdLineError;

$ENTRY Go { = <Main <ArgList>>; }

Main {
  (e.Program) =
    <WriteLine 'Usage:'>
    <WriteLine
      '  srmake [-s path\\to\\refal05c.exe] -c c++compiler '
      '{-d search-dir} MainFileName[.sref]'
    >;

  (e.Program) e.Arguments =
    <MakeProject <Main-Aux <Get-s-option e.Arguments>>>;
}

Main-Aux {
  (e.Refal05c) e.RestOfArguments =
    (e.Refal05c) <ParseCommandLine e.RestOfArguments>;
}

/*
  Да, костыль, но усложнение потребует большего объёма кода.
  Костыль имеет недочёт: в командной строке может быть
    srmake -c -s refal05c g++ MainFile.sref
  и эта строка корректно обработается.
*/
Get-s-option {
  e.Arguments-B ('--') e.Arguments-E =
    <Get-s-option e.Arguments-B> ('--') e.Arguments-E;

  e.Arguments-B ('-s') (e.Refal05c) e.Arguments-E =
    (e.Refal05c) e.Arguments-B e.Arguments-E;

  e.Arguments = ('refal05c') e.Arguments;
}

MakeProject {
  (e.Refal05c) (CmdLineError e.Message) =
    <WriteLine 'COMMAND LINE ERROR: ' e.Message>;

  (e.Refal05c) (NoCompile) (e.Folders) (e.File) =
    <WriteLine
      'COMMAND LINE ERROR: Compiler not selected'
    >;

  (e.Refal05c) (CompileCommand e.Command) (e.Folders) (e.File) =
    <Make
      (e.Refal05c) (e.Command) (e.Folders) <CreateFileList (e.Folders) e.File>
    >;

  (e.Refal05c) t.Compiler (e.Folders) e.ManyFiles =
    <WriteLine
      'COMMAND LINE ERROR: many files selected'
    >;
}

//FROM FindFile
$EXTERN Source, Output, NotFound;

Make {
  (e.Refal05c) (e.CompilerCommand) (e.Directories)
  e.Units-B (NotFound e.UnitName) e.Units-E =
    <Map PrintNotFound (NotFound e.UnitName) e.Units-E>;

  (e.Refal05c) (e.CompilerCommand) (e.Directories) e.Units =
    <System
      e.Refal05c ' -c "' e.CompilerCommand '" '
      <Map PrintDirectory e.Directories>
      <Map PrintUnit e.Units>
    >;
}

PrintNotFound {
  (NotFound e.UnitName) =
    <WriteLine
      'COMMAND LINE ERROR: Unit ' e.UnitName ' not found'
    >;

  (Output e.Output) = ;
  (Source (e.Source) e.Output) = ;
}

PrintDirectory {
  (e.Folder) = '-d "' e.Folder '" ';
}

PrintUnit {
  (Output e.Output) = '"' e.Output '" ';
  (Source (e.Source) e.Output) = '"' e.Source '" ';
}
