// Automatically generated file. Don't edit!
#include "refalrts.h"


extern refalrts::FnResult LoadFile(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult MapReduce(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult FastIntFromStr(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult DelAccummulator(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult Inc(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult Map(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult Chr(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult StrFromInt(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult LinearizeLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eLine_b_1;
    refalrts::use( eLine_b_1 );
    static refalrts::Iter eLine_e_1;
    refalrts::use( eLine_e_1 );
    // (~1 e.Line )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eLine_b_1 = bb_1;
    refalrts::use( eLine_b_1 );
    eLine_e_1 = be_1;
    refalrts::use( eLine_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '\n' );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_evar( res, eLine_b_1, eLine_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eLine_b_1;
    refalrts::use( eLine_b_1 );
    static refalrts::Iter eLine_e_1;
    refalrts::use( eLine_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Line )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eLine_b_1 = bb_1;
    refalrts::use( eLine_b_1 );
    eLine_e_1 = be_1;
    refalrts::use( eLine_e_1 );
#else
    // (~1 e.Line )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eLine_b_1 = bb_1;
    refalrts::use( eLine_b_1 );
    eLine_e_1 = be_1;
    refalrts::use( eLine_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icSpliceEVar, & eLine_b_1, & eLine_e_1},
      {refalrts::icChar, 0, 0, '\n'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '\n' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eLine_b_1, eLine_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult NormalizeTokens(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult Root(refalrts::Iter arg_begin, refalrts::Iter arg_end);

refalrts::FnResult LexFolding(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eFileName_b_1;
    refalrts::use( eFileName_b_1 );
    static refalrts::Iter eFileName_e_1;
    refalrts::use( eFileName_e_1 );
    // e.FileName
    eFileName_b_1 = bb_0;
    refalrts::use( eFileName_b_1 );
    eFileName_e_1 = be_0;
    refalrts::use( eFileName_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & NormalizeTokens, "NormalizeTokens" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & LinearizeLine, "LinearizeLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & LoadFile, "LoadFile" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n5, n6 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n1 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elems( res, n12, n15 );
    res = refalrts::splice_evar( res, eFileName_b_1, eFileName_e_1 );
    res = refalrts::splice_elems( res, n1, n11 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eFileName_b_1;
    refalrts::use( eFileName_b_1 );
    static refalrts::Iter eFileName_e_1;
    refalrts::use( eFileName_e_1 );
#ifdef OLD_PATTERN
    // e.FileName
    eFileName_b_1 = bb_0;
    refalrts::use( eFileName_b_1 );
    eFileName_e_1 = be_0;
    refalrts::use( eFileName_e_1 );
#else
    // e.FileName
    eFileName_b_1 = bb_0;
    refalrts::use( eFileName_b_1 );
    eFileName_e_1 = be_0;
    refalrts::use( eFileName_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NormalizeTokens, (void*) "NormalizeTokens"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Map, (void*) "Map"},
      {refalrts::icFunc, (void*) & LinearizeLine, (void*) "LinearizeLine"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & LoadFile, (void*) "LoadFile"},
      {refalrts::icSpliceEVar, & eFileName_b_1, & eFileName_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & NormalizeTokens, "NormalizeTokens" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & LinearizeLine, "LinearizeLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & LoadFile, "LoadFile" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n15 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eFileName_b_1, eFileName_e_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n5, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkChar(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkCloseADT(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkCloseCall(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkCloseBlock(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkCloseBracket(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkComma(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkDirective(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkEOF(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkError(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkIdentMarker(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkName(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkNumber(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkOpenADT(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkOpenCall(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkOpenBlock(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkOpenBracket(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkReplace(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkSemicolon(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkUnexpected(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkVariable(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult TkRedefinition(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult EEnum(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult Entry(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult Enum(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult Extern(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult Forward(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult Swap(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult ESwap(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult Ident(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult StrDirective(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & EEnum
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & EEnum, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'M' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'E' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & EEnum
    if( ! refalrts::function_left( & EEnum, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & EEnum
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & EEnum, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'M' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & Entry
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Entry, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'Y' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'E' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & Entry
    if( ! refalrts::function_left( & Entry, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & Entry
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Entry, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'Y'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'Y' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & Enum
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Enum, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'M' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'E' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & Enum
    if( ! refalrts::function_left( & Enum, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & Enum
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Enum, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'M' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & Extern
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Extern, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'N' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'E' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & Extern
    if( ! refalrts::function_left( & Extern, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & Extern
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Extern, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'N' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & Forward
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Forward, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'D' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'F' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n6 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & Forward
    if( ! refalrts::function_left( & Forward, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & Forward
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Forward, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'D'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'D' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & Swap
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Swap, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'P' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'S' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & Swap
    if( ! refalrts::function_left( & Swap, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & Swap
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Swap, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'P' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & ESwap
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & ESwap, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'P' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'E' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & ESwap
    if( ! refalrts::function_left( & ESwap, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & ESwap
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & ESwap, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'P' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & Ident
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Ident, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'L' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'L' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & Ident
    if( ! refalrts::function_left( & Ident, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & Ident
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & Ident, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icChar, 0, 0, 'B'},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'L' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult StrFromToken(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sChar_1;
    refalrts::use( sChar_1 );
    // & TkChar s.Char
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkChar, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sChar_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '\'' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '\'' );
    //}}} REINITS
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sChar_1 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sChar_1;
    refalrts::use( sChar_1 );
#ifdef OLD_PATTERN
    // & TkChar s.Char
    if( ! refalrts::function_left( & TkChar, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sChar_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkChar s.Char
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkChar, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sChar_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '\''},
      {refalrts::icSpliceSTVar, & sChar_1},
      {refalrts::icChar, 0, 0, '\''},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '\'' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '\'' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sChar_1 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkCloseADT
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseADT, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, ']' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkCloseADT
    if( ! refalrts::function_left( & TkCloseADT, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkCloseADT
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseADT, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, ']'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, ']' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkCloseCall
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseCall, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '>' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkCloseCall
    if( ! refalrts::function_left( & TkCloseCall, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkCloseCall
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseCall, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '>'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '>' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkCloseBlock
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseBlock, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkCloseBlock
    if( ! refalrts::function_left( & TkCloseBlock, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkCloseBlock
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseBlock, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkCloseBracket
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseBracket, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, ')' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkCloseBracket
    if( ! refalrts::function_left( & TkCloseBracket, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkCloseBracket
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkCloseBracket, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, ')'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, ')' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkComma
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkComma, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, ',' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkComma
    if( ! refalrts::function_left( & TkComma, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkComma
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkComma, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, ','},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, ',' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sDirective_1;
    refalrts::use( sDirective_1 );
    // & TkDirective s.Directive
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkDirective, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sDirective_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '$' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & StrDirective, "StrDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elems( res, n5, n6 );
    res = refalrts::splice_stvar( res, sDirective_1 );
    res = refalrts::splice_elems( res, n2, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sDirective_1;
    refalrts::use( sDirective_1 );
#ifdef OLD_PATTERN
    // & TkDirective s.Directive
    if( ! refalrts::function_left( & TkDirective, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sDirective_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkDirective s.Directive
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkDirective, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sDirective_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '$'},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StrDirective, (void*) "StrDirective"},
      {refalrts::icSpliceSTVar, & sDirective_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '$' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & StrDirective, "StrDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n7 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_stvar( res, sDirective_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkEOF
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkEOF, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'f' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'f' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'e' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'e' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n10 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkEOF
    if( ! refalrts::function_left( & TkEOF, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkEOF
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkEOF, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 'f'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'f'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'f' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'f' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eMessage_b_1;
    refalrts::use( eMessage_b_1 );
    static refalrts::Iter eMessage_e_1;
    refalrts::use( eMessage_e_1 );
    // & TkError e.Message
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkError, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eMessage_b_1 = bb_0;
    refalrts::use( eMessage_b_1 );
    eMessage_e_1 = be_0;
    refalrts::use( eMessage_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, ':' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'L' );
    //}}} REINITS
    res = refalrts::splice_evar( res, eMessage_b_1, eMessage_e_1 );
    res = refalrts::splice_elems( res, n2, n13 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eMessage_b_1;
    refalrts::use( eMessage_b_1 );
    static refalrts::Iter eMessage_e_1;
    refalrts::use( eMessage_e_1 );
#ifdef OLD_PATTERN
    // & TkError e.Message
    if( ! refalrts::function_left( & TkError, bb_0, be_0 ) ) 
      break;
    eMessage_b_1 = bb_0;
    refalrts::use( eMessage_b_1 );
    eMessage_e_1 = be_0;
    refalrts::use( eMessage_e_1 );
#else
    // & TkError e.Message
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkError, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eMessage_b_1 = bb_0;
    refalrts::use( eMessage_b_1 );
    eMessage_e_1 = be_0;
    refalrts::use( eMessage_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, ':'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icSpliceEVar, & eMessage_b_1, & eMessage_e_1},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ':' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, ' ' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_evar( res, eMessage_b_1, eMessage_e_1 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkIdentMarker
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkIdentMarker, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '#' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkIdentMarker
    if( ! refalrts::function_left( & TkIdentMarker, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkIdentMarker
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkIdentMarker, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '#'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '#' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eName_b_1;
    refalrts::use( eName_b_1 );
    static refalrts::Iter eName_e_1;
    refalrts::use( eName_e_1 );
    // & TkName e.Name
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkName, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eName_b_1 = bb_0;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_0;
    refalrts::use( eName_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, ' ' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'N' );
    //}}} REINITS
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_elems( res, n2, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eName_b_1;
    refalrts::use( eName_b_1 );
    static refalrts::Iter eName_e_1;
    refalrts::use( eName_e_1 );
#ifdef OLD_PATTERN
    // & TkName e.Name
    if( ! refalrts::function_left( & TkName, bb_0, be_0 ) ) 
      break;
    eName_b_1 = bb_0;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_0;
    refalrts::use( eName_e_1 );
#else
    // & TkName e.Name
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkName, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eName_b_1 = bb_0;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_0;
    refalrts::use( eName_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icSpliceEVar, & eName_b_1, & eName_e_1},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, ' ' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNumber_1;
    refalrts::use( sNumber_1 );
    // & TkNumber s.Number
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkNumber, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & StrFromInt, "StrFromInt" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'N' );
    //}}} REINITS
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sNumber_1 );
    res = refalrts::splice_elems( res, n2, n9 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNumber_1;
    refalrts::use( sNumber_1 );
#ifdef OLD_PATTERN
    // & TkNumber s.Number
    if( ! refalrts::function_left( & TkNumber, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkNumber s.Number
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkNumber, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'b'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StrFromInt, (void*) "StrFromInt"},
      {refalrts::icSpliceSTVar, & sNumber_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StrFromInt, "StrFromInt" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_stvar( res, sNumber_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkOpenADT
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenADT, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '[' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkOpenADT
    if( ! refalrts::function_left( & TkOpenADT, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkOpenADT
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenADT, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '['},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '[' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkOpenCall
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenCall, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '<' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkOpenCall
    if( ! refalrts::function_left( & TkOpenCall, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkOpenCall
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenCall, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '<'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '<' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkOpenBlock
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenBlock, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkOpenBlock
    if( ! refalrts::function_left( & TkOpenBlock, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkOpenBlock
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenBlock, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkOpenBracket
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenBracket, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '(' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkOpenBracket
    if( ! refalrts::function_left( & TkOpenBracket, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkOpenBracket
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkOpenBracket, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '('},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '(' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkReplace
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkReplace, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '=' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkReplace
    if( ! refalrts::function_left( & TkReplace, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkReplace
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkReplace, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '='},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '=' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkSemicolon
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkSemicolon, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, ';' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkSemicolon
    if( ! refalrts::function_left( & TkSemicolon, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkSemicolon
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkSemicolon, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, ';'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, ';' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eUnexpected_b_1;
    refalrts::use( eUnexpected_b_1 );
    static refalrts::Iter eUnexpected_e_1;
    refalrts::use( eUnexpected_e_1 );
    // & TkUnexpected e.Unexpected
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkUnexpected, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eUnexpected_b_1 = bb_0;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_0;
    refalrts::use( eUnexpected_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'h' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, '<' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, '>' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, 'U' );
    //}}} REINITS
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_evar( res, eUnexpected_b_1, eUnexpected_e_1 );
    res = refalrts::splice_elems( res, n2, n23 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eUnexpected_b_1;
    refalrts::use( eUnexpected_b_1 );
    static refalrts::Iter eUnexpected_e_1;
    refalrts::use( eUnexpected_e_1 );
#ifdef OLD_PATTERN
    // & TkUnexpected e.Unexpected
    if( ! refalrts::function_left( & TkUnexpected, bb_0, be_0 ) ) 
      break;
    eUnexpected_b_1 = bb_0;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_0;
    refalrts::use( eUnexpected_e_1 );
#else
    // & TkUnexpected e.Unexpected
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkUnexpected, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eUnexpected_b_1 = bb_0;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_0;
    refalrts::use( eUnexpected_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'h'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, '<'},
      {refalrts::icSpliceEVar, & eUnexpected_b_1, & eUnexpected_e_1},
      {refalrts::icChar, 0, 0, '>'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'h' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, '<' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, '>' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_evar( res, eUnexpected_b_1, eUnexpected_e_1 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // & TkVariable s.Mode e.Index
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkVariable, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) ) 
      break;
    eIndex_b_1 = bb_0;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_0;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '.' );
    //}}} REINITS
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_stvar( res, sMode_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
#ifdef OLD_PATTERN
    // & TkVariable s.Mode e.Index
    if( ! refalrts::function_left( & TkVariable, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) ) 
      break;
    eIndex_b_1 = bb_0;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_0;
    refalrts::use( eIndex_e_1 );
#else
    // & TkVariable s.Mode e.Index
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkVariable, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! refalrts::svar_left( sMode_1, bb_0, be_0 ) ) 
      break;
    eIndex_b_1 = bb_0;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_0;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icSpliceSTVar, & sMode_1},
      {refalrts::icChar, 0, 0, '.'},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '.' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sMode_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // & TkRedefinition
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkRedefinition, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '^' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '"' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '"' );
    //}}} REINITS
    res = refalrts::splice_elems( res, n1, n2 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // & TkRedefinition
    if( ! refalrts::function_left( & TkRedefinition, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // & TkRedefinition
    refalrts::Iter n0;
    if( (n0 = refalrts::function_left( & TkRedefinition, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icChar, 0, 0, '^'},
      {refalrts::icChar, 0, 0, '"'},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_char( n1, '"' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '^' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '"' ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TkLiteral_Char(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TkLiteral_Code(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TkLiteral_NewLine(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TkLiteral_CarriageReturn(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TkLiteral_Tab(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TkNewLine(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TkPunctuation(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TokenAccum(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TokenError(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TokenUnexpected(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult TokenUnexpectedEOF(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult ValidDirective(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult SwPunctuation(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult NormalizeName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eName_B_b_1;
    refalrts::use( eName_B_b_1 );
    static refalrts::Iter eName_B_e_1;
    refalrts::use( eName_B_e_1 );
    static refalrts::Iter eName_E_b_1;
    refalrts::use( eName_E_b_1 );
    static refalrts::Iter eName_E_e_1;
    refalrts::use( eName_E_e_1 );
    // e.Name_B '- e.Name_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eName_B_b_1 = bb_0_stk,
        eName_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eName_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eName_B_oe_1, be_0 )
    ) {
      bb_0 = eName_B_oe_1;
      eName_B_b_1 = bb_0_stk;
      eName_B_e_1 = eName_B_oe_1;
      refalrts::move_right( eName_B_b_1, eName_B_e_1 );
      refalrts::Iter n1;
      if( (n1 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      eName_E_b_1 = bb_0;
      refalrts::use( eName_E_b_1 );
      eName_E_e_1 = be_0;
      refalrts::use( eName_E_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      refalrts::Iter n3 = 0;
      if( ! refalrts::alloc_name( n3, & NormalizeName, "NormalizeName" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n4 = 0;
      if( ! refalrts::alloc_char( n4, '_' ) )
        return refalrts::cNoMemory;
      refalrts::Iter n5 = 0;
      if( ! refalrts::alloc_close_call( n5 ) )
        return refalrts::cNoMemory;
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n1 );
      //}}} REINITS
      refalrts::push_stack( n5 );
      refalrts::push_stack( n1 );
      res = refalrts::splice_elem( res, n5 );
      res = refalrts::splice_evar( res, eName_E_b_1, eName_E_e_1 );
      res = refalrts::splice_elem( res, n4 );
      res = refalrts::splice_evar( res, eName_B_b_1, eName_B_e_1 );
      res = refalrts::splice_elem( res, n3 );
      res = refalrts::splice_elem( res, n1 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eName_B_b_1;
    refalrts::use( eName_B_b_1 );
    static refalrts::Iter eName_B_e_1;
    refalrts::use( eName_B_e_1 );
    static refalrts::Iter eName_E_b_1;
    refalrts::use( eName_E_b_1 );
    static refalrts::Iter eName_E_e_1;
    refalrts::use( eName_E_e_1 );
#ifdef OLD_PATTERN
    // e.Name_B '- e.Name_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eName_B_b_1 = bb_0_stk,
        eName_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eName_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eName_B_oe_1, be_0 )
    ) {
      bb_0 = eName_B_oe_1;
      eName_B_b_1 = bb_0_stk;
      eName_B_e_1 = eName_B_oe_1;
      refalrts::move_right( eName_B_b_1, eName_B_e_1 );
      if( ! refalrts::char_left( '-', bb_0, be_0 ) ) 
        continue;
      eName_E_b_1 = bb_0;
      refalrts::use( eName_E_b_1 );
      eName_E_e_1 = be_0;
      refalrts::use( eName_E_e_1 );
#else
    // e.Name_B '- e.Name_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eName_B_b_1 = bb_0_stk,
        eName_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eName_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eName_B_oe_1, be_0 )
    ) {
      bb_0 = eName_B_oe_1;
      eName_B_b_1 = bb_0_stk;
      eName_B_e_1 = eName_B_oe_1;
      refalrts::move_right( eName_B_b_1, eName_B_e_1 );
      refalrts::Iter n1;
      if( (n1 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      eName_E_b_1 = bb_0;
      refalrts::use( eName_E_b_1 );
      eName_E_e_1 = be_0;
      refalrts::use( eName_E_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & NormalizeName, (void*) "NormalizeName"},
        {refalrts::icSpliceEVar, & eName_B_b_1, & eName_B_e_1},
        {refalrts::icChar, 0, 0, '_'},
        {refalrts::icSpliceEVar, & eName_E_b_1, & eName_E_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n3 = 0;
      if( ! refalrts::alloc_open_call( n3 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n4 = 0;
      if( ! refalrts::alloc_name( n4, & NormalizeName, "NormalizeName" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n5 = 0;
      if( ! refalrts::alloc_char( n5, '_' ) )
        return refalrts::cNoMemory;
      refalrts::Iter n6 = 0;
      if( ! refalrts::alloc_close_call( n6 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n6 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eName_E_b_1, eName_E_e_1 );
      res = refalrts::splice_elem( res, n5 );
      res = refalrts::splice_evar( res, eName_B_b_1, eName_B_e_1 );
      res = refalrts::splice_elem( res, n4 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eName_b_1;
    refalrts::use( eName_b_1 );
    static refalrts::Iter eName_e_1;
    refalrts::use( eName_e_1 );
    // e.Name
    eName_b_1 = bb_0;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_0;
    refalrts::use( eName_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eName_b_1;
    refalrts::use( eName_b_1 );
    static refalrts::Iter eName_e_1;
    refalrts::use( eName_e_1 );
#ifdef OLD_PATTERN
    // e.Name
    eName_b_1 = bb_0;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_0;
    refalrts::use( eName_e_1 );
#else
    // e.Name
    eName_b_1 = bb_0;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_0;
    refalrts::use( eName_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icSpliceEVar, & eName_b_1, & eName_e_1},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult NormalizeToken(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eDirective_b_1;
    refalrts::use( eDirective_b_1 );
    static refalrts::Iter eDirective_e_1;
    refalrts::use( eDirective_e_1 );
    // (~1 & TkDirective e.Directive )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkDirective, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDirective_b_1 = bb_1;
    refalrts::use( eDirective_b_1 );
    eDirective_e_1 = be_1;
    refalrts::use( eDirective_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n1 );
    refalrts::reinit_name( n0, & ValidDirective, "ValidDirective" );
    refalrts::reinit_close_call( n3 );
    //}}} REINITS
    refalrts::push_stack( n3 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eDirective_b_1, eDirective_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eDirective_b_1;
    refalrts::use( eDirective_b_1 );
    static refalrts::Iter eDirective_e_1;
    refalrts::use( eDirective_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TkDirective e.Directive )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkDirective, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDirective_b_1 = bb_1;
    refalrts::use( eDirective_b_1 );
    eDirective_e_1 = be_1;
    refalrts::use( eDirective_e_1 );
#else
    // (~1 & TkDirective e.Directive )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkDirective, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDirective_b_1 = bb_1;
    refalrts::use( eDirective_b_1 );
    eDirective_e_1 = be_1;
    refalrts::use( eDirective_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & ValidDirective, (void*) "ValidDirective"},
      {refalrts::icSpliceEVar, & eDirective_b_1, & eDirective_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & ValidDirective, "ValidDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eDirective_b_1, eDirective_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // (~1 & TkEOF )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkEOF, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    res = refalrts::splice_elems( res, n0, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // (~1 & TkEOF )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkEOF, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // (~1 & TkEOF )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkEOF, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkEOF, (void*) "TkEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkEOF, "TkEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sChar_1;
    refalrts::use( sChar_1 );
    // (~1 & TkLiteral_Char s.Char )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_Char, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sChar_1, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkChar, "TkChar" );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sChar_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sChar_1;
    refalrts::use( sChar_1 );
#ifdef OLD_PATTERN
    // (~1 & TkLiteral_Char s.Char )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkLiteral_Char, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sChar_1, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
#else
    // (~1 & TkLiteral_Char s.Char )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_Char, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sChar_1, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkChar, (void*) "TkChar"},
      {refalrts::icSpliceSTVar, & sChar_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkChar, "TkChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_stvar( res, sChar_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eDecCode_b_1;
    refalrts::use( eDecCode_b_1 );
    static refalrts::Iter eDecCode_e_1;
    refalrts::use( eDecCode_e_1 );
    // (~1 & TkLiteral_Code e.DecCode )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_Code, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDecCode_b_1 = bb_1;
    refalrts::use( eDecCode_b_1 );
    eDecCode_e_1 = be_1;
    refalrts::use( eDecCode_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Chr, "Chr" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & FastIntFromStr, "FastIntFromStr" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkChar, "TkChar" );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n4 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elems( res, n8, n9 );
    res = refalrts::splice_evar( res, eDecCode_b_1, eDecCode_e_1 );
    res = refalrts::splice_elems( res, n4, n7 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eDecCode_b_1;
    refalrts::use( eDecCode_b_1 );
    static refalrts::Iter eDecCode_e_1;
    refalrts::use( eDecCode_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TkLiteral_Code e.DecCode )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkLiteral_Code, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDecCode_b_1 = bb_1;
    refalrts::use( eDecCode_b_1 );
    eDecCode_e_1 = be_1;
    refalrts::use( eDecCode_e_1 );
#else
    // (~1 & TkLiteral_Code e.DecCode )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_Code, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDecCode_b_1 = bb_1;
    refalrts::use( eDecCode_b_1 );
    eDecCode_e_1 = be_1;
    refalrts::use( eDecCode_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkChar, (void*) "TkChar"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Chr, (void*) "Chr"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & FastIntFromStr, (void*) "FastIntFromStr"},
      {refalrts::icSpliceEVar, & eDecCode_b_1, & eDecCode_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkChar, "TkChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Chr, "Chr" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & FastIntFromStr, "FastIntFromStr" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n12 );
    res = refalrts::splice_elem( res, n12 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eDecCode_b_1, eDecCode_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // (~1 & TkLiteral_NewLine 'n )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_NewLine, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'n', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkChar, "TkChar" );
    refalrts::reinit_char( n2, '\n' );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // (~1 & TkLiteral_NewLine 'n )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkLiteral_NewLine, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::char_left( 'n', bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // (~1 & TkLiteral_NewLine 'n )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_NewLine, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'n', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkChar, (void*) "TkChar"},
      {refalrts::icChar, 0, 0, '\n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkChar, "TkChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, '\n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // (~1 & TkLiteral_CarriageReturn 'r )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_CarriageReturn, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'r', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkChar, "TkChar" );
    refalrts::reinit_char( n2, '\r' );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // (~1 & TkLiteral_CarriageReturn 'r )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkLiteral_CarriageReturn, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::char_left( 'r', bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // (~1 & TkLiteral_CarriageReturn 'r )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_CarriageReturn, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'r', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkChar, (void*) "TkChar"},
      {refalrts::icChar, 0, 0, '\r'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkChar, "TkChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, '\r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // (~1 & TkLiteral_Tab 't )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_Tab, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 't', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkChar, "TkChar" );
    refalrts::reinit_char( n2, '\t' );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // (~1 & TkLiteral_Tab 't )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkLiteral_Tab, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::char_left( 't', bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // (~1 & TkLiteral_Tab 't )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkLiteral_Tab, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 't', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkChar, (void*) "TkChar"},
      {refalrts::icChar, 0, 0, '\t'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkChar, "TkChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, '\t' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eName_b_1;
    refalrts::use( eName_b_1 );
    static refalrts::Iter eName_e_1;
    refalrts::use( eName_e_1 );
    // (~1 & TkName e.Name )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eName_b_1 = bb_1;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_1;
    refalrts::use( eName_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & NormalizeName, "NormalizeName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_elems( res, n4, n5 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eName_b_1;
    refalrts::use( eName_b_1 );
    static refalrts::Iter eName_e_1;
    refalrts::use( eName_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TkName e.Name )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkName, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eName_b_1 = bb_1;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_1;
    refalrts::use( eName_e_1 );
#else
    // (~1 & TkName e.Name )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eName_b_1 = bb_1;
    refalrts::use( eName_b_1 );
    eName_e_1 = be_1;
    refalrts::use( eName_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkName, (void*) "TkName"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NormalizeName, (void*) "NormalizeName"},
      {refalrts::icSpliceEVar, & eName_b_1, & eName_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkName, "TkName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & NormalizeName, "NormalizeName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n9 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eName_b_1, eName_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccumulated_b_1;
    refalrts::use( eAccumulated_b_1 );
    static refalrts::Iter eAccumulated_e_1;
    refalrts::use( eAccumulated_e_1 );
    // (~1 & TkNewLine e.Accumulated )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkNewLine, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccumulated_b_1 = bb_1;
    refalrts::use( eAccumulated_b_1 );
    eAccumulated_e_1 = be_1;
    refalrts::use( eAccumulated_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccumulated_b_1;
    refalrts::use( eAccumulated_b_1 );
    static refalrts::Iter eAccumulated_e_1;
    refalrts::use( eAccumulated_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TkNewLine e.Accumulated )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkNewLine, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccumulated_b_1 = bb_1;
    refalrts::use( eAccumulated_b_1 );
    eAccumulated_e_1 = be_1;
    refalrts::use( eAccumulated_e_1 );
#else
    // (~1 & TkNewLine e.Accumulated )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkNewLine, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccumulated_b_1 = bb_1;
    refalrts::use( eAccumulated_b_1 );
    eAccumulated_e_1 = be_1;
    refalrts::use( eAccumulated_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkNewLine, (void*) "TkNewLine"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkNewLine, "TkNewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eDigits_b_1;
    refalrts::use( eDigits_b_1 );
    static refalrts::Iter eDigits_e_1;
    refalrts::use( eDigits_e_1 );
    // (~1 & TkNumber e.Digits )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDigits_b_1 = bb_1;
    refalrts::use( eDigits_b_1 );
    eDigits_e_1 = be_1;
    refalrts::use( eDigits_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & FastIntFromStr, "FastIntFromStr" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eDigits_b_1, eDigits_e_1 );
    res = refalrts::splice_elems( res, n4, n5 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eDigits_b_1;
    refalrts::use( eDigits_b_1 );
    static refalrts::Iter eDigits_e_1;
    refalrts::use( eDigits_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TkNumber e.Digits )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkNumber, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDigits_b_1 = bb_1;
    refalrts::use( eDigits_b_1 );
    eDigits_e_1 = be_1;
    refalrts::use( eDigits_e_1 );
#else
    // (~1 & TkNumber e.Digits )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eDigits_b_1 = bb_1;
    refalrts::use( eDigits_b_1 );
    eDigits_e_1 = be_1;
    refalrts::use( eDigits_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkNumber, (void*) "TkNumber"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & FastIntFromStr, (void*) "FastIntFromStr"},
      {refalrts::icSpliceEVar, & eDigits_b_1, & eDigits_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkNumber, "TkNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & FastIntFromStr, "FastIntFromStr" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n9 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eDigits_b_1, eDigits_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sPunctuation_1;
    refalrts::use( sPunctuation_1 );
    // (~1 & TkPunctuation s.Punctuation )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkPunctuation, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sPunctuation_1, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & SwPunctuation, "SwPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n1 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    refalrts::push_stack( n5 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_stvar( res, sPunctuation_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sPunctuation_1;
    refalrts::use( sPunctuation_1 );
#ifdef OLD_PATTERN
    // (~1 & TkPunctuation s.Punctuation )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkPunctuation, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sPunctuation_1, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
#else
    // (~1 & TkPunctuation s.Punctuation )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkPunctuation, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sPunctuation_1, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SwPunctuation, (void*) "SwPunctuation"},
      {refalrts::icSpliceSTVar, & sPunctuation_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SwPunctuation, "SwPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n8 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sPunctuation_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // (~1 & TkVariable s.Type '. e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sType_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '.', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & NormalizeName, "NormalizeName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TkVariable s.Type '. e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sType_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::char_left( '.', bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#else
    // (~1 & TkVariable s.Type '. e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sType_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '.', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
      {refalrts::icSpliceSTVar, & sType_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NormalizeName, (void*) "NormalizeName"},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TkVariable, "TkVariable" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & NormalizeName, "NormalizeName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n11 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eUnexpected_b_1;
    refalrts::use( eUnexpected_b_1 );
    static refalrts::Iter eUnexpected_e_1;
    refalrts::use( eUnexpected_e_1 );
    // (~1 & TkUnexpected e.Unexpected )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkUnexpected, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eUnexpected_b_1 = bb_1;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_1;
    refalrts::use( eUnexpected_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eUnexpected_b_1, eUnexpected_e_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eUnexpected_b_1;
    refalrts::use( eUnexpected_b_1 );
    static refalrts::Iter eUnexpected_e_1;
    refalrts::use( eUnexpected_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TkUnexpected e.Unexpected )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkUnexpected, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eUnexpected_b_1 = bb_1;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_1;
    refalrts::use( eUnexpected_e_1 );
#else
    // (~1 & TkUnexpected e.Unexpected )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TkUnexpected, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eUnexpected_b_1 = bb_1;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_1;
    refalrts::use( eUnexpected_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkUnexpected, (void*) "TkUnexpected"},
      {refalrts::icSpliceEVar, & eUnexpected_b_1, & eUnexpected_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkUnexpected, "TkUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eUnexpected_b_1, eUnexpected_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eMessage_b_1;
    refalrts::use( eMessage_b_1 );
    static refalrts::Iter eMessage_e_1;
    refalrts::use( eMessage_e_1 );
    // (~1 & TokenError e.Message )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TokenError, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eMessage_b_1 = bb_1;
    refalrts::use( eMessage_b_1 );
    eMessage_e_1 = be_1;
    refalrts::use( eMessage_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkError, "TkError" );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eMessage_b_1, eMessage_e_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eMessage_b_1;
    refalrts::use( eMessage_b_1 );
    static refalrts::Iter eMessage_e_1;
    refalrts::use( eMessage_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TokenError e.Message )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TokenError, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eMessage_b_1 = bb_1;
    refalrts::use( eMessage_b_1 );
    eMessage_e_1 = be_1;
    refalrts::use( eMessage_e_1 );
#else
    // (~1 & TokenError e.Message )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TokenError, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eMessage_b_1 = bb_1;
    refalrts::use( eMessage_b_1 );
    eMessage_e_1 = be_1;
    refalrts::use( eMessage_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkError, (void*) "TkError"},
      {refalrts::icSpliceEVar, & eMessage_b_1, & eMessage_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkError, "TkError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eMessage_b_1, eMessage_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eUnexpected_b_1;
    refalrts::use( eUnexpected_b_1 );
    static refalrts::Iter eUnexpected_e_1;
    refalrts::use( eUnexpected_e_1 );
    // (~1 & TokenUnexpected e.Unexpected )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TokenUnexpected, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eUnexpected_b_1 = bb_1;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_1;
    refalrts::use( eUnexpected_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkUnexpected, "TkUnexpected" );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eUnexpected_b_1, eUnexpected_e_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eUnexpected_b_1;
    refalrts::use( eUnexpected_b_1 );
    static refalrts::Iter eUnexpected_e_1;
    refalrts::use( eUnexpected_e_1 );
#ifdef OLD_PATTERN
    // (~1 & TokenUnexpected e.Unexpected )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TokenUnexpected, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eUnexpected_b_1 = bb_1;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_1;
    refalrts::use( eUnexpected_e_1 );
#else
    // (~1 & TokenUnexpected e.Unexpected )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TokenUnexpected, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eUnexpected_b_1 = bb_1;
    refalrts::use( eUnexpected_b_1 );
    eUnexpected_e_1 = be_1;
    refalrts::use( eUnexpected_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkUnexpected, (void*) "TkUnexpected"},
      {refalrts::icSpliceEVar, & eUnexpected_b_1, & eUnexpected_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkUnexpected, "TkUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eUnexpected_b_1, eUnexpected_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // (~1 & TokenUnexpectedEOF )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TokenUnexpectedEOF, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'F' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & TkError, "TkError" );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n3, n16 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // (~1 & TokenUnexpectedEOF )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TokenUnexpectedEOF, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // (~1 & TokenUnexpectedEOF )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & TokenUnexpectedEOF, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkError, (void*) "TkError"},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkError, "TkError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n3, n19 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult ValidDirective(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'E 'N 'U 'M'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & Enum, "Enum" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'ENUM'
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'E 'N 'U 'M'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & Enum, (void*) "Enum"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Enum, "Enum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'E 'E 'N 'U 'M'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & EEnum, "EEnum" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'EENUM'
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'E 'E 'N 'U 'M'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & EEnum, (void*) "EEnum"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & EEnum, "EEnum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'E 'N 'T 'R 'Y'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & Entry, "Entry" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'ENTRY'
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Y', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'E 'N 'T 'R 'Y'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & Entry, (void*) "Entry"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Entry, "Entry" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'E 'X 'T 'E 'R 'N'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n5;
    if( (n5 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n5 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & Extern, "Extern" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'EXTERN'
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'X', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'E 'X 'T 'E 'R 'N'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n5;
    if( (n5 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n5 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & Extern, (void*) "Extern"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Extern, "Extern" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'F 'O 'R 'W 'A 'R 'D'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n5;
    if( (n5 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n5 );
    refalrts::Iter n6;
    if( (n6 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & Forward, "Forward" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'FORWARD'
    if( ! refalrts::char_left( 'F', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'O', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'D', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'F 'O 'R 'W 'A 'R 'D'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n5;
    if( (n5 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n5 );
    refalrts::Iter n6;
    if( (n6 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & Forward, (void*) "Forward"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Forward, "Forward" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n7, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'S 'W 'A 'P'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & Swap, "Swap" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'SWAP'
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'S 'W 'A 'P'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & Swap, (void*) "Swap"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Swap, "Swap" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'E 'S 'W 'A 'P'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & ESwap, "ESwap" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'ESWAP'
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'E 'S 'W 'A 'P'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & ESwap, (void*) "ESwap"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & ESwap, "ESwap" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // 'L 'A 'B 'E 'L'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_bracket( n0 );
    refalrts::reinit_name( n1, & TkDirective, "TkDirective" );
    refalrts::reinit_name( n2, & Ident, "Ident" );
    refalrts::reinit_close_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elems( res, n0, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // 'LABEL'
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'B', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // 'L 'A 'B 'E 'L'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n1;
    if( (n1 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n2;
    if( (n2 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icFunc, (void*) & Ident, (void*) "Ident"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Ident, "Ident" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eOther_b_1;
    refalrts::use( eOther_b_1 );
    static refalrts::Iter eOther_e_1;
    refalrts::use( eOther_e_1 );
    // e.Other
    eOther_b_1 = bb_0;
    refalrts::use( eOther_b_1 );
    eOther_e_1 = be_0;
    refalrts::use( eOther_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & TkError, "TkError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'k' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'w' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, '$' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n22 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_evar( res, eOther_b_1, eOther_e_1 );
    res = refalrts::splice_elems( res, n1, n21 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eOther_b_1;
    refalrts::use( eOther_b_1 );
    static refalrts::Iter eOther_e_1;
    refalrts::use( eOther_e_1 );
#ifdef OLD_PATTERN
    // e.Other
    eOther_b_1 = bb_0;
    refalrts::use( eOther_b_1 );
    eOther_e_1 = be_0;
    refalrts::use( eOther_e_1 );
#else
    // e.Other
    eOther_b_1 = bb_0;
    refalrts::use( eOther_b_1 );
    eOther_e_1 = be_0;
    refalrts::use( eOther_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkError, (void*) "TkError"},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'k'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 'w'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'v'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, '$'},
      {refalrts::icSpliceEVar, & eOther_b_1, & eOther_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & TkError, "TkError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'k' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'w' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, '$' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n1, n22 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_evar( res, eOther_b_1, eOther_e_1 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult SwPunctuation(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '<'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '<', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkOpenCall, "TkOpenCall" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '<'
    if( ! refalrts::char_left( '<', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '<'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '<', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkOpenCall, (void*) "TkOpenCall"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkOpenCall, "TkOpenCall" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '>'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '>', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkCloseCall, "TkCloseCall" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '>'
    if( ! refalrts::char_left( '>', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '>'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '>', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkCloseCall, (void*) "TkCloseCall"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkCloseCall, "TkCloseCall" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '{'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '{', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkOpenBlock, "TkOpenBlock" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '{'
    if( ! refalrts::char_left( '{', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '{'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '{', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkOpenBlock, (void*) "TkOpenBlock"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkOpenBlock, "TkOpenBlock" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '}'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '}', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkCloseBlock, "TkCloseBlock" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '}'
    if( ! refalrts::char_left( '}', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '}'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '}', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkCloseBlock, (void*) "TkCloseBlock"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkCloseBlock, "TkCloseBlock" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '('
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '(', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkOpenBracket, "TkOpenBracket" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '('
    if( ! refalrts::char_left( '(', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '('
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '(', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkOpenBracket, (void*) "TkOpenBracket"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkOpenBracket, "TkOpenBracket" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // ')'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ')', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkCloseBracket, "TkCloseBracket" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // ')'
    if( ! refalrts::char_left( ')', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // ')'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ')', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkCloseBracket, (void*) "TkCloseBracket"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkCloseBracket, "TkCloseBracket" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '='
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '=', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkReplace, "TkReplace" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '='
    if( ! refalrts::char_left( '=', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '='
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '=', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkReplace, (void*) "TkReplace"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkReplace, "TkReplace" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // ','
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ',', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkComma, "TkComma" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // ','
    if( ! refalrts::char_left( ',', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // ','
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ',', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkComma, (void*) "TkComma"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkComma, "TkComma" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // ';'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ';', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkSemicolon, "TkSemicolon" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // ';'
    if( ! refalrts::char_left( ';', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // ';'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ';', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkSemicolon, (void*) "TkSemicolon"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkSemicolon, "TkSemicolon" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '['
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '[', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkOpenADT, "TkOpenADT" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '['
    if( ! refalrts::char_left( '[', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '['
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '[', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkOpenADT, (void*) "TkOpenADT"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkOpenADT, "TkOpenADT" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // ']'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ']', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkCloseADT, "TkCloseADT" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // ']'
    if( ! refalrts::char_left( ']', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // ']'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( ']', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkCloseADT, (void*) "TkCloseADT"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkCloseADT, "TkCloseADT" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '#'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '#', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkIdentMarker, "TkIdentMarker" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '#'
    if( ! refalrts::char_left( '#', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '#'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '#', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkIdentMarker, (void*) "TkIdentMarker"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkIdentMarker, "TkIdentMarker" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    // '^'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '^', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n0, & TkRedefinition, "TkRedefinition" );
    //}}} REINITS
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    // '^'
    if( ! refalrts::char_left( '^', bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // '^'
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '^', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icFunc, (void*) & TkRedefinition, (void*) "TkRedefinition"},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_name( n1, & TkRedefinition, "TkRedefinition" ) )
      return refalrts::cNoMemory;
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult AddLineNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sLineNumber_1;
    refalrts::use( sLineNumber_1 );
    // s.LineNumber (~1 & TkNewLine )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & TkNewLine, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! refalrts::svar_left( sLineNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n2 );
    refalrts::reinit_name( n1, & Inc, "Inc" );
    refalrts::reinit_close_call( n3 );
    //}}} REINITS
    refalrts::push_stack( n3 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sLineNumber_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sLineNumber_1;
    refalrts::use( sLineNumber_1 );
#ifdef OLD_PATTERN
    // s.LineNumber (~1 & TkNewLine )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkNewLine, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! refalrts::svar_left( sLineNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // s.LineNumber (~1 & TkNewLine )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & TkNewLine, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    if( ! refalrts::svar_left( sLineNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Inc, (void*) "Inc"},
      {refalrts::icSpliceSTVar, & sLineNumber_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Inc, "Inc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_stvar( res, sLineNumber_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sLineNumber_1;
    refalrts::use( sLineNumber_1 );
    static refalrts::Iter sTokType_1;
    refalrts::use( sTokType_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // s.LineNumber (~1 s.TokType e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    if( ! refalrts::svar_left( sLineNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sTokType_1, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    static refalrts::Iter sLineNumber_2;
    refalrts::use( sLineNumber_2 );
    if( ! refalrts::copy_stvar( sLineNumber_2, sLineNumber_1 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n4 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sLineNumber_2 );
    res = refalrts::splice_stvar( res, sTokType_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_stvar( res, sLineNumber_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sLineNumber_1;
    refalrts::use( sLineNumber_1 );
    static refalrts::Iter sTokType_1;
    refalrts::use( sTokType_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter sLineNumber_2;
    refalrts::use( sLineNumber_2 );
#ifdef OLD_PATTERN
    // s.LineNumber (~1 s.TokType e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sLineNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sTokType_1, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // s.LineNumber (~1 s.TokType e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    if( ! refalrts::svar_left( sLineNumber_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sTokType_1, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icSpliceSTVar, & sLineNumber_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceSTVar, & sTokType_1},
      {refalrts::icCopySTVar, & sLineNumber_1},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    if( ! refalrts::copy_stvar( sLineNumber_2, sLineNumber_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n5, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sLineNumber_2 );
    res = refalrts::splice_stvar( res, sTokType_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_stvar( res, sLineNumber_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult NormalizeTokens(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eTokens_b_1;
    refalrts::use( eTokens_b_1 );
    static refalrts::Iter eTokens_e_1;
    refalrts::use( eTokens_e_1 );
    // e.Tokens
    eTokens_b_1 = bb_0;
    refalrts::use( eTokens_b_1 );
    eTokens_e_1 = be_0;
    refalrts::use( eTokens_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & DelAccummulator, "DelAccummulator" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & MapReduce, "MapReduce" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & AddLineNumber, "AddLineNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_number( n6, 1UL ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & NormalizeToken, "NormalizeToken" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n12 );
    refalrts::push_stack( n1 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elems( res, n10, n12 );
    res = refalrts::splice_evar( res, eTokens_b_1, eTokens_e_1 );
    res = refalrts::splice_elems( res, n1, n9 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eTokens_b_1;
    refalrts::use( eTokens_b_1 );
    static refalrts::Iter eTokens_e_1;
    refalrts::use( eTokens_e_1 );
#ifdef OLD_PATTERN
    // e.Tokens
    eTokens_b_1 = bb_0;
    refalrts::use( eTokens_b_1 );
    eTokens_e_1 = be_0;
    refalrts::use( eTokens_e_1 );
#else
    // e.Tokens
    eTokens_b_1 = bb_0;
    refalrts::use( eTokens_b_1 );
    eTokens_e_1 = be_0;
    refalrts::use( eTokens_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DelAccummulator, (void*) "DelAccummulator"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & MapReduce, (void*) "MapReduce"},
      {refalrts::icFunc, (void*) & AddLineNumber, (void*) "AddLineNumber"},
      {refalrts::icInt, 0, 0, 1 },
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Map, (void*) "Map"},
      {refalrts::icFunc, (void*) & NormalizeToken, (void*) "NormalizeToken"},
      {refalrts::icSpliceEVar, & eTokens_b_1, & eTokens_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & DelAccummulator, "DelAccummulator" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & MapReduce, "MapReduce" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & AddLineNumber, "AddLineNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_number( n6, 1UL ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & NormalizeToken, "NormalizeToken" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n12 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eTokens_b_1, eTokens_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Name(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult Number(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult VariableStart(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult Directive(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult StringLiteral_Start(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult StartComment(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult VariableIndex(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult Punctuation(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult StringLiteral(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult DirectiveTail(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult DirectiveBody(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult StringLiteral_Escape(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult SL_E_C1(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult CComment(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult CppComment(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult VariableIndexTail(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult StringLiteral_Quote(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult CComment_CheckNested(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult CComment_CheckEnd(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult StringLiteral_Escape_Code(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult SL_E_C2(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult Root(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '  e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ' ', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '  e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( ' ', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '  e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ' ', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\t e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\t', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\t e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\t', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\t e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\t', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\r', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '< e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '<', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '< e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '<', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '< e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '<', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '<'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '<' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '> e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '>', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '> e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '>', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '> e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '>', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '>'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '>' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '( e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '(', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '( e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '(', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '( e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '(', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '('},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '(' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 ') e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ')', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 ') e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( ')', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 ') e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ')', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, ')'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, ')' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '{ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '{', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '{ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '{', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '{ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '{', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '} e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '}', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '} e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '}', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '} e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '}', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '[ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '[', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '[ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '[', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '[ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '[', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '['},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '[' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '] e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ']', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '] e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( ']', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '] e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ']', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, ']'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, ']' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '= e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '=', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '= e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '=', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '= e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '=', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '='},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '=' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '; e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ';', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '; e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( ';', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '; e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ';', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, ';'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, ';' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 ', e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ',', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 ', e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( ',', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 ', e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( ',', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, ','},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, ',' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '# e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '#', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '# e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '#', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '# e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '#', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '#'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '#' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '^ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '^', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '^ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '^', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '^ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '^', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkPunctuation, (void*) "TkPunctuation"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '^'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkPunctuation, "TkPunctuation" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '^' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'B', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'B'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'C', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'D', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'D'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'D' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'F', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'G', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'G'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'G' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'H', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'H'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'H' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'I', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'J', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'J'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'J' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'K', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'K'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'K' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'M' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'O', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'P' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'V', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'V'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'V' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'X', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableStart, "VariableStart" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 's', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableStart, (void*) "VariableStart"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableStart, "VariableStart" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableStart, "VariableStart" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'e', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableStart, (void*) "VariableStart"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableStart, "VariableStart" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableStart, "VariableStart" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 't', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableStart, (void*) "VariableStart"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableStart, "VariableStart" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '$ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '$', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Directive, "Directive" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '$ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '$', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '$ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '$', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Directive, (void*) "Directive"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Directive, "Directive" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & StringLiteral_Start, "StringLiteral_Start" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\'', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral_Start, (void*) "StringLiteral_Start"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StringLiteral_Start, "StringLiteral_Start" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StartComment, "StartComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '/', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StartComment, (void*) "StartComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '/'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StartComment, "StartComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '/' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkNewLine, "TkNewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkNewLine, (void*) "TkNewLine"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '\n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkNewLine, "TkNewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '\n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TkEOF, "TkEOF" ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkEOF, (void*) "TkEOF"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkEOF, "TkEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkUnexpected, "TkUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sAny_1 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkUnexpected, (void*) "TkUnexpected"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icSpliceSTVar, & sAny_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkUnexpected, "TkUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sAny_1 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Name(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'a', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'a', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'a', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'b', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'b', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'b', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'b'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'c', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'c', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'c', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'd', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'e', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'f', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'f', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'f', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'f'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'f' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'g', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'g', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'g', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'g'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'g' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'h', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'h', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'h', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'h'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'h' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'i', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'i', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'i', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'j', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'j', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'j', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'j'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'j' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'k', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'k', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'k', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'k'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'k' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'l', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'l', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'l', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'm', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'm', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'm', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'o', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'o', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'o', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'p', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'p', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'p', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'r', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 's', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 't', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'u', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'u', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'u', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'v', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'v', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'v', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'v'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'w', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'w', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'w', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'w'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'w' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'x', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'x', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'x', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'B', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'B'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'C', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'D', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'D'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'D' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'F', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'G', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'G'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'G' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'H', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'H'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'H' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'I', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'J', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'J'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'J' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'K', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'K'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'K' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'M' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'O', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'P' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'V', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'V'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'V' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'X', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '_', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '_', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '_', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '_'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '_' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '-', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Name, (void*) "Name"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '-'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Name, "Name" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '-' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkName, "TkName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n7, n8 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkName, (void*) "TkName"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkName, "TkName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult VariableStart(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '. e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '.', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndex, "VariableIndex" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '. e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '.', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '. e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '.', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndex, (void*) "VariableIndex"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '.'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndex, "VariableIndex" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '.' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_open_call( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_name( n18, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_bracket( n20 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_call( n21 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n19, n20 );
    refalrts::push_stack( n21 );
    refalrts::push_stack( n17 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n17, n20 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n4, n16 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_call( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_open_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_close_call( n23 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n23 );
    refalrts::push_stack( n19 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n21, n22 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::link_brackets( n4, n18 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Number(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Number, (void*) "Number"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Number, "Number" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkNumber, "TkNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n7, n8 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkNumber, (void*) "TkNumber"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkNumber, "TkNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Directive(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'B', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'B'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'C', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'D', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'D'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'D' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'F', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'G', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'G'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'G' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'H', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'H'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'H' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'I', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'J', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'J'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'J' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'K', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'K'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'K' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'M' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'O', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'P' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'V', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'V'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'V' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'X', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_open_call( n28 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_name( n29, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_open_bracket( n30 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_close_bracket( n31 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_close_call( n32 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n30, n31 );
    refalrts::push_stack( n32 );
    refalrts::push_stack( n28 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n28, n31 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n4, n27 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'v'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_close_bracket( n29 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_open_call( n30 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_name( n31, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_open_bracket( n32 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_close_bracket( n33 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_close_call( n34 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n34 );
    refalrts::push_stack( n30 );
    res = refalrts::splice_elem( res, n34 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n32, n33 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    refalrts::link_brackets( n4, n29 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult StringLiteral_Start(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\'', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Char, (void*) "TkLiteral_Char"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '\''},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '\'' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n4, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n6, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult StartComment(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '*', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '*', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '*', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment, (void*) "CComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CppComment, "CppComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '/', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CppComment, (void*) "CppComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CppComment, "CppComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkUnexpected, "TkUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n7, n8 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkUnexpected, (void*) "TkUnexpected"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkUnexpected, "TkUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult VariableIndex(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'a', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'a', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'a', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'b', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'b', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'b', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'b'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'c', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'c', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'c', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'd', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'e', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'f', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'f', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'f', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'f'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'f' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'g', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'g', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'g', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'g'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'g' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'h', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'h', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'h', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'h'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'h' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'i', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'i', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'i', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'j', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'j', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'j', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'j'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'j' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'k', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'k', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'k', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'k'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'k' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'l', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'l', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'l', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'm', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'm', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'm', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'o', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'o', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'o', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'p', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'p', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'p', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'r', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 's', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 't', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'u', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'u', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'u', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'v', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'v', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'v', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'v'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'w', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'w', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'w', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'w'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'w' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'x', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'x', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'x', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'B', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'B'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'C', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'D', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'D'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'D' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'F', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'G', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'G'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'G' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'H', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'H'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'H' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'I', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'J', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'J'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'J' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'K', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'K'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'K' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'M' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'O', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'P' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'V', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'V'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'V' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'X', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '_', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '_', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '_', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '_'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '_' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '-', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '-'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '-' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_open_call( n27 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_name( n28, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_open_bracket( n29 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_close_bracket( n30 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_close_call( n31 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n29, n30 );
    refalrts::push_stack( n31 );
    refalrts::push_stack( n27 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n27, n30 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n4, n26 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'v'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'b'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_close_bracket( n28 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_open_call( n29 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_name( n30, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_open_bracket( n31 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_close_bracket( n32 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_close_call( n33 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n33 );
    refalrts::push_stack( n29 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n31, n32 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    refalrts::link_brackets( n4, n28 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult DirectiveTail(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'B', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'B'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'C', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'D', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'D'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'D' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'F', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'G', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'G'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'G' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'H', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'H'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'H' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'I', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'J', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'J'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'J' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'K', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'K'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'K' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'M' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'O', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'P' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'V', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'V'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'V' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'X', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DirectiveTail, (void*) "DirectiveTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & DirectiveTail, "DirectiveTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n7, n8 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkDirective, (void*) "TkDirective"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkDirective, "TkDirective" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult StringLiteral(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\\ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\\', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & StringLiteral_Escape, "StringLiteral_Escape" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\\ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\\', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\\ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\\', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral_Escape, (void*) "StringLiteral_Escape"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StringLiteral_Escape, "StringLiteral_Escape" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & StringLiteral_Quote, "StringLiteral_Quote" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\'', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral_Quote, (void*) "StringLiteral_Quote"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StringLiteral_Quote, "StringLiteral_Quote" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_call( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_open_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_close_call( n23 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n3, & TokenError, "TokenError" );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n21, n22 );
    refalrts::push_stack( n23 );
    refalrts::push_stack( n19 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n19, n22 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n5, n18 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'q'},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_open_call( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_name( n23, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_open_bracket( n24 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_close_bracket( n25 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_close_call( n26 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n26 );
    refalrts::push_stack( n22 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n24, n25 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    refalrts::link_brackets( n5, n21 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'g' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_char( n32, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_char( n33, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_char( n34, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_char( n35, 'l' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n3, n35 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'g'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'g' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_char( n32, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_char( n33, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_char( n34, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_char( n35, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n36 = 0;
    if( ! refalrts::alloc_char( n36, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n37 = 0;
    if( ! refalrts::alloc_close_bracket( n37 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n3, n37 );
    res = refalrts::splice_elem( res, n37 );
    res = refalrts::splice_elem( res, n36 );
    res = refalrts::splice_elem( res, n35 );
    res = refalrts::splice_elem( res, n34 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sAny_1 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Char, (void*) "TkLiteral_Char"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icSpliceSTVar, & sAny_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sAny_1 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult CComment(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CComment_CheckNested, "CComment_CheckNested" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '/', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment_CheckNested, (void*) "CComment_CheckNested"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CComment_CheckNested, "CComment_CheckNested" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '*', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CComment_CheckEnd, "CComment_CheckEnd" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '*', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '*', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment_CheckEnd, (void*) "CComment_CheckEnd"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CComment_CheckEnd, "CComment_CheckEnd" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkNewLine, "TkNewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkNewLine, (void*) "TkNewLine"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '\n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment, (void*) "CComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkNewLine, "TkNewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '\n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment, (void*) "CComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, ':' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_char( n32, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_char( n33, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_char( n34, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_char( n35, 't' ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n3, n35 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icChar, 0, 0, ':'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, ':' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_char( n32, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_char( n33, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_char( n34, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_char( n35, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n36 = 0;
    if( ! refalrts::alloc_char( n36, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n37 = 0;
    if( ! refalrts::alloc_close_bracket( n37 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n3, n37 );
    res = refalrts::splice_elem( res, n37 );
    res = refalrts::splice_elem( res, n36 );
    res = refalrts::splice_elem( res, n35 );
    res = refalrts::splice_elem( res, n34 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult CppComment(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkNewLine, "TkNewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkNewLine, (void*) "TkNewLine"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '\n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkNewLine, "TkNewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '\n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TkEOF, "TkEOF" ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkEOF, (void*) "TkEOF"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkEOF, "TkEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CppComment, "CppComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sAny_1;
    refalrts::use( sAny_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Any e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sAny_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CppComment, (void*) "CppComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & CppComment, "CppComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult VariableIndexTail(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'a', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'a', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'a e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'a', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'b', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'b', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'b e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'b', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'b'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'c', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'c', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'c e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'c', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'd', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'e', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'e e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'e', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'f', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'f', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'f e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'f', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'f'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'f' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'g', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'g', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'g e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'g', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'g'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'g' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'h', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'h', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'h e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'h', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'h'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'h' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'i', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'i', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'i e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'i', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'j', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'j', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'j e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'j', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'j'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'j' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'k', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'k', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'k e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'k', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'k'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'k' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'l', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'l', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'l e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'l', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'm', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'm', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'm e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'm', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'o', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'o', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'o e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'o', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'p', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'p', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'p e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'p', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'r', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 's', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 's e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 's', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 't', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'u', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'u', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'u e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'u', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'v', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'v', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'v e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'v', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'v'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'v' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'w', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'w', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'w e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'w', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'w'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'w' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'x', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'x', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'x e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'x', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'A', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'A e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'A', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'B', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'B e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'B', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'B'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'B' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'C', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'C e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'C', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'D', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'D e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'D', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'D'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'D' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'E', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'E e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'E', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'F', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'F e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'F', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'F'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'F' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'G', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'G e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'G', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'G'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'G' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'H', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'H e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'H', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'H'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'H' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'I', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'I e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'I', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'J', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'J e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'J', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'J'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'J' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'K', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'K e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'K', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'K'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'K' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'L', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'L e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'L', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'M', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'M e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'M', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'M'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'M' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'N', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'N e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'N', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'O', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'O e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'O', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'P', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'P e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'P', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'P'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'P' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Q', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Q e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Q', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Q'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'R', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'R e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'R', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'S', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'S e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'S', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'T', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'T e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'T', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'U', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'U e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'U', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'V', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'V e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'V', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'V'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'V' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'W', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'W e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'W', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'W'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'W' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'X', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'X e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'X', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'X'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'X' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Y', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Y e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Y', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Y'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Y' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'Z', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'Z e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'Z', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'Z'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'Z' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '_', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '_', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '_ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '_', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '_'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '_' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '-', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '- e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '-', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & VariableIndexTail, (void*) "VariableIndexTail"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '-'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & VariableIndexTail, "VariableIndexTail" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '-' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkVariable, "TkVariable" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n7, n8 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkVariable, "TkVariable" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult StringLiteral_Escape(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_NewLine, "TkLiteral_NewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_NewLine, (void*) "TkLiteral_NewLine"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_NewLine, "TkLiteral_NewLine" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_CarriageReturn, "TkLiteral_CarriageReturn" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'r', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'r e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'r', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_CarriageReturn, (void*) "TkLiteral_CarriageReturn"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 'r'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_CarriageReturn, "TkLiteral_CarriageReturn" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'r' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Tab, "TkLiteral_Tab" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 't', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 't e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 't', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Tab, (void*) "TkLiteral_Tab"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Tab, "TkLiteral_Tab" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\\ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\\', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\\ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\\', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\\ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\\', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Char, (void*) "TkLiteral_Char"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '\\'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '\\' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\'', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Char, (void*) "TkLiteral_Char"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '\''},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '\'' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & StringLiteral_Escape_Code, "StringLiteral_Escape_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( 'd', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 'd e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( 'd', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral_Escape_Code, (void*) "StringLiteral_Escape_Code"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StringLiteral_Escape_Code, "StringLiteral_Escape_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_call( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_open_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_close_call( n23 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n3, & TokenError, "TokenError" );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n21, n22 );
    refalrts::push_stack( n23 );
    refalrts::push_stack( n19 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n19, n22 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n5, n18 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\n', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\n e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'q'},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_open_call( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_name( n23, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_open_bracket( n24 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_close_bracket( n25 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_close_call( n26 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n26 );
    refalrts::push_stack( n22 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n24, n25 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    refalrts::link_brackets( n5, n21 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_open_call( n31 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_name( n32, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_open_bracket( n33 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_close_bracket( n34 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_close_call( n35 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n33, n34 );
    refalrts::push_stack( n35 );
    refalrts::push_stack( n31 );
    res = refalrts::splice_elem( res, n35 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n31, n34 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n4, n30 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'U'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'q'},
      {refalrts::icChar, 0, 0, 'u'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'U' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'q' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'u' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_close_bracket( n32 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_open_call( n33 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_name( n34, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_open_bracket( n35 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n36 = 0;
    if( ! refalrts::alloc_close_bracket( n36 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n37 = 0;
    if( ! refalrts::alloc_close_call( n37 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n37 );
    refalrts::push_stack( n33 );
    res = refalrts::splice_elem( res, n37 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n35, n36 );
    res = refalrts::splice_elem( res, n36 );
    res = refalrts::splice_elem( res, n35 );
    res = refalrts::splice_elem( res, n34 );
    res = refalrts::splice_elem( res, n33 );
    refalrts::link_brackets( n4, n32 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult StringLiteral_Quote(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '\'', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '\' e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '\'', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Char, (void*) "TkLiteral_Char"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '\''},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Char, "TkLiteral_Char" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '\'' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n4, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n6, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult CComment_CheckNested(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '*', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_open_call( n32 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_name( n33, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_open_bracket( n34 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_close_bracket( n35 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n36 = 0;
    if( ! refalrts::alloc_close_call( n36 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n3, & TokenError, "TokenError" );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n34, n35 );
    refalrts::push_stack( n36 );
    refalrts::push_stack( n32 );
    res = refalrts::splice_elem( res, n36 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n32, n35 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n5, n31 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '*', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '* e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '*', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'o'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 's'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'b'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment, (void*) "CComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'o' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 's' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'b' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_char( n32, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_char( n33, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n34 = 0;
    if( ! refalrts::alloc_close_bracket( n34 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n35 = 0;
    if( ! refalrts::alloc_open_call( n35 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n36 = 0;
    if( ! refalrts::alloc_name( n36, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n37 = 0;
    if( ! refalrts::alloc_open_bracket( n37 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n38 = 0;
    if( ! refalrts::alloc_close_bracket( n38 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n39 = 0;
    if( ! refalrts::alloc_close_call( n39 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n39 );
    refalrts::push_stack( n35 );
    res = refalrts::splice_elem( res, n39 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n37, n38 );
    res = refalrts::splice_elem( res, n38 );
    res = refalrts::splice_elem( res, n37 );
    res = refalrts::splice_elem( res, n36 );
    res = refalrts::splice_elem( res, n35 );
    refalrts::link_brackets( n5, n34 );
    res = refalrts::splice_elem( res, n34 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n4, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment, (void*) "CComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n6, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult CComment_CheckEnd(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '/', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '/ e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '/', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n4, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & CComment, (void*) "CComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & CComment, "CComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n6, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult StringLiteral_Escape_Code(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C1, (void*) "SL_E_C1"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C1, "SL_E_C1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'g' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_open_call( n27 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_name( n28, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_open_bracket( n29 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_close_bracket( n30 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_close_call( n31 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n29, n30 );
    refalrts::push_stack( n31 );
    refalrts::push_stack( n27 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n27, n30 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elems( res, n4, n26 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenError, (void*) "TokenError"},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'x'},
      {refalrts::icChar, 0, 0, 'p'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icChar, 0, 0, 'c'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'm'},
      {refalrts::icChar, 0, 0, 'a'},
      {refalrts::icChar, 0, 0, 'l'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'd'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 'g'},
      {refalrts::icChar, 0, 0, 'i'},
      {refalrts::icChar, 0, 0, 't'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenError, "TokenError" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'x' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'p' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_char( n14, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_char( n16, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_char( n17, 'c' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_char( n18, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_char( n19, 'm' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, 'a' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, 'l' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, 'd' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'g' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'i' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 't' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_close_bracket( n28 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_open_call( n29 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_name( n30, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_open_bracket( n31 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_close_bracket( n32 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n33 = 0;
    if( ! refalrts::alloc_close_call( n33 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n33 );
    refalrts::push_stack( n29 );
    res = refalrts::splice_elem( res, n33 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n31, n32 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    refalrts::link_brackets( n4, n28 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult SL_E_C1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SL_E_C2, (void*) "SL_E_C2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & SL_E_C2, "SL_E_C2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n7, n8 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult SL_E_C2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '0', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '0 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '0', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '0'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '0' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '1', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '1', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '1'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '1' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '2', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '2 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '2', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '2'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '2' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '3', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '3 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '3', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '3'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '3' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '4', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '4 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '4', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '4'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '4' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '5', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '5 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '5', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '5'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '5' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '6', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '6 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '6', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '6'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '6' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '7', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '7 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '7', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '7'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '7' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '8', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '8 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '8', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '8'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '8' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::char_left( '9', bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 '9 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::char_left( '9', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icChar, 0, 0, '9'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, '9' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n5, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n7, n8 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TkLiteral_Code, (void*) "TkLiteral_Code"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & StringLiteral, (void*) "StringLiteral"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TkLiteral_Code, "TkLiteral_Code" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & StringLiteral, "StringLiteral" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n8, n9 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    res = refalrts::splice_elems( res, n6, n9 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sUnexpected_1;
    refalrts::use( sUnexpected_1 );
    static refalrts::Iter eText_b_1;
    refalrts::use( eText_b_1 );
    static refalrts::Iter eText_e_1;
    refalrts::use( eText_e_1 );
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#else
    // (~1 e.Accum )~1 s.Unexpected e.Text
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
    if( ! refalrts::svar_left( sUnexpected_1, bb_0, be_0 ) ) 
      break;
    eText_b_1 = bb_0;
    refalrts::use( eText_b_1 );
    eText_e_1 = be_0;
    refalrts::use( eText_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpected, (void*) "TokenUnexpected"},
      {refalrts::icSpliceSTVar, & sUnexpected_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Root, (void*) "Root"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eText_b_1, & eText_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & TokenUnexpected, "TokenUnexpected" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Root, "Root" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n12 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eText_b_1, eText_e_1 );
    refalrts::link_brackets( n10, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n5, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, sUnexpected_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elems( res, n4, n6 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eAccum_b_1;
    refalrts::use( eAccum_b_1 );
    static refalrts::Iter eAccum_e_1;
    refalrts::use( eAccum_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#else
    // (~1 e.Accum )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eAccum_b_1 = bb_1;
    refalrts::use( eAccum_b_1 );
    eAccum_e_1 = be_1;
    refalrts::use( eAccum_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenAccum, (void*) "TokenAccum"},
      {refalrts::icSpliceEVar, & eAccum_b_1, & eAccum_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & TokenUnexpectedEOF, (void*) "TokenUnexpectedEOF"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & TokenAccum, "TokenAccum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & TokenUnexpectedEOF, "TokenUnexpectedEOF" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eAccum_b_1, eAccum_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}


//End of file
