// Automatically generated file. Don't edit!
#include "refalrts.h"


extern refalrts::FnResult CmdChar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdName(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdIdent(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdBrackets(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdADT(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdEmpty(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdRepeated(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdVar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdOpenedE(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdClosedE(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdAllocateElem(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdLinkBrackets(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdPushStack(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdInsertElem(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdInsertEVar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElChar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElName(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElIdent(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElOpenADT(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElCloseADT(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElOpenBracket(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElCloseBracket(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElOpenCall(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElCloseCall(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElElem(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElSTVar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ElSeq(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdEmptyResult(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdReturnResult(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdIfDef(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdElse(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdEndIf(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdInitRAA(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdFinRAA(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdDeclareEVar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdDeclareVar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdCopyEVar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdCopyVar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult AlgLeft(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult AlgRight(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdComment(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdPrint(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrChar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrInt(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrFunc(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrIdent(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrOB(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrCB(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrOADT(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrCADT(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrOC(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrCC(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrSplice(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdArrCopy(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkOpenBracket(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkCloseBracket(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkOpenADT(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkCloseADT(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkName(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkVariable(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkChar(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkOpenCall(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkCloseCall(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult TkIdentifier(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult AlgMatch(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdTerm(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdInner(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult CmdReinitElem(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult Map(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult Inc(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult Fetch(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult EnumeratePattern(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult GenPattern_v2(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult GenResult(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult VarSetUnion(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult VarSetDifference(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult ReplicateVars(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult MakeDeclaration(refalrts::Iter arg_begin, refalrts::Iter arg_end);

extern refalrts::FnResult MakeAlgorithm_v2(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult lambda_MakeAlgorithm_v2_0(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
    static refalrts::Iter eScannedPattern_b_1;
    refalrts::use( eScannedPattern_b_1 );
    static refalrts::Iter eScannedPattern_e_1;
    refalrts::use( eScannedPattern_e_1 );
    static refalrts::Iter eCommands_b_1;
    refalrts::use( eCommands_b_1 );
    static refalrts::Iter eCommands_e_1;
    refalrts::use( eCommands_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    // (~4 e.Result )~4 s.Total (~1 e.Vars )~1 (~2 e.ScannedPattern )~2 (~3 e.Commands )~3
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n10;
    if( (n10 = refalrts::brackets_right( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n10 );
    refalrts::Iter n12 = 0; // Right
    if( ! refalrts::brackets_match( n12, n10 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n4;
    if( (n4 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n4 ) ) 
      break;
    eResult_b_1 = bb_4;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_4;
    refalrts::use( eResult_e_1 );
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eScannedPattern_b_1 = bb_2;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_2;
    refalrts::use( eScannedPattern_e_1 );
    eCommands_b_1 = bb_3;
    refalrts::use( eCommands_b_1 );
    eCommands_e_1 = be_3;
    refalrts::use( eCommands_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_name( n13, & ReplicateVars, "ReplicateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & GenResult, "GenResult" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n7 );
    refalrts::reinit_name( n10, & Map, "Map" );
    refalrts::reinit_name( n9, & MakeDeclaration, "MakeDeclaration" );
    refalrts::reinit_open_call( n12 );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n4, n6 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n12 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eScannedPattern_b_1, eScannedPattern_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n16, n17 );
    res = refalrts::splice_evar( res, eCommands_b_1, eCommands_e_1 );
    res = refalrts::splice_elems( res, n14, n15 );
    res = refalrts::splice_evar( res, eVars_b_1, eVars_e_1 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
    static refalrts::Iter eScannedPattern_b_1;
    refalrts::use( eScannedPattern_b_1 );
    static refalrts::Iter eScannedPattern_e_1;
    refalrts::use( eScannedPattern_e_1 );
    static refalrts::Iter eCommands_b_1;
    refalrts::use( eCommands_b_1 );
    static refalrts::Iter eCommands_e_1;
    refalrts::use( eCommands_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
#ifdef OLD_PATTERN
    // (~4 e.Result )~4 s.Total (~1 e.Vars )~1 (~2 e.ScannedPattern )~2 (~3 e.Commands )~3
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_right( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_right( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eResult_b_1 = bb_4;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_4;
    refalrts::use( eResult_e_1 );
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eScannedPattern_b_1 = bb_2;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_2;
    refalrts::use( eScannedPattern_e_1 );
    eCommands_b_1 = bb_3;
    refalrts::use( eCommands_b_1 );
    eCommands_e_1 = be_3;
    refalrts::use( eCommands_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // (~4 e.Result )~4 s.Total (~1 e.Vars )~1 (~2 e.ScannedPattern )~2 (~3 e.Commands )~3
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n10;
    if( (n10 = refalrts::brackets_right( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n10 );
    refalrts::Iter n12 = 0; // Right
    if( ! refalrts::brackets_match( n12, n10 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n4;
    if( (n4 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n4 ) ) 
      break;
    eResult_b_1 = bb_4;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_4;
    refalrts::use( eResult_e_1 );
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eScannedPattern_b_1 = bb_2;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_2;
    refalrts::use( eScannedPattern_e_1 );
    eCommands_b_1 = bb_3;
    refalrts::use( eCommands_b_1 );
    eCommands_e_1 = be_3;
    refalrts::use( eCommands_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Map, (void*) "Map"},
      {refalrts::icFunc, (void*) & MakeDeclaration, (void*) "MakeDeclaration"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & ReplicateVars, (void*) "ReplicateVars"},
      {refalrts::icSpliceEVar, & eVars_b_1, & eVars_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icSpliceEVar, & eCommands_b_1, & eCommands_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & GenResult, (void*) "GenResult"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScannedPattern_b_1, & eScannedPattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & MakeDeclaration, "MakeDeclaration" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & ReplicateVars, "ReplicateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_call( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_open_call( n20 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_name( n21, & GenResult, "GenResult" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_open_bracket( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_close_bracket( n23 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_open_bracket( n24 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_close_bracket( n25 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_close_call( n26 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n26 );
    refalrts::push_stack( n20 );
    res = refalrts::splice_elem( res, n26 );
    refalrts::link_brackets( n24, n25 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n24 );
    refalrts::link_brackets( n22, n23 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_evar( res, eScannedPattern_b_1, eScannedPattern_e_1 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, eCommands_b_1, eCommands_e_1 );
    refalrts::push_stack( n19 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n16 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eVars_b_1, eVars_e_1 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

refalrts::FnResult MakeAlgorithm_v2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    // (~1 e.Pattern )~1 (~2 e.Result )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eResult_b_1 = bb_2;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_2;
    refalrts::use( eResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & GenPattern_v2, "GenPattern_v2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & lambda_MakeAlgorithm_v2_0, "lambda_MakeAlgorithm_v2_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    refalrts::reinit_name( n5, & Fetch, "Fetch" );
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elems( res, n12, n13 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n8, n11 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Pattern )~1 (~2 e.Result )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eResult_b_1 = bb_2;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_2;
    refalrts::use( eResult_e_1 );
#else
    // (~1 e.Pattern )~1 (~2 e.Result )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eResult_b_1 = bb_2;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_2;
    refalrts::use( eResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Fetch, (void*) "Fetch"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & GenPattern_v2, (void*) "GenPattern_v2"},
      {refalrts::icSpliceEVar, & ePattern_b_1, & ePattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & refalrts::create_closure, (void*) "refalrts::create_closure"},
      {refalrts::icFunc, (void*) & lambda_MakeAlgorithm_v2_0, (void*) "lambda_MakeAlgorithm_v2_0"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & GenPattern_v2, "GenPattern_v2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_name( n13, & lambda_MakeAlgorithm_v2_0, "lambda_MakeAlgorithm_v2_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_bracket( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_call( n17 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n17 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n17 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n16 );
    refalrts::link_brackets( n14, n15 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult DoGenResult_FindSamples(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult DoGenResult_FindReuse(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult DoGenResult_EnumerateVars(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult GenResultCommands(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult GenResult(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult lambda_GenResult_0(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter ePreparedResult_b_1;
    refalrts::use( ePreparedResult_b_1 );
    static refalrts::Iter ePreparedResult_e_1;
    refalrts::use( ePreparedResult_e_1 );
    // s.Total e.PreparedResult
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    ePreparedResult_b_1 = bb_0;
    refalrts::use( ePreparedResult_b_1 );
    ePreparedResult_e_1 = be_0;
    refalrts::use( ePreparedResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & GenResultCommands, "GenResultCommands" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, ePreparedResult_b_1, ePreparedResult_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter ePreparedResult_b_1;
    refalrts::use( ePreparedResult_b_1 );
    static refalrts::Iter ePreparedResult_e_1;
    refalrts::use( ePreparedResult_e_1 );
#ifdef OLD_PATTERN
    // s.Total e.PreparedResult
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    ePreparedResult_b_1 = bb_0;
    refalrts::use( ePreparedResult_b_1 );
    ePreparedResult_e_1 = be_0;
    refalrts::use( ePreparedResult_e_1 );
#else
    // s.Total e.PreparedResult
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    ePreparedResult_b_1 = bb_0;
    refalrts::use( ePreparedResult_b_1 );
    ePreparedResult_e_1 = be_0;
    refalrts::use( ePreparedResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & GenResultCommands, (void*) "GenResultCommands"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icSpliceEVar, & ePreparedResult_b_1, & ePreparedResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & GenResultCommands, "GenResultCommands" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, ePreparedResult_b_1, ePreparedResult_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult lambda_GenResult_1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern1_b_1;
    refalrts::use( ePattern1_b_1 );
    static refalrts::Iter ePattern1_e_1;
    refalrts::use( ePattern1_e_1 );
    static refalrts::Iter eResult1_b_1;
    refalrts::use( eResult1_b_1 );
    static refalrts::Iter eResult1_e_1;
    refalrts::use( eResult1_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    // s.Total (~1 e.Pattern1 )~1 (~2 e.Result1 )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n4;
    if( (n4 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n4 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n1 ) ) 
      break;
    ePattern1_b_1 = bb_1;
    refalrts::use( ePattern1_b_1 );
    ePattern1_e_1 = be_1;
    refalrts::use( ePattern1_e_1 );
    eResult1_b_1 = bb_2;
    refalrts::use( eResult1_b_1 );
    eResult1_e_1 = be_2;
    refalrts::use( eResult1_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_name( n13, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & lambda_GenResult_0, "lambda_GenResult_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n3 );
    refalrts::link_brackets( n4, n6 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elems( res, n15, n16 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n11, n14 );
    res = refalrts::splice_evar( res, eResult1_b_1, eResult1_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elems( res, n3, n4 );
    res = refalrts::splice_evar( res, ePattern1_b_1, ePattern1_e_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elems( res, n7, n10 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter ePattern1_b_1;
    refalrts::use( ePattern1_b_1 );
    static refalrts::Iter ePattern1_e_1;
    refalrts::use( ePattern1_e_1 );
    static refalrts::Iter eResult1_b_1;
    refalrts::use( eResult1_b_1 );
    static refalrts::Iter eResult1_e_1;
    refalrts::use( eResult1_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
#ifdef OLD_PATTERN
    // s.Total (~1 e.Pattern1 )~1 (~2 e.Result1 )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_right( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    ePattern1_b_1 = bb_1;
    refalrts::use( ePattern1_b_1 );
    ePattern1_e_1 = be_1;
    refalrts::use( ePattern1_e_1 );
    eResult1_b_1 = bb_2;
    refalrts::use( eResult1_b_1 );
    eResult1_e_1 = be_2;
    refalrts::use( eResult1_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // s.Total (~1 e.Pattern1 )~1 (~2 e.Result1 )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n4;
    if( (n4 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n4 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n1 ) ) 
      break;
    ePattern1_b_1 = bb_1;
    refalrts::use( ePattern1_b_1 );
    ePattern1_e_1 = be_1;
    refalrts::use( ePattern1_e_1 );
    eResult1_b_1 = bb_2;
    refalrts::use( eResult1_b_1 );
    eResult1_e_1 = be_2;
    refalrts::use( eResult1_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Fetch, (void*) "Fetch"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & ePattern1_b_1, & ePattern1_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult1_b_1, & eResult1_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & refalrts::create_closure, (void*) "refalrts::create_closure"},
      {refalrts::icFunc, (void*) & lambda_GenResult_0, (void*) "lambda_GenResult_0"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_name( n18, & lambda_GenResult_0, "lambda_GenResult_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_call( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n20 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n20 );
    refalrts::push_stack( n19 );
    refalrts::push_stack( n16 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eResult1_b_1, eResult1_e_1 );
    refalrts::link_brackets( n13, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, ePattern1_b_1, ePattern1_e_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult lambda_GenResult_2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScannedPattern_b_1;
    refalrts::use( eScannedPattern_b_1 );
    static refalrts::Iter eScannedPattern_e_1;
    refalrts::use( eScannedPattern_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eNumResult_b_1;
    refalrts::use( eNumResult_b_1 );
    static refalrts::Iter eNumResult_e_1;
    refalrts::use( eNumResult_e_1 );
    // (~1 e.ScannedPattern )~1 s.Total e.NumResult
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eScannedPattern_b_1 = bb_1;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_1;
    refalrts::use( eScannedPattern_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    eNumResult_b_1 = bb_0;
    refalrts::use( eNumResult_b_1 );
    eNumResult_e_1 = be_0;
    refalrts::use( eNumResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_name( n13, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & lambda_GenResult_1, "lambda_GenResult_1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n9, n10 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n5 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elems( res, n15, n16 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n11, n14 );
    res = refalrts::splice_evar( res, eNumResult_b_1, eNumResult_e_1 );
    res = refalrts::splice_elems( res, n9, n10 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eScannedPattern_b_1, eScannedPattern_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n5, n8 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eScannedPattern_b_1;
    refalrts::use( eScannedPattern_b_1 );
    static refalrts::Iter eScannedPattern_e_1;
    refalrts::use( eScannedPattern_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eNumResult_b_1;
    refalrts::use( eNumResult_b_1 );
    static refalrts::Iter eNumResult_e_1;
    refalrts::use( eNumResult_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.ScannedPattern )~1 s.Total e.NumResult
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eScannedPattern_b_1 = bb_1;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_1;
    refalrts::use( eScannedPattern_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    eNumResult_b_1 = bb_0;
    refalrts::use( eNumResult_b_1 );
    eNumResult_e_1 = be_0;
    refalrts::use( eNumResult_e_1 );
#else
    // (~1 e.ScannedPattern )~1 s.Total e.NumResult
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eScannedPattern_b_1 = bb_1;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_1;
    refalrts::use( eScannedPattern_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    eNumResult_b_1 = bb_0;
    refalrts::use( eNumResult_b_1 );
    eNumResult_e_1 = be_0;
    refalrts::use( eNumResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Fetch, (void*) "Fetch"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScannedPattern_b_1, & eScannedPattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eNumResult_b_1, & eNumResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & refalrts::create_closure, (void*) "refalrts::create_closure"},
      {refalrts::icFunc, (void*) & lambda_GenResult_1, (void*) "lambda_GenResult_1"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_name( n16, & lambda_GenResult_1, "lambda_GenResult_1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_call( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n18 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n18 );
    refalrts::push_stack( n17 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eNumResult_b_1, eNumResult_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::link_brackets( n9, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eScannedPattern_b_1, eScannedPattern_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult GenResult(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScannedPattern_b_1;
    refalrts::use( eScannedPattern_b_1 );
    static refalrts::Iter eScannedPattern_e_1;
    refalrts::use( eScannedPattern_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    // s.Total (~1 e.ScannedPattern )~1 (~2 e.Result )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n4;
    if( (n4 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n4 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n1 ) ) 
      break;
    eScannedPattern_b_1 = bb_1;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_1;
    refalrts::use( eScannedPattern_e_1 );
    eResult_b_1 = bb_2;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_2;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_name( n13, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & lambda_GenResult_2, "lambda_GenResult_2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n3 );
    refalrts::link_brackets( n4, n6 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elems( res, n15, n16 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eScannedPattern_b_1, eScannedPattern_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elems( res, n11, n14 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elems( res, n7, n10 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eScannedPattern_b_1;
    refalrts::use( eScannedPattern_b_1 );
    static refalrts::Iter eScannedPattern_e_1;
    refalrts::use( eScannedPattern_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
#ifdef OLD_PATTERN
    // s.Total (~1 e.ScannedPattern )~1 (~2 e.Result )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_right( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eScannedPattern_b_1 = bb_1;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_1;
    refalrts::use( eScannedPattern_e_1 );
    eResult_b_1 = bb_2;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_2;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // s.Total (~1 e.ScannedPattern )~1 (~2 e.Result )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n4;
    if( (n4 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n4 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n4 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n1 ) ) 
      break;
    eScannedPattern_b_1 = bb_1;
    refalrts::use( eScannedPattern_b_1 );
    eScannedPattern_e_1 = be_1;
    refalrts::use( eScannedPattern_e_1 );
    eResult_b_1 = bb_2;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_2;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Fetch, (void*) "Fetch"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_EnumerateVars, (void*) "DoGenResult_EnumerateVars"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & refalrts::create_closure, (void*) "refalrts::create_closure"},
      {refalrts::icFunc, (void*) & lambda_GenResult_2, (void*) "lambda_GenResult_2"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScannedPattern_b_1, & eScannedPattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & refalrts::create_closure, "refalrts::create_closure" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_name( n16, & lambda_GenResult_2, "lambda_GenResult_2" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_open_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_call( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n20 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n20 );
    refalrts::push_stack( n19 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    refalrts::link_brackets( n17, n18 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eScannedPattern_b_1, eScannedPattern_e_1 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    refalrts::link_brackets( n11, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Sample(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult FullReuse(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult PartReuse(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Alloc(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult NoNum(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult DoGenResult_EnumerateVars(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter sMode_2;
    refalrts::use( sMode_2 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
    static refalrts::Iter eVars_B_b_1;
    refalrts::use( eVars_B_b_1 );
    static refalrts::Iter eVars_B_e_1;
    refalrts::use( eVars_B_e_1 );
    static refalrts::Iter eVars_E_b_1;
    refalrts::use( eVars_E_b_1 );
    static refalrts::Iter eVars_E_e_1;
    refalrts::use( eVars_E_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    // (~1 e.Vars_B (~2 s.Mode s.Num e.Index )~2 e.Vars_E )~1 (~3 & TkVariable s.Mode e.Index )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n13 = 0; // Right
    if( ! refalrts::brackets_match( n13, n9 ) ) 
      break;
    refalrts::Iter n10;
    if( (n10 = refalrts::function_left( & TkVariable, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n10 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sMode_1, bb_3, be_3 ) ) 
      break;
    eIndex_b_1 = bb_3;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_3;
    refalrts::use( eIndex_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eVars_B_b_1 = bb_1_stk,
        eVars_B_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eVars_B_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eVars_B_oe_1, be_1 )
    ) {
      bb_1 = eVars_B_oe_1;
      eVars_B_b_1 = bb_1_stk;
      eVars_B_e_1 = eVars_B_oe_1;
      refalrts::move_right( eVars_B_b_1, eVars_B_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sMode_2, sMode_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_right( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1, bb_2, be_2 ) ) 
        continue;
      eVars_E_b_1 = bb_1;
      refalrts::use( eVars_E_b_1 );
      eVars_E_e_1 = be_1;
      refalrts::use( eVars_E_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      refalrts::Iter n15 = 0;
      if( ! refalrts::alloc_name( n15, & Alloc, "Alloc" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n16 = 0;
      if( ! refalrts::alloc_open_call( n16 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n17 = 0;
      if( ! refalrts::alloc_name( n17, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n18 = 0;
      if( ! refalrts::alloc_open_call( n18 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_name( n19, & Inc, "Inc" ) )
        return refalrts::cNoMemory;
      static refalrts::Iter sNum_2;
      refalrts::use( sNum_2 );
      if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_close_call( n20 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_close_call( n21 ) )
        return refalrts::cNoMemory;
      //}}} ALLOCS
      //{{{ REINITS
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n13 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n21 );
      refalrts::push_stack( n16 );
      refalrts::push_stack( n20 );
      refalrts::push_stack( n18 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_evar( res, eVars_E_b_1, eVars_E_e_1 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_stvar( res, sNum_2 );
      res = refalrts::splice_elems( res, n18, n19 );
      res = refalrts::splice_stvar( res, sMode_2 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eVars_B_b_1, eVars_B_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elems( res, n16, n17 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
      res = refalrts::splice_stvar( res, sMode_1 );
      res = refalrts::splice_elem( res, n10 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_elem( res, n0 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter sMode_2;
    refalrts::use( sMode_2 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
    static refalrts::Iter eVars_B_b_1;
    refalrts::use( eVars_B_b_1 );
    static refalrts::Iter eVars_B_e_1;
    refalrts::use( eVars_B_e_1 );
    static refalrts::Iter eVars_E_b_1;
    refalrts::use( eVars_E_b_1 );
    static refalrts::Iter eVars_E_e_1;
    refalrts::use( eVars_E_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
#ifdef OLD_PATTERN
    // (~1 e.Vars_B (~2 s.Mode s.Num e.Index )~2 e.Vars_E )~1 (~3 & TkVariable s.Mode e.Index )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_3, be_3 ) ) 
      break;
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sMode_1, bb_3, be_3 ) ) 
      break;
    eIndex_b_1 = bb_3;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_3;
    refalrts::use( eIndex_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eVars_B_b_1 = bb_1_stk,
        eVars_B_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eVars_B_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eVars_B_oe_1, be_1 )
    ) {
      bb_1 = eVars_B_oe_1;
      eVars_B_b_1 = bb_1_stk;
      eVars_B_e_1 = eVars_B_oe_1;
      refalrts::move_right( eVars_B_b_1, eVars_B_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sMode_2, sMode_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_right( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1, bb_2, be_2 ) ) 
        continue;
      eVars_E_b_1 = bb_1;
      refalrts::use( eVars_E_b_1 );
      eVars_E_e_1 = be_1;
      refalrts::use( eVars_E_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;
#else
    // (~1 e.Vars_B (~2 s.Mode s.Num e.Index )~2 e.Vars_E )~1 (~3 & TkVariable s.Mode e.Index )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n13 = 0; // Right
    if( ! refalrts::brackets_match( n13, n9 ) ) 
      break;
    refalrts::Iter n10;
    if( (n10 = refalrts::function_left( & TkVariable, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n10 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sMode_1, bb_3, be_3 ) ) 
      break;
    eIndex_b_1 = bb_3;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_3;
    refalrts::use( eIndex_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eVars_B_b_1 = bb_1_stk,
        eVars_B_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eVars_B_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eVars_B_oe_1, be_1 )
    ) {
      bb_1 = eVars_B_oe_1;
      eVars_B_b_1 = bb_1_stk;
      eVars_B_e_1 = eVars_B_oe_1;
      refalrts::move_right( eVars_B_b_1, eVars_B_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sMode_2, sMode_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_right( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1, bb_2, be_2 ) ) 
        continue;
      eVars_E_b_1 = bb_1;
      refalrts::use( eVars_E_b_1 );
      eVars_E_e_1 = be_1;
      refalrts::use( eVars_E_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
        {refalrts::icSpliceSTVar, & sNum_1},
        {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
        {refalrts::icSpliceSTVar, & sMode_1},
        {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_EnumerateVars, (void*) "DoGenResult_EnumerateVars"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eVars_B_b_1, & eVars_B_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceSTVar, & sMode_2},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & Inc, (void*) "Inc"},
        {refalrts::icCopySTVar, & sNum_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icSpliceEVar, & eIndex_b_2, & eIndex_e_2},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eVars_E_b_1, & eVars_E_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n15 = 0;
      if( ! refalrts::alloc_open_bracket( n15 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n16 = 0;
      if( ! refalrts::alloc_name( n16, & Alloc, "Alloc" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n17 = 0;
      if( ! refalrts::alloc_name( n17, & TkVariable, "TkVariable" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n18 = 0;
      if( ! refalrts::alloc_close_bracket( n18 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_open_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_call( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_name( n24, & Inc, "Inc" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_close_call( n25 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n21, n27 );
      res = refalrts::splice_elem( res, n27 );
      res = refalrts::splice_evar( res, eVars_E_b_1, eVars_E_e_1 );
      refalrts::link_brackets( n22, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
      refalrts::push_stack( n25 );
      refalrts::push_stack( n23 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_stvar( res, sNum_2 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_elem( res, n23 );
      res = refalrts::splice_stvar( res, sMode_2 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eVars_B_b_1, eVars_B_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::link_brackets( n15, n18 );
      res = refalrts::splice_elem( res, n18 );
      res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
      res = refalrts::splice_stvar( res, sMode_1 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n16 );
      res = refalrts::splice_elem( res, n15 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // (~1 e.Vars )~1 (~2 & TkVariable s.Mode e.Index )~2 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n7 = 0; // Right
    if( ! refalrts::brackets_match( n7, n3 ) ) 
      break;
    refalrts::Iter n4;
    if( (n4 = refalrts::function_left( & TkVariable, bb_2, be_2 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sMode_1, bb_2, be_2 ) ) 
      break;
    eIndex_b_1 = bb_2;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_2;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_number( n10, 1UL ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    static refalrts::Iter sMode_2;
    refalrts::use( sMode_2 );
    if( ! refalrts::copy_stvar( sMode_2, sMode_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_number( n14, 2UL ) )
      return refalrts::cNoMemory;
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_bracket( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n3, n15 );
    refalrts::link_brackets( n13, n7 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_stvar( res, sMode_2 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eVars_b_1, eVars_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elems( res, n11, n12 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elems( res, n9, n10 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    static refalrts::Iter sMode_2;
    refalrts::use( sMode_2 );
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
#ifdef OLD_PATTERN
    // (~1 e.Vars )~1 (~2 & TkVariable s.Mode e.Index )~2 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_2, be_2 ) ) 
      break;
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sMode_1, bb_2, be_2 ) ) 
      break;
    eIndex_b_1 = bb_2;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_2;
    refalrts::use( eIndex_e_1 );
#else
    // (~1 e.Vars )~1 (~2 & TkVariable s.Mode e.Index )~2 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n7 = 0; // Right
    if( ! refalrts::brackets_match( n7, n3 ) ) 
      break;
    refalrts::Iter n4;
    if( (n4 = refalrts::function_left( & TkVariable, bb_2, be_2 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sMode_1, bb_2, be_2 ) ) 
      break;
    eIndex_b_1 = bb_2;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_2;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icInt, 0, 0, 1 },
      {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
      {refalrts::icSpliceSTVar, & sMode_1},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_EnumerateVars, (void*) "DoGenResult_EnumerateVars"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eVars_b_1, & eVars_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icCopySTVar, & sMode_1},
      {refalrts::icInt, 0, 0, 2 },
      {refalrts::icCopyEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    if( ! refalrts::copy_stvar( sMode_2, sMode_1 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_number( n11, 1UL ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & TkVariable, "TkVariable" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_open_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_number( n18, 2UL ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_bracket( n20 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_call( n21 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n21 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    refalrts::link_brackets( n16, n20 );
    res = refalrts::splice_elem( res, n20 );
    refalrts::link_brackets( n17, n19 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_stvar( res, sMode_2 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, eVars_b_1, eVars_e_1 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::link_brackets( n9, n13 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
    static refalrts::Iter eOtherElement_b_1;
    refalrts::use( eOtherElement_b_1 );
    static refalrts::Iter eOtherElement_e_1;
    refalrts::use( eOtherElement_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    // (~1 e.Vars )~1 (~2 e.OtherElement )~2 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eOtherElement_b_1 = bb_2;
    refalrts::use( eOtherElement_b_1 );
    eOtherElement_e_1 = be_2;
    refalrts::use( eOtherElement_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & NoNum, "NoNum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n3, n5 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eVars_b_1, eVars_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elems( res, n9, n10 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eOtherElement_b_1, eOtherElement_e_1 );
    res = refalrts::splice_elems( res, n7, n8 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
    static refalrts::Iter eOtherElement_b_1;
    refalrts::use( eOtherElement_b_1 );
    static refalrts::Iter eOtherElement_e_1;
    refalrts::use( eOtherElement_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Vars )~1 (~2 e.OtherElement )~2 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eOtherElement_b_1 = bb_2;
    refalrts::use( eOtherElement_b_1 );
    eOtherElement_e_1 = be_2;
    refalrts::use( eOtherElement_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#else
    // (~1 e.Vars )~1 (~2 e.OtherElement )~2 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
    eOtherElement_b_1 = bb_2;
    refalrts::use( eOtherElement_b_1 );
    eOtherElement_e_1 = be_2;
    refalrts::use( eOtherElement_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icFunc, (void*) & NoNum, (void*) "NoNum"},
      {refalrts::icSpliceEVar, & eOtherElement_b_1, & eOtherElement_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_EnumerateVars, (void*) "DoGenResult_EnumerateVars"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eVars_b_1, & eVars_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & NoNum, "NoNum" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & DoGenResult_EnumerateVars, "DoGenResult_EnumerateVars" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n15 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    refalrts::link_brackets( n13, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, eVars_b_1, eVars_e_1 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::link_brackets( n7, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eOtherElement_b_1, eOtherElement_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
    // (~1 e.Vars )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eVars_b_1;
    refalrts::use( eVars_b_1 );
    static refalrts::Iter eVars_e_1;
    refalrts::use( eVars_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Vars )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
#else
    // (~1 e.Vars )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eVars_b_1 = bb_1;
    refalrts::use( eVars_b_1 );
    eVars_e_1 = be_1;
    refalrts::use( eVars_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult DoGenResult_FindSamples(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 e.Begin (~2 & TkOpenBracket s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkOpenBracket s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkOpenBracket, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n13 );
      refalrts::reinit_name( n15, & DoGenResult_FindSamples, "DoGenResult_FindSamples" );
      refalrts::reinit_name( n12, & Sample, "Sample" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n13 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n3 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_elem( res, n13 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkOpenBracket s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkOpenBracket s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenBracket, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkOpenBracket, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkOpenBracket s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkOpenBracket s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkOpenBracket, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
        {refalrts::icSpliceSTVar, & sNum_1},
        {refalrts::icFunc, (void*) & TkOpenBracket, (void*) "TkOpenBracket"},
        {refalrts::icSpliceSTVar, & sBracketNo_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & Sample, "Sample" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_name( n26, & TkOpenBracket, "TkOpenBracket" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_bracket( n28 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n29 = 0;
      if( ! refalrts::alloc_close_call( n29 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n29 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n29 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n28 );
      res = refalrts::splice_elem( res, n28 );
      refalrts::link_brackets( n24, n27 );
      res = refalrts::splice_elem( res, n27 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 e.Begin (~2 & TkCloseBracket s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkCloseBracket s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkCloseBracket, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n13 );
      refalrts::reinit_name( n15, & DoGenResult_FindSamples, "DoGenResult_FindSamples" );
      refalrts::reinit_name( n12, & Sample, "Sample" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n13 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n3 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_elem( res, n13 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkCloseBracket s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkCloseBracket s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseBracket, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkCloseBracket, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkCloseBracket s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkCloseBracket s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkCloseBracket, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
        {refalrts::icSpliceSTVar, & sNum_1},
        {refalrts::icFunc, (void*) & TkCloseBracket, (void*) "TkCloseBracket"},
        {refalrts::icSpliceSTVar, & sBracketNo_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & Sample, "Sample" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_name( n26, & TkCloseBracket, "TkCloseBracket" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_bracket( n28 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n29 = 0;
      if( ! refalrts::alloc_close_call( n29 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n29 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n29 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n28 );
      res = refalrts::splice_elem( res, n28 );
      refalrts::link_brackets( n24, n27 );
      res = refalrts::splice_elem( res, n27 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 e.Begin (~2 & TkOpenADT s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkOpenADT s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkOpenADT, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n13 );
      refalrts::reinit_name( n15, & DoGenResult_FindSamples, "DoGenResult_FindSamples" );
      refalrts::reinit_name( n12, & Sample, "Sample" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n13 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n3 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_elem( res, n13 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkOpenADT s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkOpenADT s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenADT, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkOpenADT, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkOpenADT s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkOpenADT s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkOpenADT, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
        {refalrts::icSpliceSTVar, & sNum_1},
        {refalrts::icFunc, (void*) & TkOpenADT, (void*) "TkOpenADT"},
        {refalrts::icSpliceSTVar, & sBracketNo_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & Sample, "Sample" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_name( n26, & TkOpenADT, "TkOpenADT" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_bracket( n28 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n29 = 0;
      if( ! refalrts::alloc_close_call( n29 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n29 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n29 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n28 );
      res = refalrts::splice_elem( res, n28 );
      refalrts::link_brackets( n24, n27 );
      res = refalrts::splice_elem( res, n27 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 e.Begin (~2 & TkCloseADT s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkCloseADT s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkCloseADT, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n13 );
      refalrts::reinit_name( n15, & DoGenResult_FindSamples, "DoGenResult_FindSamples" );
      refalrts::reinit_name( n12, & Sample, "Sample" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n13 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n3 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_elem( res, n13 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sBracketNo_1;
    refalrts::use( sBracketNo_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sResultNum_1;
    refalrts::use( sResultNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkCloseADT s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkCloseADT s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseADT, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkCloseADT, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkCloseADT s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultNum & TkCloseADT s.BracketNo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkCloseADT, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    if( ! refalrts::svar_left( sBracketNo_1, bb_4, be_4 ) ) 
      break;
    if( ! empty_seq( bb_4, be_4 ) )
      break;
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
        continue;
      eInfo_b_1 = bb_2;
      refalrts::use( eInfo_b_1 );
      eInfo_e_1 = be_2;
      refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
        {refalrts::icSpliceSTVar, & sNum_1},
        {refalrts::icFunc, (void*) & TkCloseADT, (void*) "TkCloseADT"},
        {refalrts::icSpliceSTVar, & sBracketNo_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & Sample, "Sample" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_name( n26, & TkCloseADT, "TkCloseADT" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_bracket( n28 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n29 = 0;
      if( ! refalrts::alloc_close_call( n29 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n29 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n29 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n28 );
      res = refalrts::splice_elem( res, n28 );
      refalrts::link_brackets( n24, n27 );
      res = refalrts::splice_elem( res, n27 );
      res = refalrts::splice_stvar( res, sBracketNo_1 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eInfo_b_2;
    refalrts::use( eInfo_b_2 );
    static refalrts::Iter eInfo_e_2;
    refalrts::use( eInfo_e_2 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    // (~1 e.Begin (~2 & TkVariable s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.Num & TkVariable e.Info )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkVariable, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    eInfo_b_1 = bb_4;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_4;
    refalrts::use( eInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkVariable, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      if( ! refalrts::repeated_stvar_left( sNum_2, sNum_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_left( eInfo_b_2, eInfo_e_2, eInfo_b_1, eInfo_e_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n13 );
      refalrts::reinit_name( n15, & DoGenResult_FindSamples, "DoGenResult_FindSamples" );
      refalrts::reinit_name( n12, & Sample, "Sample" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n13 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
      res = refalrts::splice_elem( res, n3 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_elem( res, n13 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
    static refalrts::Iter eInfo_b_2;
    refalrts::use( eInfo_b_2 );
    static refalrts::Iter eInfo_e_2;
    refalrts::use( eInfo_e_2 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkVariable s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.Num & TkVariable e.Info )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_4, be_4 ) ) 
      break;
    eInfo_b_1 = bb_4;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_4;
    refalrts::use( eInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkVariable, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sNum_2, sNum_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_left( eInfo_b_2, eInfo_e_2, eInfo_b_1, eInfo_e_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
#else
    // (~1 e.Begin (~2 & TkVariable s.Num e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.Num & TkVariable e.Info )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_4, be_4 ) ) 
      break;
    refalrts::Iter n15;
    if( (n15 = refalrts::function_left( & TkVariable, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n15 );
    eInfo_b_1 = bb_4;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_4;
    refalrts::use( eInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkVariable, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      if( ! refalrts::repeated_stvar_left( sNum_2, sNum_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_left( eInfo_b_2, eInfo_e_2, eInfo_b_1, eInfo_e_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
        {refalrts::icSpliceSTVar, & sNum_1},
        {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
        {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & Sample, "Sample" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_name( n26, & TkVariable, "TkVariable" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_bracket( n28 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n29 = 0;
      if( ! refalrts::alloc_close_call( n29 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n29 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n29 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n28 );
      res = refalrts::splice_elem( res, n28 );
      refalrts::link_brackets( n24, n27 );
      res = refalrts::splice_elem( res, n27 );
      res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_stvar( res, sNum_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter sType_2;
    refalrts::use( sType_2 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eInfo_b_2;
    refalrts::use( eInfo_b_2 );
    static refalrts::Iter eInfo_e_2;
    refalrts::use( eInfo_e_2 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    // (~1 e.Begin (~2 s.Type s.PatternPos e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.Info )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eInfo_b_1 = bb_4;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_4;
    refalrts::use( eInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sType_2, sType_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_right( eInfo_b_2, eInfo_e_2, eInfo_b_1, eInfo_e_1, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_close_call( n19 ) )
        return refalrts::cNoMemory;
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n13 );
      refalrts::reinit_name( n12, & DoGenResult_FindSamples, "DoGenResult_FindSamples" );
      refalrts::reinit_name( n17, & Sample, "Sample" );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n19 );
      refalrts::push_stack( n13 );
      res = refalrts::splice_elem( res, n19 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n13 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_2;
    refalrts::use( sType_2 );
    static refalrts::Iter eInfo_b_2;
    refalrts::use( eInfo_b_2 );
    static refalrts::Iter eInfo_e_2;
    refalrts::use( eInfo_e_2 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 s.Type s.PatternPos e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.Info )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eInfo_b_1 = bb_4;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_4;
    refalrts::use( eInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sType_2, sType_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_right( eInfo_b_2, eInfo_e_2, eInfo_b_1, eInfo_e_1, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;
#else
    // (~1 e.Begin (~2 s.Type s.PatternPos e.Info )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.Info )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eInfo_b_1 = bb_4;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_4;
    refalrts::use( eInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sType_2, sType_1, bb_2, be_2 ) ) 
        continue;
      if( ! refalrts::repeated_evar_right( eInfo_b_2, eInfo_e_2, eInfo_b_1, eInfo_e_1, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      if( ! empty_seq( bb_2, be_2 ) )
        continue;
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & Sample, "Sample" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc s.ResultPos s.Type e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Alloc, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_3, be_3 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_3, be_3 ) ) 
      break;
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n3, n11 );
    refalrts::link_brackets( n6, n5 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_stvar( res, sResultPos_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n13, n14 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc s.ResultPos s.Type e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_3, be_3 ) ) 
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_3, be_3 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_3, be_3 ) ) 
      break;
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc s.ResultPos s.Type e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Alloc, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_3, be_3 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_3, be_3 ) ) 
      break;
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_FindSamples, (void*) "DoGenResult_FindSamples"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & ePattern_b_1, & ePattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icSpliceSTVar, & sResultPos_1},
      {refalrts::icSpliceSTVar, & sType_1},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & DoGenResult_FindSamples, "DoGenResult_FindSamples" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_open_bracket( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_open_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_open_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_name( n19, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_bracket( n20 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_call( n22 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n22 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    refalrts::link_brackets( n17, n21 );
    res = refalrts::splice_elem( res, n21 );
    refalrts::link_brackets( n18, n20 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_stvar( res, sResultPos_1 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n17 );
    refalrts::link_brackets( n15, n16 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n3, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
#else
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & ePattern_b_1, & ePattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n8, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n6, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult DoGenResult_FindReuse(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Sample e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Sample, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n3, n9 );
    refalrts::link_brackets( n6, n5 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n11, n12 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Sample e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Sample, bb_3, be_3 ) ) 
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#else
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Sample e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Sample, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & ePattern_b_1, & ePattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_open_bracket( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & Sample, "Sample" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n20 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    refalrts::link_brackets( n15, n19 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::link_brackets( n16, n18 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::link_brackets( n13, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc s.Num & TkVariable s.Type e.Index )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n12 = 0; // Right
    if( ! refalrts::brackets_match( n12, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Alloc, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_3, be_3 ) ) 
      break;
    refalrts::Iter n9;
    if( (n9 = refalrts::function_left( & TkVariable, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n9 );
    if( ! refalrts::svar_left( sType_1, bb_3, be_3 ) ) 
      break;
    eIndex_b_1 = bb_3;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_3;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n3, n12 );
    refalrts::link_brackets( n6, n5 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n14, n15 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc s.Num & TkVariable s.Type e.Index )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_3, be_3 ) ) 
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_3, be_3 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_3, be_3 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_3, be_3 ) ) 
      break;
    eIndex_b_1 = bb_3;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_3;
    refalrts::use( eIndex_e_1 );
#else
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc s.Num & TkVariable s.Type e.Index )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n12 = 0; // Right
    if( ! refalrts::brackets_match( n12, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Alloc, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_3, be_3 ) ) 
      break;
    refalrts::Iter n9;
    if( (n9 = refalrts::function_left( & TkVariable, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n9 );
    if( ! refalrts::svar_left( sType_1, bb_3, be_3 ) ) 
      break;
    eIndex_b_1 = bb_3;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_3;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & ePattern_b_1, & ePattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
      {refalrts::icSpliceSTVar, & sType_1},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_open_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_name( n21, & TkVariable, "TkVariable" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_close_bracket( n23 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_close_call( n24 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n24 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    refalrts::link_brackets( n18, n23 );
    res = refalrts::splice_elem( res, n23 );
    refalrts::link_brackets( n19, n22 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n18 );
    refalrts::link_brackets( n16, n17 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter sType_2;
    refalrts::use( sType_2 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 s.Type s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sType_2, sType_1, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_close_call( n19 ) )
        return refalrts::cNoMemory;
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n13 );
      refalrts::reinit_name( n12, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n17, & PartReuse, "PartReuse" );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n19 );
      refalrts::push_stack( n13 );
      res = refalrts::splice_elem( res, n19 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n13 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_2;
    refalrts::use( sType_2 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 s.Type s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sType_2, sType_1, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 s.Type s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_left( sType_2, sType_1, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & PartReuse, (void*) "PartReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & PartReuse, "PartReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 & TkChar s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkChar, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n3 );
      refalrts::reinit_name( n13, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n12, & FullReuse, "FullReuse" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkChar s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkChar, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkChar s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkChar, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & FullReuse, "FullReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 & TkName s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkName, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n3 );
      refalrts::reinit_name( n13, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n12, & FullReuse, "FullReuse" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkName s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkName, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkName s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkName, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & FullReuse, "FullReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 & TkIdentifier s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkIdentifier, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n3 );
      refalrts::reinit_name( n13, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n12, & FullReuse, "FullReuse" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkIdentifier s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkIdentifier, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkIdentifier s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkIdentifier, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & FullReuse, "FullReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 & TkOpenBracket s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n3 );
      refalrts::reinit_name( n13, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n12, & FullReuse, "FullReuse" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkOpenBracket s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkOpenBracket, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkOpenBracket s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & FullReuse, "FullReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 & TkOpenADT s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n3 );
      refalrts::reinit_name( n13, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n12, & FullReuse, "FullReuse" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkOpenADT s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkOpenADT, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkOpenADT s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkOpenADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & FullReuse, "FullReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 & TkCloseBracket s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n3 );
      refalrts::reinit_name( n13, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n12, & FullReuse, "FullReuse" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkCloseBracket s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkCloseBracket, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkCloseBracket s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseBracket, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & FullReuse, "FullReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
    // (~1 e.Begin (~2 & TkCloseADT s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_open_call( n3 );
      refalrts::reinit_name( n13, & DoGenResult_FindReuse, "DoGenResult_FindReuse" );
      refalrts::reinit_name( n12, & FullReuse, "FullReuse" );
      refalrts::reinit_close_call( n17 );
      //}}} REINITS
      refalrts::link_brackets( n0, n6 );
      refalrts::link_brackets( n2, n11 );
      refalrts::link_brackets( n9, n8 );
      refalrts::push_stack( n17 );
      refalrts::push_stack( n3 );
      res = refalrts::splice_elem( res, n17 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n12 );
      res = refalrts::splice_elem( res, n9 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n2 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n0 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_elem( res, n3 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eResultInfo_b_1;
    refalrts::use( eResultInfo_b_1 );
    static refalrts::Iter eResultInfo_e_1;
    refalrts::use( eResultInfo_e_1 );
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sPatternPos_1;
    refalrts::use( sPatternPos_1 );
    static refalrts::Iter sResultPos_1;
    refalrts::use( sResultPos_1 );
    static refalrts::Iter ePatternInfo_b_1;
    refalrts::use( ePatternInfo_b_1 );
    static refalrts::Iter ePatternInfo_e_1;
    refalrts::use( ePatternInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Begin (~2 & TkCloseADT s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_left( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_4, be_4 ) ) 
      break;
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkCloseADT, bb_2, be_2 ) ) 
        continue;
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#else
    // (~1 e.Begin (~2 & TkCloseADT s.PatternPos e.PatternInfo )~2 e.End )~1 (~3 e.Scanned )~3 (~4 & Alloc s.ResultPos s.Type e.ResultInfo )~4 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n8 = 0; // Right
    if( ! refalrts::brackets_match( n8, n0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n9;
    if( (n9 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n9 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n9 ) ) 
      break;
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_left( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n17 = 0; // Right
    if( ! refalrts::brackets_match( n17, n12 ) ) 
      break;
    refalrts::Iter n13;
    if( (n13 = refalrts::function_left( & Alloc, bb_4, be_4 )) == 0 ) 
      break;
    refalrts::use( n13 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
    if( ! refalrts::svar_left( sResultPos_1, bb_4, be_4 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_4, be_4 ) ) 
      break;
    eResultInfo_b_1 = bb_4;
    refalrts::use( eResultInfo_b_1 );
    eResultInfo_e_1 = be_4;
    refalrts::use( eResultInfo_e_1 );
    refalrts::Iter bb_1_stk = bb_1;
    refalrts::Iter be_1_stk = be_1;
    for( 
      refalrts::Iter
        eBegin_b_1 = bb_1_stk,
        eBegin_oe_1 = bb_1_stk,
        bb_1 = bb_1_stk,
        be_1 = be_1_stk;
      ! empty_seq( eBegin_oe_1, be_1 );
      bb_1 = bb_1_stk,
      be_1 = be_1_stk,
      refalrts::next_term( eBegin_oe_1, be_1 )
    ) {
      bb_1 = eBegin_oe_1;
      eBegin_b_1 = bb_1_stk;
      eBegin_e_1 = eBegin_oe_1;
      refalrts::move_right( eBegin_b_1, eBegin_e_1 );
      refalrts::Iter bb_2 = 0;
      refalrts::Iter be_2 = 0;
      refalrts::Iter n2;
      if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n2 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n2 ) ) 
        continue;
      refalrts::Iter n3;
      if( (n3 = refalrts::function_left( & TkCloseADT, bb_2, be_2 )) == 0 ) 
        continue;
      refalrts::use( n3 );
      eEnd_b_1 = bb_1;
      refalrts::use( eEnd_b_1 );
      eEnd_e_1 = be_1;
      refalrts::use( eEnd_e_1 );
      if( ! refalrts::svar_left( sPatternPos_1, bb_2, be_2 ) ) 
        continue;
      ePatternInfo_b_1 = bb_2;
      refalrts::use( ePatternInfo_b_1 );
      ePatternInfo_e_1 = be_2;
      refalrts::use( ePatternInfo_e_1 );
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
        {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
        {refalrts::icSpliceSTVar, & sPatternPos_1},
        {refalrts::icSpliceSTVar, & sType_1},
        {refalrts::icSpliceEVar, & eResultInfo_b_1, & eResultInfo_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_open_call( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_name( n20, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_open_bracket( n21 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_bracket( n22 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n23 = 0;
      if( ! refalrts::alloc_open_bracket( n23 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n24 = 0;
      if( ! refalrts::alloc_open_bracket( n24 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n25 = 0;
      if( ! refalrts::alloc_name( n25, & FullReuse, "FullReuse" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n26 = 0;
      if( ! refalrts::alloc_close_bracket( n26 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n27 = 0;
      if( ! refalrts::alloc_close_bracket( n27 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n28 = 0;
      if( ! refalrts::alloc_close_call( n28 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n28 );
      refalrts::push_stack( n19 );
      res = refalrts::splice_elem( res, n28 );
      res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
      refalrts::link_brackets( n23, n27 );
      res = refalrts::splice_elem( res, n27 );
      refalrts::link_brackets( n24, n26 );
      res = refalrts::splice_elem( res, n26 );
      res = refalrts::splice_evar( res, eResultInfo_b_1, eResultInfo_e_1 );
      res = refalrts::splice_stvar( res, sType_1 );
      res = refalrts::splice_stvar( res, sPatternPos_1 );
      res = refalrts::splice_elem( res, n25 );
      res = refalrts::splice_elem( res, n24 );
      res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
      res = refalrts::splice_elem( res, n23 );
      refalrts::link_brackets( n21, n22 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
      res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      res = refalrts::splice_elem( res, n19 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Alloc, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::link_brackets( n3, n9 );
    refalrts::link_brackets( n6, n5 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elems( res, n11, n12 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_left( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_3, be_3 ) ) 
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#else
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2 (~3 & Alloc e.Info )~3 e.Result
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n6;
    if( (n6 = refalrts::brackets_left( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n6 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n6 ) ) 
      break;
    refalrts::Iter n7;
    if( (n7 = refalrts::function_left( & Alloc, bb_3, be_3 )) == 0 ) 
      break;
    refalrts::use( n7 );
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    eInfo_b_1 = bb_3;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_3;
    refalrts::use( eInfo_e_1 );
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & DoGenResult_FindReuse, (void*) "DoGenResult_FindReuse"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & ePattern_b_1, & ePattern_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & DoGenResult_FindReuse, "DoGenResult_FindReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_open_bracket( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n20 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    refalrts::link_brackets( n15, n19 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::link_brackets( n16, n18 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::link_brackets( n13, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, ePattern_b_1, ePattern_e_1 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter ePattern_b_1;
    refalrts::use( ePattern_b_1 );
    static refalrts::Iter ePattern_e_1;
    refalrts::use( ePattern_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
#else
    // (~1 e.Pattern )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n3;
    if( (n3 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n3 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    ePattern_b_1 = bb_1;
    refalrts::use( ePattern_b_1 );
    ePattern_e_1 = be_1;
    refalrts::use( ePattern_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult NoCR(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    // '\\ e.Tail
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '\\', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '\\' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elems( res, n2, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
#ifdef OLD_PATTERN
    // '\\ e.Tail
    if( ! refalrts::char_left( '\\', bb_0, be_0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#else
    // '\\ e.Tail
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '\\', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '\\'},
      {refalrts::icChar, 0, 0, '\\'},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NoCR, (void*) "NoCR"},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '\\' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '\\' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    // '\n e.Tail
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_char( n0, '\\' );
    //}}} REINITS
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elems( res, n2, n4 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
#ifdef OLD_PATTERN
    // '\n e.Tail
    if( ! refalrts::char_left( '\n', bb_0, be_0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#else
    // '\n e.Tail
    refalrts::Iter n0;
    if( (n0 = refalrts::char_left( '\n', bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icChar, 0, 0, '\\'},
      {refalrts::icChar, 0, 0, 'n'},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NoCR, (void*) "NoCR"},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_char( n2, '\\' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, 'n' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sOther_1;
    refalrts::use( sOther_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    // s.Other e.Tail
    if( ! refalrts::svar_left( sOther_1, bb_0, be_0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    res = refalrts::splice_stvar( res, sOther_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sOther_1;
    refalrts::use( sOther_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
#ifdef OLD_PATTERN
    // s.Other e.Tail
    if( ! refalrts::svar_left( sOther_1, bb_0, be_0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#else
    // s.Other e.Tail
    if( ! refalrts::svar_left( sOther_1, bb_0, be_0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icSpliceSTVar, & sOther_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NoCR, (void*) "NoCR"},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_stvar( res, sOther_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInner_b_1;
    refalrts::use( eInner_b_1 );
    static refalrts::Iter eInner_e_1;
    refalrts::use( eInner_e_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    // (~1 e.Inner )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eInner_b_1 = bb_1;
    refalrts::use( eInner_b_1 );
    eInner_e_1 = be_1;
    refalrts::use( eInner_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elems( res, n7, n8 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInner_b_1, eInner_e_1 );
    res = refalrts::splice_elems( res, n4, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInner_b_1;
    refalrts::use( eInner_b_1 );
    static refalrts::Iter eInner_e_1;
    refalrts::use( eInner_e_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Inner )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eInner_b_1 = bb_1;
    refalrts::use( eInner_b_1 );
    eInner_e_1 = be_1;
    refalrts::use( eInner_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#else
    // (~1 e.Inner )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    eInner_b_1 = bb_1;
    refalrts::use( eInner_b_1 );
    eInner_e_1 = be_1;
    refalrts::use( eInner_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NoCR, (void*) "NoCR"},
      {refalrts::icSpliceEVar, & eInner_b_1, & eInner_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NoCR, (void*) "NoCR"},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n4, n8 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eInner_b_1, eInner_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult PrintItems(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult lambda_PrintItems_0(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eCommand_b_1;
    refalrts::use( eCommand_b_1 );
    static refalrts::Iter eCommand_e_1;
    refalrts::use( eCommand_e_1 );
    // (~1 e.Command )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eCommand_b_1 = bb_1;
    refalrts::use( eCommand_b_1 );
    eCommand_e_1 = be_1;
    refalrts::use( eCommand_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eCommand_b_1, eCommand_e_1 );
    res = refalrts::splice_elems( res, n3, n5 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eCommand_b_1;
    refalrts::use( eCommand_b_1 );
    static refalrts::Iter eCommand_e_1;
    refalrts::use( eCommand_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Command )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eCommand_b_1 = bb_1;
    refalrts::use( eCommand_b_1 );
    eCommand_e_1 = be_1;
    refalrts::use( eCommand_e_1 );
#else
    // (~1 e.Command )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eCommand_b_1 = bb_1;
    refalrts::use( eCommand_b_1 );
    eCommand_e_1 = be_1;
    refalrts::use( eCommand_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdComment, (void*) "CmdComment"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & NoCR, (void*) "NoCR"},
      {refalrts::icSpliceEVar, & eCommand_b_1, & eCommand_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & NoCR, "NoCR" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n3, n8 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eCommand_b_1, eCommand_e_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult PrintItems(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eItems_b_1;
    refalrts::use( eItems_b_1 );
    static refalrts::Iter eItems_e_1;
    refalrts::use( eItems_e_1 );
    // e.Items
    eItems_b_1 = bb_0;
    refalrts::use( eItems_b_1 );
    eItems_e_1 = be_0;
    refalrts::use( eItems_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & lambda_PrintItems_0, "lambda_PrintItems_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n4 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eItems_b_1, eItems_e_1 );
    res = refalrts::splice_elems( res, n1, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eItems_b_1;
    refalrts::use( eItems_b_1 );
    static refalrts::Iter eItems_e_1;
    refalrts::use( eItems_e_1 );
#ifdef OLD_PATTERN
    // e.Items
    eItems_b_1 = bb_0;
    refalrts::use( eItems_b_1 );
    eItems_e_1 = be_0;
    refalrts::use( eItems_e_1 );
#else
    // e.Items
    eItems_b_1 = bb_0;
    refalrts::use( eItems_b_1 );
    eItems_e_1 = be_0;
    refalrts::use( eItems_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Map, (void*) "Map"},
      {refalrts::icFunc, (void*) & lambda_PrintItems_0, (void*) "lambda_PrintItems_0"},
      {refalrts::icSpliceEVar, & eItems_b_1, & eItems_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & lambda_PrintItems_0, "lambda_PrintItems_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eItems_b_1, eItems_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult InitAllocs(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult SeparateAllocs(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult SeparateReinits(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult LinkBrackets(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult LinkCalls(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult BuildResult(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult GenResultCommands(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult lambda_GenResultCommands_0(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInitialized_b_1;
    refalrts::use( eInitialized_b_1 );
    static refalrts::Iter eInitialized_e_1;
    refalrts::use( eInitialized_e_1 );
    // e.Initialized
    eInitialized_b_1 = bb_0;
    refalrts::use( eInitialized_b_1 );
    eInitialized_e_1 = be_0;
    refalrts::use( eInitialized_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & CmdEmptyResult, "CmdEmptyResult" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & SeparateAllocs, "SeparateAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & SeparateReinits, "SeparateReinits" ) )
      return refalrts::cNoMemory;
    static refalrts::Iter eInitialized_b_2;
    refalrts::use( eInitialized_b_2 );
    static refalrts::Iter eInitialized_e_2;
    refalrts::use( eInitialized_e_2 );
    if( ! refalrts::copy_evar( eInitialized_b_2, eInitialized_e_2, eInitialized_b_1, eInitialized_e_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & LinkBrackets, "LinkBrackets" ) )
      return refalrts::cNoMemory;
    static refalrts::Iter eInitialized_b_3;
    refalrts::use( eInitialized_b_3 );
    static refalrts::Iter eInitialized_e_3;
    refalrts::use( eInitialized_e_3 );
    if( ! refalrts::copy_evar( eInitialized_b_3, eInitialized_e_3, eInitialized_b_2, eInitialized_e_2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & LinkCalls, "LinkCalls" ) )
      return refalrts::cNoMemory;
    static refalrts::Iter eInitialized_b_4;
    refalrts::use( eInitialized_b_4 );
    static refalrts::Iter eInitialized_e_4;
    refalrts::use( eInitialized_e_4 );
    if( ! refalrts::copy_evar( eInitialized_b_4, eInitialized_e_4, eInitialized_b_3, eInitialized_e_3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & BuildResult, "BuildResult" ) )
      return refalrts::cNoMemory;
    static refalrts::Iter eInitialized_b_5;
    refalrts::use( eInitialized_b_5 );
    static refalrts::Iter eInitialized_e_5;
    refalrts::use( eInitialized_e_5 );
    if( ! refalrts::copy_evar( eInitialized_b_5, eInitialized_e_5, eInitialized_b_4, eInitialized_e_4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & CmdReturnResult, "CmdReturnResult" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_bracket( n21 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n3 );
    refalrts::link_brackets( n19, n21 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n7 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elems( res, n18, n21 );
    res = refalrts::splice_evar( res, eInitialized_b_5, eInitialized_e_5 );
    res = refalrts::splice_elems( res, n15, n17 );
    res = refalrts::splice_evar( res, eInitialized_b_4, eInitialized_e_4 );
    res = refalrts::splice_elems( res, n12, n14 );
    res = refalrts::splice_evar( res, eInitialized_b_3, eInitialized_e_3 );
    res = refalrts::splice_elems( res, n9, n11 );
    res = refalrts::splice_evar( res, eInitialized_b_2, eInitialized_e_2 );
    res = refalrts::splice_elems( res, n6, n8 );
    res = refalrts::splice_evar( res, eInitialized_b_1, eInitialized_e_1 );
    res = refalrts::splice_elems( res, n1, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInitialized_b_1;
    refalrts::use( eInitialized_b_1 );
    static refalrts::Iter eInitialized_e_1;
    refalrts::use( eInitialized_e_1 );
    static refalrts::Iter eInitialized_b_2;
    refalrts::use( eInitialized_b_2 );
    static refalrts::Iter eInitialized_e_2;
    refalrts::use( eInitialized_e_2 );
    static refalrts::Iter eInitialized_b_3;
    refalrts::use( eInitialized_b_3 );
    static refalrts::Iter eInitialized_e_3;
    refalrts::use( eInitialized_e_3 );
    static refalrts::Iter eInitialized_b_4;
    refalrts::use( eInitialized_b_4 );
    static refalrts::Iter eInitialized_e_4;
    refalrts::use( eInitialized_e_4 );
    static refalrts::Iter eInitialized_b_5;
    refalrts::use( eInitialized_b_5 );
    static refalrts::Iter eInitialized_e_5;
    refalrts::use( eInitialized_e_5 );
#ifdef OLD_PATTERN
    // e.Initialized
    eInitialized_b_1 = bb_0;
    refalrts::use( eInitialized_b_1 );
    eInitialized_e_1 = be_0;
    refalrts::use( eInitialized_e_1 );
#else
    // e.Initialized
    eInitialized_b_1 = bb_0;
    refalrts::use( eInitialized_b_1 );
    eInitialized_e_1 = be_0;
    refalrts::use( eInitialized_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdEmptyResult, (void*) "CmdEmptyResult"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SeparateAllocs, (void*) "SeparateAllocs"},
      {refalrts::icSpliceEVar, & eInitialized_b_1, & eInitialized_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & SeparateReinits, (void*) "SeparateReinits"},
      {refalrts::icCopyEVar, & eInitialized_b_1, & eInitialized_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & LinkBrackets, (void*) "LinkBrackets"},
      {refalrts::icCopyEVar, & eInitialized_b_1, & eInitialized_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & LinkCalls, (void*) "LinkCalls"},
      {refalrts::icCopyEVar, & eInitialized_b_1, & eInitialized_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & BuildResult, (void*) "BuildResult"},
      {refalrts::icCopyEVar, & eInitialized_b_1, & eInitialized_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReturnResult, (void*) "CmdReturnResult"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    if( ! refalrts::copy_evar( eInitialized_b_2, eInitialized_e_2, eInitialized_b_1, eInitialized_e_1 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::copy_evar( eInitialized_b_3, eInitialized_e_3, eInitialized_b_2, eInitialized_e_2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::copy_evar( eInitialized_b_4, eInitialized_e_4, eInitialized_b_3, eInitialized_e_3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::copy_evar( eInitialized_b_5, eInitialized_e_5, eInitialized_b_4, eInitialized_e_4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & CmdEmptyResult, "CmdEmptyResult" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_close_bracket( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & SeparateAllocs, "SeparateAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & SeparateReinits, "SeparateReinits" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & LinkBrackets, "LinkBrackets" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & LinkCalls, "LinkCalls" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_call( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & BuildResult, "BuildResult" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & CmdReturnResult, "CmdReturnResult" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n19, n21 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n16 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eInitialized_b_5, eInitialized_e_5 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eInitialized_b_4, eInitialized_e_4 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eInitialized_b_3, eInitialized_e_3 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInitialized_b_2, eInitialized_e_2 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInitialized_b_1, eInitialized_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::link_brackets( n1, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult GenResultCommands(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    // s.Total e.Result
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & lambda_GenResultCommands_0, "lambda_GenResultCommands_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n8 );
    refalrts::push_stack( n2 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elems( res, n6, n8 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n2, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
#ifdef OLD_PATTERN
    // s.Total e.Result
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#else
    // s.Total e.Result
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Fetch, (void*) "Fetch"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & InitAllocs, (void*) "InitAllocs"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icFunc, (void*) & lambda_GenResultCommands_0, (void*) "lambda_GenResultCommands_0"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & lambda_GenResultCommands_0, "lambda_GenResultCommands_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n4 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult InitAllocs(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    // s.Total (~1 & Sample e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n4 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n1, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
#ifdef OLD_PATTERN
    // s.Total (~1 & Sample e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Sample, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#else
    // s.Total (~1 & Sample e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Sample, (void*) "Sample"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & InitAllocs, (void*) "InitAllocs"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Sample, "Sample" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    // s.Total (~1 & PartReuse e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n4 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n1, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
#ifdef OLD_PATTERN
    // s.Total (~1 & PartReuse e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#else
    // s.Total (~1 & PartReuse e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & PartReuse, (void*) "PartReuse"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & InitAllocs, (void*) "InitAllocs"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & PartReuse, "PartReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    // s.Total (~1 & FullReuse e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n4 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n1, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
#ifdef OLD_PATTERN
    // s.Total (~1 & FullReuse e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#else
    // s.Total (~1 & FullReuse e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & FullReuse, (void*) "FullReuse"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & InitAllocs, (void*) "InitAllocs"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & FullReuse, "FullReuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_open_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n9 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    refalrts::link_brackets( n6, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // s.Total (~1 & Alloc s.Num & TkVariable e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n4;
    if( (n4 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n6 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n8, n9 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n1, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // s.Total (~1 & Alloc s.Num & TkVariable e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // s.Total (~1 & Alloc s.Num & TkVariable e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n4;
    if( (n4 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & InitAllocs, (void*) "InitAllocs"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & TkVariable, "TkVariable" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_name( n13, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n14 );
    refalrts::push_stack( n12 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    refalrts::link_brackets( n8, n11 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    // s.Total (~1 & Alloc & NoNum e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & NoNum, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Inc, "Inc" ) )
      return refalrts::cNoMemory;
    static refalrts::Iter sTotal_2;
    refalrts::use( sTotal_2 );
    if( ! refalrts::copy_stvar( sTotal_2, sTotal_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n1, n5 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n3 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sTotal_2 );
    res = refalrts::splice_elems( res, n7, n9 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elems( res, n1, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eEnd_b_1;
    refalrts::use( eEnd_b_1 );
    static refalrts::Iter eEnd_e_1;
    refalrts::use( eEnd_e_1 );
    static refalrts::Iter sTotal_2;
    refalrts::use( sTotal_2 );
#ifdef OLD_PATTERN
    // s.Total (~1 & Alloc & NoNum e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & NoNum, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#else
    // s.Total (~1 & Alloc & NoNum e.Info )~1 e.End
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n1 ) ) 
      break;
    refalrts::Iter n2;
    if( (n2 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & NoNum, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eEnd_b_1 = bb_0;
    refalrts::use( eEnd_b_1 );
    eEnd_e_1 = be_0;
    refalrts::use( eEnd_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icSpliceSTVar, & sTotal_1},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & InitAllocs, (void*) "InitAllocs"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Inc, (void*) "Inc"},
      {refalrts::icCopySTVar, & sTotal_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icSpliceEVar, & eEnd_b_1, & eEnd_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    if( ! refalrts::copy_stvar( sTotal_2, sTotal_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & InitAllocs, "InitAllocs" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_call( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_name( n13, & Inc, "Inc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n15 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eEnd_b_1, eEnd_e_1 );
    refalrts::push_stack( n14 );
    refalrts::push_stack( n12 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_stvar( res, sTotal_2 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sTotal_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
    // s.Total
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sTotal_1;
    refalrts::use( sTotal_1 );
#ifdef OLD_PATTERN
    // s.Total
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    // s.Total
    if( ! refalrts::svar_left( sTotal_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult SeparateAllocs(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult lambda_SeparateAllocs_0(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Sample, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // (~1 & Alloc s.Num & TkVariable 'e e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'e', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdCopyEVar, "CmdCopyEVar" ) )
      return refalrts::cNoMemory;
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
    if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'e' ) )
      return refalrts::cNoMemory;
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdDeclareEVar, "CmdDeclareEVar" );
    refalrts::reinit_open_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n6 );
    refalrts::link_brackets( n3, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_2 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkVariable 'e e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::char_left( 'e', bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#else
    // (~1 & Alloc s.Num & TkVariable 'e e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'e', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdDeclareEVar, (void*) "CmdDeclareEVar"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdCopyEVar, (void*) "CmdCopyEVar"},
      {refalrts::icCopySTVar, & sNum_1},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icCopyEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & CmdDeclareEVar, "CmdDeclareEVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & CmdCopyEVar, "CmdCopyEVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n11, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_stvar( res, sNum_2 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::link_brackets( n7, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // (~1 & Alloc s.Num & TkVariable s.Type e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! refalrts::svar_left( sType_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdCopyVar, "CmdCopyVar" ) )
      return refalrts::cNoMemory;
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
    if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
      return refalrts::cNoMemory;
    static refalrts::Iter sType_2;
    refalrts::use( sType_2 );
    if( ! refalrts::copy_stvar( sType_2, sType_1 ) )
      return refalrts::cNoMemory;
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdDeclareVar, "CmdDeclareVar" );
    refalrts::reinit_open_bracket( n3 );
    //}}} REINITS
    refalrts::link_brackets( n0, n6 );
    refalrts::link_brackets( n3, n8 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_stvar( res, sType_2 );
    res = refalrts::splice_stvar( res, sNum_2 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sType_1;
    refalrts::use( sType_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
    static refalrts::Iter sType_2;
    refalrts::use( sType_2 );
    static refalrts::Iter eIndex_b_2;
    refalrts::use( eIndex_b_2 );
    static refalrts::Iter eIndex_e_2;
    refalrts::use( eIndex_e_2 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkVariable s.Type e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sType_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#else
    // (~1 & Alloc s.Num & TkVariable s.Type e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! refalrts::svar_left( sType_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdDeclareVar, (void*) "CmdDeclareVar"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icSpliceSTVar, & sType_1},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdCopyVar, (void*) "CmdCopyVar"},
      {refalrts::icCopySTVar, & sNum_1},
      {refalrts::icCopySTVar, & sType_1},
      {refalrts::icCopyEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::copy_stvar( sType_2, sType_1 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::copy_evar( eIndex_b_2, eIndex_e_2, eIndex_b_1, eIndex_e_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & CmdDeclareVar, "CmdDeclareVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & CmdCopyVar, "CmdCopyVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n10, n12 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eIndex_b_2, eIndex_e_2 );
    res = refalrts::splice_stvar( res, sType_2 );
    res = refalrts::splice_stvar( res, sNum_2 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::link_brackets( n7, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sType_1 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkChar, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElChar, "ElChar" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkChar, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkChar, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElChar, (void*) "ElChar"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElChar, "ElChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElName, "ElName" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkName, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElName, (void*) "ElName"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElName, "ElName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElNumber, "ElNumber" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkNumber, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElNumber, (void*) "ElNumber"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElNumber, "ElNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkIdentifier, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElIdent, "ElIdent" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkIdentifier, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkIdentifier, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElIdent, (void*) "ElIdent"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElIdent, "ElIdent" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElOpenBracket, "ElOpenBracket" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenBracket, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenBracket, (void*) "ElOpenBracket"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenBracket, "ElOpenBracket" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElOpenADT, "ElOpenADT" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenADT, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenADT, (void*) "ElOpenADT"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenADT, "ElOpenADT" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElOpenCall, "ElOpenCall" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenCall, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenCall, (void*) "ElOpenCall"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenCall, "ElOpenCall" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElCloseBracket, "ElCloseBracket" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseBracket, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseBracket, (void*) "ElCloseBracket"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseBracket, "ElCloseBracket" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElCloseADT, "ElCloseADT" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseADT, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseADT, (void*) "ElCloseADT"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseADT, "ElCloseADT" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdAllocateElem, "CmdAllocateElem" );
    refalrts::reinit_name( n3, & ElCloseCall, "ElCloseCall" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseCall, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdAllocateElem, (void*) "CmdAllocateElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseCall, (void*) "ElCloseCall"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdAllocateElem, "CmdAllocateElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseCall, "ElCloseCall" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult SeparateAllocs(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_name( n16, & lambda_SeparateAllocs_0, "lambda_SeparateAllocs_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_call( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_open_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_name( n19, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_close_bracket( n30 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n13 );
    refalrts::link_brackets( n18, n30 );
    refalrts::push_stack( n17 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elems( res, n17, n30 );
    res = refalrts::splice_evar( res, eElems_b_1, eElems_e_1 );
    res = refalrts::splice_elems( res, n1, n16 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
#ifdef OLD_PATTERN
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#else
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdComment, (void*) "CmdComment"},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Map, (void*) "Map"},
      {refalrts::icFunc, (void*) & lambda_SeparateAllocs_0, (void*) "lambda_SeparateAllocs_0"},
      {refalrts::icSpliceEVar, & eElems_b_1, & eElems_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdComment, (void*) "CmdComment"},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'A'},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icChar, 0, 0, 'L'},
      {refalrts::icChar, 0, 0, 'O'},
      {refalrts::icChar, 0, 0, 'C'},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_open_call( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_name( n16, & lambda_SeparateAllocs_0, "lambda_SeparateAllocs_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_call( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_open_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_name( n19, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_char( n20, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, 'A' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'L' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'O' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'C' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_close_bracket( n30 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n18, n30 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    refalrts::push_stack( n17 );
    refalrts::push_stack( n14 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, eElems_b_1, eElems_e_1 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::link_brackets( n1, n13 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult SeparateReinits(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult lambda_SeparateReinits_0(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Sample, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkChar, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElChar, "ElChar" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkChar, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkChar, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElChar, (void*) "ElChar"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElChar, "ElChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElName, "ElName" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkName, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElName, (void*) "ElName"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElName, "ElName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElNumber, "ElNumber" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkNumber, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElNumber, (void*) "ElNumber"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElNumber, "ElNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkIdentifier, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElIdent, "ElIdent" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkIdentifier, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkIdentifier, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElIdent, (void*) "ElIdent"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElIdent, "ElIdent" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElOpenBracket, "ElOpenBracket" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenBracket, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenBracket, (void*) "ElOpenBracket"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenBracket, "ElOpenBracket" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElOpenADT, "ElOpenADT" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenADT, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenADT, (void*) "ElOpenADT"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenADT, "ElOpenADT" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElOpenCall, "ElOpenCall" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenCall, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenCall, (void*) "ElOpenCall"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenCall, "ElOpenCall" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElCloseBracket, "ElCloseBracket" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseBracket, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseBracket, (void*) "ElCloseBracket"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseBracket, "ElCloseBracket" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElCloseADT, "ElCloseADT" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseADT, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseADT, (void*) "ElCloseADT"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseADT, "ElCloseADT" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElCloseCall, "ElCloseCall" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseCall, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseCall, (void*) "ElCloseCall"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseCall, "ElCloseCall" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkChar, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElChar, "ElChar" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkChar, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkChar e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkChar, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElChar, (void*) "ElChar"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElChar, "ElChar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElName, "ElName" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkName, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkName e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkName, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElName, (void*) "ElName"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElName, "ElName" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElNumber, "ElNumber" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkNumber, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkNumber e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkNumber, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElNumber, (void*) "ElNumber"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElNumber, "ElNumber" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkIdentifier, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElIdent, "ElIdent" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkIdentifier, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkIdentifier e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkIdentifier, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElIdent, (void*) "ElIdent"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElIdent, "ElIdent" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElOpenBracket, "ElOpenBracket" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenBracket, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkOpenBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenBracket, (void*) "ElOpenBracket"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenBracket, "ElOpenBracket" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElOpenADT, "ElOpenADT" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenADT, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkOpenADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenADT, (void*) "ElOpenADT"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenADT, "ElOpenADT" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElOpenCall, "ElOpenCall" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkOpenCall, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkOpenCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkOpenCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElOpenCall, (void*) "ElOpenCall"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElOpenCall, "ElOpenCall" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElCloseBracket, "ElCloseBracket" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseBracket, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkCloseBracket e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseBracket, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseBracket, (void*) "ElCloseBracket"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseBracket, "ElCloseBracket" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElCloseADT, "ElCloseADT" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseADT, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkCloseADT e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseADT, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseADT, (void*) "ElCloseADT"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseADT, "ElCloseADT" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & CmdReinitElem, "CmdReinitElem" );
    refalrts::reinit_name( n3, & ElCloseCall, "ElCloseCall" );
    //}}} REINITS
    refalrts::link_brackets( n0, n5 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseCall, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse s.Num & TkCloseCall e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkCloseCall, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdReinitElem, (void*) "CmdReinitElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & ElCloseCall, (void*) "ElCloseCall"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & CmdReinitElem, "CmdReinitElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & ElCloseCall, "ElCloseCall" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n6, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult SeparateReinits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_open_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_name( n16, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & lambda_SeparateReinits_0, "lambda_SeparateReinits_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_close_bracket( n32 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n1, n14 );
    refalrts::link_brackets( n19, n32 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n15 );
    res = refalrts::splice_elems( res, n18, n32 );
    res = refalrts::splice_evar( res, eElems_b_1, eElems_e_1 );
    res = refalrts::splice_elems( res, n1, n17 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
#ifdef OLD_PATTERN
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#else
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdComment, (void*) "CmdComment"},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icChar, 0, 0, '{'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Map, (void*) "Map"},
      {refalrts::icFunc, (void*) & lambda_SeparateReinits_0, (void*) "lambda_SeparateReinits_0"},
      {refalrts::icSpliceEVar, & eElems_b_1, & eElems_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdComment, (void*) "CmdComment"},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icChar, 0, 0, '}'},
      {refalrts::icChar, 0, 0, ' '},
      {refalrts::icChar, 0, 0, 'R'},
      {refalrts::icChar, 0, 0, 'E'},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icChar, 0, 0, 'N'},
      {refalrts::icChar, 0, 0, 'I'},
      {refalrts::icChar, 0, 0, 'T'},
      {refalrts::icChar, 0, 0, 'S'},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_bracket( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_char( n3, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_char( n4, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_char( n5, '{' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_char( n6, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_char( n7, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_char( n8, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_char( n9, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_char( n10, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_char( n11, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_char( n12, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_char( n13, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_open_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_name( n16, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_name( n17, & lambda_SeparateReinits_0, "lambda_SeparateReinits_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_open_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & CmdComment, "CmdComment" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_char( n21, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_char( n22, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_char( n23, '}' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n24 = 0;
    if( ! refalrts::alloc_char( n24, ' ' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n25 = 0;
    if( ! refalrts::alloc_char( n25, 'R' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n26 = 0;
    if( ! refalrts::alloc_char( n26, 'E' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n27 = 0;
    if( ! refalrts::alloc_char( n27, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n28 = 0;
    if( ! refalrts::alloc_char( n28, 'N' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n29 = 0;
    if( ! refalrts::alloc_char( n29, 'I' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n30 = 0;
    if( ! refalrts::alloc_char( n30, 'T' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n31 = 0;
    if( ! refalrts::alloc_char( n31, 'S' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n32 = 0;
    if( ! refalrts::alloc_close_bracket( n32 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n19, n32 );
    res = refalrts::splice_elem( res, n32 );
    res = refalrts::splice_elem( res, n31 );
    res = refalrts::splice_elem( res, n30 );
    res = refalrts::splice_elem( res, n29 );
    res = refalrts::splice_elem( res, n28 );
    res = refalrts::splice_elem( res, n27 );
    res = refalrts::splice_elem( res, n26 );
    res = refalrts::splice_elem( res, n25 );
    res = refalrts::splice_elem( res, n24 );
    res = refalrts::splice_elem( res, n23 );
    res = refalrts::splice_elem( res, n22 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::push_stack( n18 );
    refalrts::push_stack( n15 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eElems_b_1, eElems_e_1 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::link_brackets( n1, n14 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult LinkBrackets(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eElems_B_b_1;
    refalrts::use( eElems_B_b_1 );
    static refalrts::Iter eElems_B_e_1;
    refalrts::use( eElems_B_e_1 );
    static refalrts::Iter sReuse_L_1;
    refalrts::use( sReuse_L_1 );
    static refalrts::Iter sLeft_1;
    refalrts::use( sLeft_1 );
    static refalrts::Iter sPair_1;
    refalrts::use( sPair_1 );
    static refalrts::Iter sPair_2;
    refalrts::use( sPair_2 );
    static refalrts::Iter eElems_M_b_1;
    refalrts::use( eElems_M_b_1 );
    static refalrts::Iter eElems_M_e_1;
    refalrts::use( eElems_M_e_1 );
    static refalrts::Iter eElems_E_b_1;
    refalrts::use( eElems_E_b_1 );
    static refalrts::Iter eElems_E_e_1;
    refalrts::use( eElems_E_e_1 );
    static refalrts::Iter sReuse_R_1;
    refalrts::use( sReuse_R_1 );
    static refalrts::Iter sRight_1;
    refalrts::use( sRight_1 );
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenBracket s.Pair )~1 e.Elems_M (~2 s.Reuse_R s.Right & TkCloseBracket s.Pair )~2 e.Elems_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      refalrts::Iter n1;
      if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n1 ) ) 
        continue;
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      refalrts::Iter n4;
      if( (n4 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n4 );
      if( ! refalrts::svar_left( sPair_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
      refalrts::Iter bb_0_stk = bb_0;
      refalrts::Iter be_0_stk = be_0;
      for( 
        refalrts::Iter
          eElems_M_b_1 = bb_0_stk,
          eElems_M_oe_1 = bb_0_stk,
          bb_0 = bb_0_stk,
          be_0 = be_0_stk;
        ! empty_seq( eElems_M_oe_1, be_0 );
        bb_0 = bb_0_stk,
        be_0 = be_0_stk,
        refalrts::next_term( eElems_M_oe_1, be_0 )
      ) {
        bb_0 = eElems_M_oe_1;
        eElems_M_b_1 = bb_0_stk;
        eElems_M_e_1 = eElems_M_oe_1;
        refalrts::move_right( eElems_M_b_1, eElems_M_e_1 );
        refalrts::Iter bb_2 = 0;
        refalrts::Iter be_2 = 0;
        refalrts::Iter n8;
        if( (n8 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
          continue;
        refalrts::use( n8 );
        refalrts::Iter n13 = 0; // Right
        if( ! refalrts::brackets_match( n13, n8 ) ) 
          continue;
        if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_2, be_2 ) ) 
          continue;
        refalrts::Iter n11;
        if( (n11 = refalrts::function_right( & TkCloseBracket, bb_2, be_2 )) == 0 ) 
          continue;
        refalrts::use( n11 );
        eElems_E_b_1 = bb_0;
        refalrts::use( eElems_E_b_1 );
        eElems_E_e_1 = be_0;
        refalrts::use( eElems_E_e_1 );
        if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
          continue;
        if( ! empty_seq( bb_2, be_2 ) )
          continue;

        refalrts::reset_allocator();
        refalrts::Iter res = arg_begin;
        //{{{ ALLOCS
        //}}} ALLOCS
        //{{{ REINITS
        refalrts::reinit_name( n4, & CmdLinkBrackets, "CmdLinkBrackets" );
        refalrts::reinit_open_call( n11 );
        refalrts::reinit_name( n8, & LinkBrackets, "LinkBrackets" );
        refalrts::reinit_close_call( n13 );
        //}}} REINITS
        refalrts::link_brackets( n1, n6 );
        refalrts::push_stack( n13 );
        refalrts::push_stack( n11 );
        res = refalrts::splice_elem( res, n13 );
        res = refalrts::splice_evar( res, eElems_E_b_1, eElems_E_e_1 );
        res = refalrts::splice_evar( res, eElems_M_b_1, eElems_M_e_1 );
        res = refalrts::splice_evar( res, eElems_B_b_1, eElems_B_e_1 );
        res = refalrts::splice_elem( res, n8 );
        res = refalrts::splice_elem( res, n11 );
        res = refalrts::splice_elem( res, n6 );
        res = refalrts::splice_stvar( res, sRight_1 );
        res = refalrts::splice_stvar( res, sLeft_1 );
        res = refalrts::splice_elem( res, n4 );
        res = refalrts::splice_elem( res, n1 );
        refalrts::use( res );
        refalrts::splice_to_freelist( arg_begin, arg_end );
        return refalrts::cSuccess;
      }
    }
  } while ( 0 );
#else
    static refalrts::Iter eElems_B_b_1;
    refalrts::use( eElems_B_b_1 );
    static refalrts::Iter eElems_B_e_1;
    refalrts::use( eElems_B_e_1 );
    static refalrts::Iter sLeft_1;
    refalrts::use( sLeft_1 );
    static refalrts::Iter eElems_M_b_1;
    refalrts::use( eElems_M_b_1 );
    static refalrts::Iter eElems_M_e_1;
    refalrts::use( eElems_M_e_1 );
    static refalrts::Iter eElems_E_b_1;
    refalrts::use( eElems_E_b_1 );
    static refalrts::Iter eElems_E_e_1;
    refalrts::use( eElems_E_e_1 );
    static refalrts::Iter sRight_1;
    refalrts::use( sRight_1 );
    static refalrts::Iter sReuse_L_1;
    refalrts::use( sReuse_L_1 );
    static refalrts::Iter sPair_1;
    refalrts::use( sPair_1 );
    static refalrts::Iter sPair_2;
    refalrts::use( sPair_2 );
    static refalrts::Iter sReuse_R_1;
    refalrts::use( sReuse_R_1 );
#ifdef OLD_PATTERN
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenBracket s.Pair )~1 e.Elems_M (~2 s.Reuse_R s.Right & TkCloseBracket s.Pair )~2 e.Elems_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
        continue;
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkOpenBracket, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sPair_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
      refalrts::Iter bb_0_stk = bb_0;
      refalrts::Iter be_0_stk = be_0;
      for( 
        refalrts::Iter
          eElems_M_b_1 = bb_0_stk,
          eElems_M_oe_1 = bb_0_stk,
          bb_0 = bb_0_stk,
          be_0 = be_0_stk;
        ! empty_seq( eElems_M_oe_1, be_0 );
        bb_0 = bb_0_stk,
        be_0 = be_0_stk,
        refalrts::next_term( eElems_M_oe_1, be_0 )
      ) {
        bb_0 = eElems_M_oe_1;
        eElems_M_b_1 = bb_0_stk;
        eElems_M_e_1 = eElems_M_oe_1;
        refalrts::move_right( eElems_M_b_1, eElems_M_e_1 );
        refalrts::Iter bb_2 = 0;
        refalrts::Iter be_2 = 0;
        if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
          continue;
        if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::function_right( & TkCloseBracket, bb_2, be_2 ) ) 
          continue;
        eElems_E_b_1 = bb_0;
        refalrts::use( eElems_E_b_1 );
        eElems_E_e_1 = be_0;
        refalrts::use( eElems_E_e_1 );
        if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
          continue;
        if( ! empty_seq( bb_2, be_2 ) )
          continue;
#else
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenBracket s.Pair )~1 e.Elems_M (~2 s.Reuse_R s.Right & TkCloseBracket s.Pair )~2 e.Elems_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      refalrts::Iter n1;
      if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n1 ) ) 
        continue;
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      refalrts::Iter n4;
      if( (n4 = refalrts::function_left( & TkOpenBracket, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n4 );
      if( ! refalrts::svar_left( sPair_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
      refalrts::Iter bb_0_stk = bb_0;
      refalrts::Iter be_0_stk = be_0;
      for( 
        refalrts::Iter
          eElems_M_b_1 = bb_0_stk,
          eElems_M_oe_1 = bb_0_stk,
          bb_0 = bb_0_stk,
          be_0 = be_0_stk;
        ! empty_seq( eElems_M_oe_1, be_0 );
        bb_0 = bb_0_stk,
        be_0 = be_0_stk,
        refalrts::next_term( eElems_M_oe_1, be_0 )
      ) {
        bb_0 = eElems_M_oe_1;
        eElems_M_b_1 = bb_0_stk;
        eElems_M_e_1 = eElems_M_oe_1;
        refalrts::move_right( eElems_M_b_1, eElems_M_e_1 );
        refalrts::Iter bb_2 = 0;
        refalrts::Iter be_2 = 0;
        refalrts::Iter n8;
        if( (n8 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
          continue;
        refalrts::use( n8 );
        refalrts::Iter n13 = 0; // Right
        if( ! refalrts::brackets_match( n13, n8 ) ) 
          continue;
        if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_2, be_2 ) ) 
          continue;
        refalrts::Iter n11;
        if( (n11 = refalrts::function_right( & TkCloseBracket, bb_2, be_2 )) == 0 ) 
          continue;
        refalrts::use( n11 );
        eElems_E_b_1 = bb_0;
        refalrts::use( eElems_E_b_1 );
        eElems_E_e_1 = be_0;
        refalrts::use( eElems_E_e_1 );
        if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
          continue;
        if( ! empty_seq( bb_2, be_2 ) )
          continue;
#endif
#ifdef INTERPRET
        const static refalrts::ResultAction raa[] = {
          {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
          {refalrts::icFunc, (void*) & CmdLinkBrackets, (void*) "CmdLinkBrackets"},
          {refalrts::icSpliceSTVar, & sLeft_1},
          {refalrts::icSpliceSTVar, & sRight_1},
          {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
          {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
          {refalrts::icFunc, (void*) & LinkBrackets, (void*) "LinkBrackets"},
          {refalrts::icSpliceEVar, & eElems_B_b_1, & eElems_B_e_1},
          {refalrts::icSpliceEVar, & eElems_M_b_1, & eElems_M_e_1},
          {refalrts::icSpliceEVar, & eElems_E_b_1, & eElems_E_e_1},
          {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
          {refalrts::icEnd}
        };
        refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
        refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
        return res;
      }
    }
  } while ( 0 );
#else

        refalrts::reset_allocator();
        refalrts::Iter res = arg_begin;
        refalrts::Iter n15 = 0;
        if( ! refalrts::alloc_open_bracket( n15 ) )
          return refalrts::cNoMemory;
        refalrts::Iter n16 = 0;
        if( ! refalrts::alloc_name( n16, & CmdLinkBrackets, "CmdLinkBrackets" ) )
          return refalrts::cNoMemory;
        refalrts::Iter n17 = 0;
        if( ! refalrts::alloc_close_bracket( n17 ) )
          return refalrts::cNoMemory;
        refalrts::Iter n18 = 0;
        if( ! refalrts::alloc_open_call( n18 ) )
          return refalrts::cNoMemory;
        refalrts::Iter n19 = 0;
        if( ! refalrts::alloc_name( n19, & LinkBrackets, "LinkBrackets" ) )
          return refalrts::cNoMemory;
        refalrts::Iter n20 = 0;
        if( ! refalrts::alloc_close_call( n20 ) )
          return refalrts::cNoMemory;
        refalrts::push_stack( n20 );
        refalrts::push_stack( n18 );
        res = refalrts::splice_elem( res, n20 );
        res = refalrts::splice_evar( res, eElems_E_b_1, eElems_E_e_1 );
        res = refalrts::splice_evar( res, eElems_M_b_1, eElems_M_e_1 );
        res = refalrts::splice_evar( res, eElems_B_b_1, eElems_B_e_1 );
        res = refalrts::splice_elem( res, n19 );
        res = refalrts::splice_elem( res, n18 );
        refalrts::link_brackets( n15, n17 );
        res = refalrts::splice_elem( res, n17 );
        res = refalrts::splice_stvar( res, sRight_1 );
        res = refalrts::splice_stvar( res, sLeft_1 );
        res = refalrts::splice_elem( res, n16 );
        res = refalrts::splice_elem( res, n15 );
        refalrts::use( res );
        refalrts::splice_to_freelist( arg_begin, arg_end );
        return refalrts::cSuccess;
      }
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eElems_B_b_1;
    refalrts::use( eElems_B_b_1 );
    static refalrts::Iter eElems_B_e_1;
    refalrts::use( eElems_B_e_1 );
    static refalrts::Iter sReuse_L_1;
    refalrts::use( sReuse_L_1 );
    static refalrts::Iter sLeft_1;
    refalrts::use( sLeft_1 );
    static refalrts::Iter sPair_1;
    refalrts::use( sPair_1 );
    static refalrts::Iter sPair_2;
    refalrts::use( sPair_2 );
    static refalrts::Iter eElems_M_b_1;
    refalrts::use( eElems_M_b_1 );
    static refalrts::Iter eElems_M_e_1;
    refalrts::use( eElems_M_e_1 );
    static refalrts::Iter eElems_E_b_1;
    refalrts::use( eElems_E_b_1 );
    static refalrts::Iter eElems_E_e_1;
    refalrts::use( eElems_E_e_1 );
    static refalrts::Iter sReuse_R_1;
    refalrts::use( sReuse_R_1 );
    static refalrts::Iter sRight_1;
    refalrts::use( sRight_1 );
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenADT s.Pair )~1 e.Elems_M (~2 s.Reuse_R s.Right & TkCloseADT s.Pair )~2 e.Elems_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      refalrts::Iter n1;
      if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n1 ) ) 
        continue;
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      refalrts::Iter n4;
      if( (n4 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n4 );
      if( ! refalrts::svar_left( sPair_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
      refalrts::Iter bb_0_stk = bb_0;
      refalrts::Iter be_0_stk = be_0;
      for( 
        refalrts::Iter
          eElems_M_b_1 = bb_0_stk,
          eElems_M_oe_1 = bb_0_stk,
          bb_0 = bb_0_stk,
          be_0 = be_0_stk;
        ! empty_seq( eElems_M_oe_1, be_0 );
        bb_0 = bb_0_stk,
        be_0 = be_0_stk,
        refalrts::next_term( eElems_M_oe_1, be_0 )
      ) {
        bb_0 = eElems_M_oe_1;
        eElems_M_b_1 = bb_0_stk;
        eElems_M_e_1 = eElems_M_oe_1;
        refalrts::move_right( eElems_M_b_1, eElems_M_e_1 );
        refalrts::Iter bb_2 = 0;
        refalrts::Iter be_2 = 0;
        refalrts::Iter n8;
        if( (n8 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
          continue;
        refalrts::use( n8 );
        refalrts::Iter n13 = 0; // Right
        if( ! refalrts::brackets_match( n13, n8 ) ) 
          continue;
        if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_2, be_2 ) ) 
          continue;
        refalrts::Iter n11;
        if( (n11 = refalrts::function_right( & TkCloseADT, bb_2, be_2 )) == 0 ) 
          continue;
        refalrts::use( n11 );
        eElems_E_b_1 = bb_0;
        refalrts::use( eElems_E_b_1 );
        eElems_E_e_1 = be_0;
        refalrts::use( eElems_E_e_1 );
        if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
          continue;
        if( ! empty_seq( bb_2, be_2 ) )
          continue;

        refalrts::reset_allocator();
        refalrts::Iter res = arg_begin;
        //{{{ ALLOCS
        //}}} ALLOCS
        //{{{ REINITS
        refalrts::reinit_name( n4, & CmdLinkBrackets, "CmdLinkBrackets" );
        refalrts::reinit_open_call( n11 );
        refalrts::reinit_name( n8, & LinkBrackets, "LinkBrackets" );
        refalrts::reinit_close_call( n13 );
        //}}} REINITS
        refalrts::link_brackets( n1, n6 );
        refalrts::push_stack( n13 );
        refalrts::push_stack( n11 );
        res = refalrts::splice_elem( res, n13 );
        res = refalrts::splice_evar( res, eElems_E_b_1, eElems_E_e_1 );
        res = refalrts::splice_evar( res, eElems_M_b_1, eElems_M_e_1 );
        res = refalrts::splice_evar( res, eElems_B_b_1, eElems_B_e_1 );
        res = refalrts::splice_elem( res, n8 );
        res = refalrts::splice_elem( res, n11 );
        res = refalrts::splice_elem( res, n6 );
        res = refalrts::splice_stvar( res, sRight_1 );
        res = refalrts::splice_stvar( res, sLeft_1 );
        res = refalrts::splice_elem( res, n4 );
        res = refalrts::splice_elem( res, n1 );
        refalrts::use( res );
        refalrts::splice_to_freelist( arg_begin, arg_end );
        return refalrts::cSuccess;
      }
    }
  } while ( 0 );
#else
    static refalrts::Iter eElems_B_b_1;
    refalrts::use( eElems_B_b_1 );
    static refalrts::Iter eElems_B_e_1;
    refalrts::use( eElems_B_e_1 );
    static refalrts::Iter sLeft_1;
    refalrts::use( sLeft_1 );
    static refalrts::Iter eElems_M_b_1;
    refalrts::use( eElems_M_b_1 );
    static refalrts::Iter eElems_M_e_1;
    refalrts::use( eElems_M_e_1 );
    static refalrts::Iter eElems_E_b_1;
    refalrts::use( eElems_E_b_1 );
    static refalrts::Iter eElems_E_e_1;
    refalrts::use( eElems_E_e_1 );
    static refalrts::Iter sRight_1;
    refalrts::use( sRight_1 );
    static refalrts::Iter sReuse_L_1;
    refalrts::use( sReuse_L_1 );
    static refalrts::Iter sPair_1;
    refalrts::use( sPair_1 );
    static refalrts::Iter sPair_2;
    refalrts::use( sPair_2 );
    static refalrts::Iter sReuse_R_1;
    refalrts::use( sReuse_R_1 );
#ifdef OLD_PATTERN
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenADT s.Pair )~1 e.Elems_M (~2 s.Reuse_R s.Right & TkCloseADT s.Pair )~2 e.Elems_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
        continue;
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_left( & TkOpenADT, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sPair_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
      refalrts::Iter bb_0_stk = bb_0;
      refalrts::Iter be_0_stk = be_0;
      for( 
        refalrts::Iter
          eElems_M_b_1 = bb_0_stk,
          eElems_M_oe_1 = bb_0_stk,
          bb_0 = bb_0_stk,
          be_0 = be_0_stk;
        ! empty_seq( eElems_M_oe_1, be_0 );
        bb_0 = bb_0_stk,
        be_0 = be_0_stk,
        refalrts::next_term( eElems_M_oe_1, be_0 )
      ) {
        bb_0 = eElems_M_oe_1;
        eElems_M_b_1 = bb_0_stk;
        eElems_M_e_1 = eElems_M_oe_1;
        refalrts::move_right( eElems_M_b_1, eElems_M_e_1 );
        refalrts::Iter bb_2 = 0;
        refalrts::Iter be_2 = 0;
        if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
          continue;
        if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::function_right( & TkCloseADT, bb_2, be_2 ) ) 
          continue;
        eElems_E_b_1 = bb_0;
        refalrts::use( eElems_E_b_1 );
        eElems_E_e_1 = be_0;
        refalrts::use( eElems_E_e_1 );
        if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
          continue;
        if( ! empty_seq( bb_2, be_2 ) )
          continue;
#else
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenADT s.Pair )~1 e.Elems_M (~2 s.Reuse_R s.Right & TkCloseADT s.Pair )~2 e.Elems_E
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      refalrts::Iter n1;
      if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n1 ) ) 
        continue;
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      refalrts::Iter n4;
      if( (n4 = refalrts::function_left( & TkOpenADT, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n4 );
      if( ! refalrts::svar_left( sPair_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
      refalrts::Iter bb_0_stk = bb_0;
      refalrts::Iter be_0_stk = be_0;
      for( 
        refalrts::Iter
          eElems_M_b_1 = bb_0_stk,
          eElems_M_oe_1 = bb_0_stk,
          bb_0 = bb_0_stk,
          be_0 = be_0_stk;
        ! empty_seq( eElems_M_oe_1, be_0 );
        bb_0 = bb_0_stk,
        be_0 = be_0_stk,
        refalrts::next_term( eElems_M_oe_1, be_0 )
      ) {
        bb_0 = eElems_M_oe_1;
        eElems_M_b_1 = bb_0_stk;
        eElems_M_e_1 = eElems_M_oe_1;
        refalrts::move_right( eElems_M_b_1, eElems_M_e_1 );
        refalrts::Iter bb_2 = 0;
        refalrts::Iter be_2 = 0;
        refalrts::Iter n8;
        if( (n8 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
          continue;
        refalrts::use( n8 );
        refalrts::Iter n13 = 0; // Right
        if( ! refalrts::brackets_match( n13, n8 ) ) 
          continue;
        if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_2, be_2 ) ) 
          continue;
        refalrts::Iter n11;
        if( (n11 = refalrts::function_right( & TkCloseADT, bb_2, be_2 )) == 0 ) 
          continue;
        refalrts::use( n11 );
        eElems_E_b_1 = bb_0;
        refalrts::use( eElems_E_b_1 );
        eElems_E_e_1 = be_0;
        refalrts::use( eElems_E_e_1 );
        if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
          continue;
        if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
          continue;
        if( ! empty_seq( bb_2, be_2 ) )
          continue;
#endif
#ifdef INTERPRET
        const static refalrts::ResultAction raa[] = {
          {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
          {refalrts::icFunc, (void*) & CmdLinkBrackets, (void*) "CmdLinkBrackets"},
          {refalrts::icSpliceSTVar, & sLeft_1},
          {refalrts::icSpliceSTVar, & sRight_1},
          {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
          {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
          {refalrts::icFunc, (void*) & LinkBrackets, (void*) "LinkBrackets"},
          {refalrts::icSpliceEVar, & eElems_B_b_1, & eElems_B_e_1},
          {refalrts::icSpliceEVar, & eElems_M_b_1, & eElems_M_e_1},
          {refalrts::icSpliceEVar, & eElems_E_b_1, & eElems_E_e_1},
          {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
          {refalrts::icEnd}
        };
        refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
        refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
        return res;
      }
    }
  } while ( 0 );
#else

        refalrts::reset_allocator();
        refalrts::Iter res = arg_begin;
        refalrts::Iter n15 = 0;
        if( ! refalrts::alloc_open_bracket( n15 ) )
          return refalrts::cNoMemory;
        refalrts::Iter n16 = 0;
        if( ! refalrts::alloc_name( n16, & CmdLinkBrackets, "CmdLinkBrackets" ) )
          return refalrts::cNoMemory;
        refalrts::Iter n17 = 0;
        if( ! refalrts::alloc_close_bracket( n17 ) )
          return refalrts::cNoMemory;
        refalrts::Iter n18 = 0;
        if( ! refalrts::alloc_open_call( n18 ) )
          return refalrts::cNoMemory;
        refalrts::Iter n19 = 0;
        if( ! refalrts::alloc_name( n19, & LinkBrackets, "LinkBrackets" ) )
          return refalrts::cNoMemory;
        refalrts::Iter n20 = 0;
        if( ! refalrts::alloc_close_call( n20 ) )
          return refalrts::cNoMemory;
        refalrts::push_stack( n20 );
        refalrts::push_stack( n18 );
        res = refalrts::splice_elem( res, n20 );
        res = refalrts::splice_evar( res, eElems_E_b_1, eElems_E_e_1 );
        res = refalrts::splice_evar( res, eElems_M_b_1, eElems_M_e_1 );
        res = refalrts::splice_evar( res, eElems_B_b_1, eElems_B_e_1 );
        res = refalrts::splice_elem( res, n19 );
        res = refalrts::splice_elem( res, n18 );
        refalrts::link_brackets( n15, n17 );
        res = refalrts::splice_elem( res, n17 );
        res = refalrts::splice_stvar( res, sRight_1 );
        res = refalrts::splice_stvar( res, sLeft_1 );
        res = refalrts::splice_elem( res, n16 );
        res = refalrts::splice_elem( res, n15 );
        refalrts::use( res );
        refalrts::splice_to_freelist( arg_begin, arg_end );
        return refalrts::cSuccess;
      }
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
#ifdef OLD_PATTERN
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#else
    // e.Elems
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult LinkCalls(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sReuse_R_1;
    refalrts::use( sReuse_R_1 );
    static refalrts::Iter sRight_1;
    refalrts::use( sRight_1 );
    static refalrts::Iter sPair_1;
    refalrts::use( sPair_1 );
    static refalrts::Iter sPair_2;
    refalrts::use( sPair_2 );
    static refalrts::Iter eElems_B_b_1;
    refalrts::use( eElems_B_b_1 );
    static refalrts::Iter eElems_B_e_1;
    refalrts::use( eElems_B_e_1 );
    static refalrts::Iter eElems_E_b_1;
    refalrts::use( eElems_E_b_1 );
    static refalrts::Iter eElems_E_e_1;
    refalrts::use( eElems_E_e_1 );
    static refalrts::Iter sReuse_L_1;
    refalrts::use( sReuse_L_1 );
    static refalrts::Iter sLeft_1;
    refalrts::use( sLeft_1 );
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenCall s.Pair )~1 e.Elems_E (~2 s.Reuse_R s.Right & TkCloseCall s.Pair )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n8;
    if( (n8 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n8 );
    refalrts::Iter n13 = 0; // Right
    if( ! refalrts::brackets_match( n13, n8 ) ) 
      break;
    if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
      break;
    refalrts::Iter n11;
    if( (n11 = refalrts::function_left( & TkCloseCall, bb_2, be_2 )) == 0 ) 
      break;
    refalrts::use( n11 );
    if( ! refalrts::svar_left( sPair_1, bb_2, be_2 ) ) 
      break;
    if( ! empty_seq( bb_2, be_2 ) )
      break;
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      refalrts::Iter n1;
      if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n1 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_1, be_1 ) ) 
        continue;
      refalrts::Iter n4;
      if( (n4 = refalrts::function_right( & TkOpenCall, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n4 );
      eElems_E_b_1 = bb_0;
      refalrts::use( eElems_E_b_1 );
      eElems_E_e_1 = be_0;
      refalrts::use( eElems_E_e_1 );
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      //{{{ ALLOCS
      refalrts::Iter n14 = 0;
      if( ! refalrts::alloc_open_call( n14 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n15 = 0;
      if( ! refalrts::alloc_name( n15, & LinkCalls, "LinkCalls" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n16 = 0;
      if( ! refalrts::alloc_close_call( n16 ) )
        return refalrts::cNoMemory;
      //}}} ALLOCS
      //{{{ REINITS
      refalrts::reinit_name( n4, & CmdPushStack, "CmdPushStack" );
      refalrts::reinit_name( n11, & CmdPushStack, "CmdPushStack" );
      //}}} REINITS
      refalrts::link_brackets( n1, n6 );
      refalrts::link_brackets( n8, n13 );
      refalrts::push_stack( n16 );
      refalrts::push_stack( n14 );
      res = refalrts::splice_elem( res, n16 );
      res = refalrts::splice_evar( res, eElems_E_b_1, eElems_E_e_1 );
      res = refalrts::splice_evar( res, eElems_B_b_1, eElems_B_e_1 );
      res = refalrts::splice_elems( res, n14, n15 );
      res = refalrts::splice_elem( res, n13 );
      res = refalrts::splice_stvar( res, sLeft_1 );
      res = refalrts::splice_elem( res, n11 );
      res = refalrts::splice_elem( res, n8 );
      res = refalrts::splice_elem( res, n6 );
      res = refalrts::splice_stvar( res, sRight_1 );
      res = refalrts::splice_elem( res, n4 );
      res = refalrts::splice_elem( res, n1 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#else
    static refalrts::Iter sRight_1;
    refalrts::use( sRight_1 );
    static refalrts::Iter eElems_B_b_1;
    refalrts::use( eElems_B_b_1 );
    static refalrts::Iter eElems_B_e_1;
    refalrts::use( eElems_B_e_1 );
    static refalrts::Iter eElems_E_b_1;
    refalrts::use( eElems_E_b_1 );
    static refalrts::Iter eElems_E_e_1;
    refalrts::use( eElems_E_e_1 );
    static refalrts::Iter sLeft_1;
    refalrts::use( sLeft_1 );
    static refalrts::Iter sReuse_R_1;
    refalrts::use( sReuse_R_1 );
    static refalrts::Iter sPair_1;
    refalrts::use( sPair_1 );
    static refalrts::Iter sPair_2;
    refalrts::use( sPair_2 );
    static refalrts::Iter sReuse_L_1;
    refalrts::use( sReuse_L_1 );
#ifdef OLD_PATTERN
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenCall s.Pair )~1 e.Elems_E (~2 s.Reuse_R s.Right & TkCloseCall s.Pair )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_right( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::function_left( & TkCloseCall, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::svar_left( sPair_1, bb_2, be_2 ) ) 
      break;
    if( ! empty_seq( bb_2, be_2 ) )
      break;
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::function_right( & TkOpenCall, bb_1, be_1 ) ) 
        continue;
      eElems_E_b_1 = bb_0;
      refalrts::use( eElems_E_b_1 );
      eElems_E_e_1 = be_0;
      refalrts::use( eElems_E_e_1 );
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
#else
    // e.Elems_B (~1 s.Reuse_L s.Left & TkOpenCall s.Pair )~1 e.Elems_E (~2 s.Reuse_R s.Right & TkCloseCall s.Pair )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n8;
    if( (n8 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n8 );
    refalrts::Iter n13 = 0; // Right
    if( ! refalrts::brackets_match( n13, n8 ) ) 
      break;
    if( ! refalrts::svar_left( sReuse_R_1, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::svar_left( sRight_1, bb_2, be_2 ) ) 
      break;
    refalrts::Iter n11;
    if( (n11 = refalrts::function_left( & TkCloseCall, bb_2, be_2 )) == 0 ) 
      break;
    refalrts::use( n11 );
    if( ! refalrts::svar_left( sPair_1, bb_2, be_2 ) ) 
      break;
    if( ! empty_seq( bb_2, be_2 ) )
      break;
    refalrts::Iter bb_0_stk = bb_0;
    refalrts::Iter be_0_stk = be_0;
    for( 
      refalrts::Iter
        eElems_B_b_1 = bb_0_stk,
        eElems_B_oe_1 = bb_0_stk,
        bb_0 = bb_0_stk,
        be_0 = be_0_stk;
      ! empty_seq( eElems_B_oe_1, be_0 );
      bb_0 = bb_0_stk,
      be_0 = be_0_stk,
      refalrts::next_term( eElems_B_oe_1, be_0 )
    ) {
      bb_0 = eElems_B_oe_1;
      eElems_B_b_1 = bb_0_stk;
      eElems_B_e_1 = eElems_B_oe_1;
      refalrts::move_right( eElems_B_b_1, eElems_B_e_1 );
      refalrts::Iter bb_1 = 0;
      refalrts::Iter be_1 = 0;
      refalrts::Iter n1;
      if( (n1 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
        continue;
      refalrts::use( n1 );
      refalrts::Iter n6 = 0; // Right
      if( ! refalrts::brackets_match( n6, n1 ) ) 
        continue;
      if( ! refalrts::repeated_stvar_right( sPair_2, sPair_1, bb_1, be_1 ) ) 
        continue;
      refalrts::Iter n4;
      if( (n4 = refalrts::function_right( & TkOpenCall, bb_1, be_1 )) == 0 ) 
        continue;
      refalrts::use( n4 );
      eElems_E_b_1 = bb_0;
      refalrts::use( eElems_E_b_1 );
      eElems_E_e_1 = be_0;
      refalrts::use( eElems_E_e_1 );
      if( ! refalrts::svar_left( sReuse_L_1, bb_1, be_1 ) ) 
        continue;
      if( ! refalrts::svar_left( sLeft_1, bb_1, be_1 ) ) 
        continue;
      if( ! empty_seq( bb_1, be_1 ) )
        continue;
#endif
#ifdef INTERPRET
      const static refalrts::ResultAction raa[] = {
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & CmdPushStack, (void*) "CmdPushStack"},
        {refalrts::icSpliceSTVar, & sRight_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
        {refalrts::icFunc, (void*) & CmdPushStack, (void*) "CmdPushStack"},
        {refalrts::icSpliceSTVar, & sLeft_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
        {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
        {refalrts::icFunc, (void*) & LinkCalls, (void*) "LinkCalls"},
        {refalrts::icSpliceEVar, & eElems_B_b_1, & eElems_B_e_1},
        {refalrts::icSpliceEVar, & eElems_E_b_1, & eElems_E_e_1},
        {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
        {refalrts::icEnd}
      };
      refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
      refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
      return res;
    }
  } while ( 0 );
#else

      refalrts::reset_allocator();
      refalrts::Iter res = arg_begin;
      refalrts::Iter n14 = 0;
      if( ! refalrts::alloc_open_bracket( n14 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n15 = 0;
      if( ! refalrts::alloc_name( n15, & CmdPushStack, "CmdPushStack" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n16 = 0;
      if( ! refalrts::alloc_close_bracket( n16 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n17 = 0;
      if( ! refalrts::alloc_open_bracket( n17 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n18 = 0;
      if( ! refalrts::alloc_name( n18, & CmdPushStack, "CmdPushStack" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n19 = 0;
      if( ! refalrts::alloc_close_bracket( n19 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n20 = 0;
      if( ! refalrts::alloc_open_call( n20 ) )
        return refalrts::cNoMemory;
      refalrts::Iter n21 = 0;
      if( ! refalrts::alloc_name( n21, & LinkCalls, "LinkCalls" ) )
        return refalrts::cNoMemory;
      refalrts::Iter n22 = 0;
      if( ! refalrts::alloc_close_call( n22 ) )
        return refalrts::cNoMemory;
      refalrts::push_stack( n22 );
      refalrts::push_stack( n20 );
      res = refalrts::splice_elem( res, n22 );
      res = refalrts::splice_evar( res, eElems_E_b_1, eElems_E_e_1 );
      res = refalrts::splice_evar( res, eElems_B_b_1, eElems_B_e_1 );
      res = refalrts::splice_elem( res, n21 );
      res = refalrts::splice_elem( res, n20 );
      refalrts::link_brackets( n17, n19 );
      res = refalrts::splice_elem( res, n19 );
      res = refalrts::splice_stvar( res, sLeft_1 );
      res = refalrts::splice_elem( res, n18 );
      res = refalrts::splice_elem( res, n17 );
      refalrts::link_brackets( n14, n16 );
      res = refalrts::splice_elem( res, n16 );
      res = refalrts::splice_stvar( res, sRight_1 );
      res = refalrts::splice_elem( res, n15 );
      res = refalrts::splice_elem( res, n14 );
      refalrts::use( res );
      refalrts::splice_to_freelist( arg_begin, arg_end );
      return refalrts::cSuccess;
    }
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter tOtherTerm_1;
    refalrts::use( tOtherTerm_1 );
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
    // e.Elems t.OtherTerm
    if( ! refalrts::tvar_right( tOtherTerm_1, bb_0, be_0 ) ) 
      break;
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & LinkCalls, "LinkCalls" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eElems_b_1, eElems_e_1 );
    res = refalrts::splice_elems( res, n2, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eElems_b_1;
    refalrts::use( eElems_b_1 );
    static refalrts::Iter eElems_e_1;
    refalrts::use( eElems_e_1 );
    static refalrts::Iter tOtherTerm_1;
    refalrts::use( tOtherTerm_1 );
#ifdef OLD_PATTERN
    // e.Elems t.OtherTerm
    if( ! refalrts::tvar_right( tOtherTerm_1, bb_0, be_0 ) ) 
      break;
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#else
    // e.Elems t.OtherTerm
    if( ! refalrts::tvar_right( tOtherTerm_1, bb_0, be_0 ) ) 
      break;
    eElems_b_1 = bb_0;
    refalrts::use( eElems_b_1 );
    eElems_e_1 = be_0;
    refalrts::use( eElems_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & LinkCalls, (void*) "LinkCalls"},
      {refalrts::icSpliceEVar, & eElems_b_1, & eElems_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_open_call( n2 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_name( n3, & LinkCalls, "LinkCalls" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_close_call( n4 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n4 );
    refalrts::push_stack( n2 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eElems_b_1, eElems_e_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Reuse(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Var(refalrts::Iter, refalrts::Iter) {
  refalrts::this_is_generated_function();
  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult BuildResult_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult Group(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult BuildResult(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult lambda_BuildResult_0(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // (~1 s.Reuse s.Num & TkVariable s.Mode e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sReuse_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! refalrts::svar_left( sMode_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Var, "Var" ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
#ifdef OLD_PATTERN
    // (~1 s.Reuse s.Num & TkVariable s.Mode e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sReuse_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sMode_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#else
    // (~1 s.Reuse s.Num & TkVariable s.Mode e.Index )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    if( ! refalrts::svar_left( sReuse_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! refalrts::svar_left( sMode_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Var, (void*) "Var"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icFunc, (void*) & TkVariable, (void*) "TkVariable"},
      {refalrts::icSpliceSTVar, & sMode_1},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Var, "Var" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & TkVariable, "TkVariable" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n7, n10 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & PartReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & Reuse, "Reuse" );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & PartReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & PartReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & PartReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & PartReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Reuse, (void*) "Reuse"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Reuse, "Reuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & FullReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & Reuse, "Reuse" );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & FullReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & FullReuse, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & FullReuse e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & FullReuse, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Reuse, (void*) "Reuse"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Reuse, "Reuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_name( n1, & Reuse, "Reuse" );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Sample, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Sample e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Sample, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Reuse, (void*) "Reuse"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Reuse, "Reuse" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 & Alloc e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elems( res, n0, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Alloc e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Alloc, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 & Alloc e.Info )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Alloc, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & Alloc, (void*) "Alloc"},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_open_bracket( n4 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Alloc, "Alloc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::link_brackets( n4, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult lambda_BuildResult_1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eTaggedResult_b_1;
    refalrts::use( eTaggedResult_b_1 );
    static refalrts::Iter eTaggedResult_e_1;
    refalrts::use( eTaggedResult_e_1 );
    // e.TaggedResult
    eTaggedResult_b_1 = bb_0;
    refalrts::use( eTaggedResult_b_1 );
    eTaggedResult_e_1 = be_0;
    refalrts::use( eTaggedResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & Group, "Group" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n6, n7 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n1 );
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elems( res, n5, n8 );
    res = refalrts::splice_evar( res, eTaggedResult_b_1, eTaggedResult_e_1 );
    res = refalrts::splice_elems( res, n1, n4 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eTaggedResult_b_1;
    refalrts::use( eTaggedResult_b_1 );
    static refalrts::Iter eTaggedResult_e_1;
    refalrts::use( eTaggedResult_e_1 );
#ifdef OLD_PATTERN
    // e.TaggedResult
    eTaggedResult_b_1 = bb_0;
    refalrts::use( eTaggedResult_b_1 );
    eTaggedResult_e_1 = be_0;
    refalrts::use( eTaggedResult_e_1 );
#else
    // e.TaggedResult
    eTaggedResult_b_1 = bb_0;
    refalrts::use( eTaggedResult_b_1 );
    eTaggedResult_e_1 = be_0;
    refalrts::use( eTaggedResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & BuildResult_Aux, (void*) "BuildResult_Aux"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Group, (void*) "Group"},
      {refalrts::icSpliceEVar, & eTaggedResult_b_1, & eTaggedResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & Group, "Group" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_close_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n6, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::push_stack( n5 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eTaggedResult_b_1, eTaggedResult_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult BuildResult(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
    // e.Result
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & lambda_BuildResult_0, "lambda_BuildResult_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & lambda_BuildResult_1, "lambda_BuildResult_1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::push_stack( n8 );
    refalrts::push_stack( n1 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elems( res, n6, n8 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elems( res, n1, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eResult_b_1;
    refalrts::use( eResult_b_1 );
    static refalrts::Iter eResult_e_1;
    refalrts::use( eResult_e_1 );
#ifdef OLD_PATTERN
    // e.Result
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#else
    // e.Result
    eResult_b_1 = bb_0;
    refalrts::use( eResult_b_1 );
    eResult_e_1 = be_0;
    refalrts::use( eResult_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Fetch, (void*) "Fetch"},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Map, (void*) "Map"},
      {refalrts::icFunc, (void*) & lambda_BuildResult_0, (void*) "lambda_BuildResult_0"},
      {refalrts::icSpliceEVar, & eResult_b_1, & eResult_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icFunc, (void*) & lambda_BuildResult_1, (void*) "lambda_BuildResult_1"},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n1 = 0;
    if( ! refalrts::alloc_open_call( n1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n2 = 0;
    if( ! refalrts::alloc_name( n2, & Fetch, "Fetch" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n3 = 0;
    if( ! refalrts::alloc_open_call( n3 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n4 = 0;
    if( ! refalrts::alloc_name( n4, & Map, "Map" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & lambda_BuildResult_0, "lambda_BuildResult_0" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & lambda_BuildResult_1, "lambda_BuildResult_1" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n8 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eResult_b_1, eResult_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult BuildResult_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // e.Begin (~1 s.Num & TkVariable 'e e.Index )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'e', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & CmdInsertEVar, "CmdInsertEVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n1, n9 );
    refalrts::link_brackets( n7, n6 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
#ifdef OLD_PATTERN
    // e.Begin (~1 s.Num & TkVariable 'e e.Index )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_right( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::char_left( 'e', bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#else
    // e.Begin (~1 s.Num & TkVariable 'e e.Index )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    refalrts::Iter n4;
    if( (n4 = refalrts::char_left( 'e', bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n4 );
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & BuildResult_Aux, (void*) "BuildResult_Aux"},
      {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdInsertEVar, (void*) "CmdInsertEVar"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icChar, 0, 0, 'e'},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & CmdInsertEVar, "CmdInsertEVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_char( n15, 'e' ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n18 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n18 );
    refalrts::link_brackets( n12, n17 );
    res = refalrts::splice_elem( res, n17 );
    refalrts::link_brackets( n13, n16 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
    // e.Begin (~1 s.Num & TkVariable s.Mode e.Index )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! refalrts::svar_left( sMode_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & CmdInsertElem, "CmdInsertElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & ElSTVar, "ElSTVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n3 );
    //}}} REINITS
    refalrts::link_brackets( n1, n9 );
    refalrts::link_brackets( n7, n6 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n3 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n11, n12 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n3 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter sMode_1;
    refalrts::use( sMode_1 );
    static refalrts::Iter eIndex_b_1;
    refalrts::use( eIndex_b_1 );
    static refalrts::Iter eIndex_e_1;
    refalrts::use( eIndex_e_1 );
#ifdef OLD_PATTERN
    // e.Begin (~1 s.Num & TkVariable s.Mode e.Index )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_right( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::function_left( & TkVariable, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sMode_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#else
    // e.Begin (~1 s.Num & TkVariable s.Mode e.Index )~1 (~2 e.Scanned )~2
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_2;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_2;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    refalrts::Iter n3;
    if( (n3 = refalrts::function_left( & TkVariable, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n3 );
    if( ! refalrts::svar_left( sMode_1, bb_1, be_1 ) ) 
      break;
    eIndex_b_1 = bb_1;
    refalrts::use( eIndex_b_1 );
    eIndex_e_1 = be_1;
    refalrts::use( eIndex_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & BuildResult_Aux, (void*) "BuildResult_Aux"},
      {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdInsertElem, (void*) "CmdInsertElem"},
      {refalrts::icFunc, (void*) & ElSTVar, (void*) "ElSTVar"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icSpliceSTVar, & sMode_1},
      {refalrts::icSpliceEVar, & eIndex_b_1, & eIndex_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & CmdInsertElem, "CmdInsertElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & ElSTVar, "ElSTVar" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n18 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n18 );
    refalrts::link_brackets( n12, n17 );
    res = refalrts::splice_elem( res, n17 );
    refalrts::link_brackets( n13, n16 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eIndex_b_1, eIndex_e_1 );
    res = refalrts::splice_stvar( res, sMode_1 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // e.Begin (~1 (~2 s.Num e.Info )~2 )~1 (~3 e.Scanned )~3
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n2 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
      break;
    eInfo_b_1 = bb_2;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_2;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_name( n10, & CmdInsertElem, "CmdInsertElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & ElElem, "ElElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_call( n12 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n7 );
    refalrts::reinit_name( n9, & BuildResult_Aux, "BuildResult_Aux" );
    //}}} REINITS
    refalrts::link_brackets( n1, n6 );
    refalrts::link_brackets( n2, n5 );
    refalrts::push_stack( n12 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elems( res, n5, n6 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n10, n11 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
#ifdef OLD_PATTERN
    // e.Begin (~1 (~2 s.Num e.Info )~2 )~1 (~3 e.Scanned )~3
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_right( bb_3, be_3, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
      break;
    eInfo_b_1 = bb_2;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_2;
    refalrts::use( eInfo_e_1 );
#else
    // e.Begin (~1 (~2 s.Num e.Info )~2 )~1 (~3 e.Scanned )~3
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_3, be_3, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n7 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n6 = 0; // Right
    if( ! refalrts::brackets_match( n6, n1 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n2 ) ) 
      break;
    if( ! empty_seq( bb_1, be_1 ) )
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eScanned_b_1 = bb_3;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_3;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum_1, bb_2, be_2 ) ) 
      break;
    eInfo_b_1 = bb_2;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_2;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & BuildResult_Aux, (void*) "BuildResult_Aux"},
      {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdInsertElem, (void*) "CmdInsertElem"},
      {refalrts::icFunc, (void*) & ElElem, (void*) "ElElem"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_open_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_name( n11, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & CmdInsertElem, "CmdInsertElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_name( n15, & ElElem, "ElElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_close_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_call( n18 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n18 );
    refalrts::push_stack( n10 );
    res = refalrts::splice_elem( res, n18 );
    refalrts::link_brackets( n12, n17 );
    res = refalrts::splice_elem( res, n17 );
    refalrts::link_brackets( n13, n16 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eMiddle_b_1;
    refalrts::use( eMiddle_b_1 );
    static refalrts::Iter eMiddle_e_1;
    refalrts::use( eMiddle_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum1_1;
    refalrts::use( sNum1_1 );
    static refalrts::Iter eInfo2_b_1;
    refalrts::use( eInfo2_b_1 );
    static refalrts::Iter eInfo2_e_1;
    refalrts::use( eInfo2_e_1 );
    static refalrts::Iter sNum2_1;
    refalrts::use( sNum2_1 );
    static refalrts::Iter eInfo1_b_1;
    refalrts::use( eInfo1_b_1 );
    static refalrts::Iter eInfo1_e_1;
    refalrts::use( eInfo1_e_1 );
    // e.Begin (~1 (~2 s.Num1 e.Info2 )~2 e.Middle (~3 s.Num2 e.Info1 )~3 )~1 (~4 e.Scanned )~4
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_right( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n14 = 0; // Right
    if( ! refalrts::brackets_match( n14, n12 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n1 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n2 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_3, be_3, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n10 = 0; // Right
    if( ! refalrts::brackets_match( n10, n7 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eMiddle_b_1 = bb_1;
    refalrts::use( eMiddle_b_1 );
    eMiddle_e_1 = be_1;
    refalrts::use( eMiddle_e_1 );
    eScanned_b_1 = bb_4;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_4;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum1_1, bb_2, be_2 ) ) 
      break;
    eInfo2_b_1 = bb_2;
    refalrts::use( eInfo2_b_1 );
    eInfo2_e_1 = be_2;
    refalrts::use( eInfo2_e_1 );
    if( ! refalrts::svar_left( sNum2_1, bb_3, be_3 ) ) 
      break;
    eInfo1_b_1 = bb_3;
    refalrts::use( eInfo1_b_1 );
    eInfo1_e_1 = be_3;
    refalrts::use( eInfo1_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n7 );
    refalrts::reinit_name( n12, & BuildResult_Aux, "BuildResult_Aux" );
    refalrts::reinit_name( n11, & CmdInsertElem, "CmdInsertElem" );
    refalrts::reinit_name( n14, & ElSeq, "ElSeq" );
    //}}} REINITS
    refalrts::link_brackets( n1, n10 );
    refalrts::link_brackets( n2, n5 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_stvar( res, sNum2_1 );
    res = refalrts::splice_stvar( res, sNum1_1 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eBegin_b_1;
    refalrts::use( eBegin_b_1 );
    static refalrts::Iter eBegin_e_1;
    refalrts::use( eBegin_e_1 );
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    static refalrts::Iter sNum1_1;
    refalrts::use( sNum1_1 );
    static refalrts::Iter sNum2_1;
    refalrts::use( sNum2_1 );
    static refalrts::Iter eMiddle_b_1;
    refalrts::use( eMiddle_b_1 );
    static refalrts::Iter eMiddle_e_1;
    refalrts::use( eMiddle_e_1 );
    static refalrts::Iter eInfo2_b_1;
    refalrts::use( eInfo2_b_1 );
    static refalrts::Iter eInfo2_e_1;
    refalrts::use( eInfo2_e_1 );
    static refalrts::Iter eInfo1_b_1;
    refalrts::use( eInfo1_b_1 );
    static refalrts::Iter eInfo1_e_1;
    refalrts::use( eInfo1_e_1 );
#ifdef OLD_PATTERN
    // e.Begin (~1 (~2 s.Num1 e.Info2 )~2 e.Middle (~3 s.Num2 e.Info1 )~3 )~1 (~4 e.Scanned )~4
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    if( ! refalrts::brackets_right( bb_4, be_4, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_right( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_1, be_1 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    if( ! refalrts::brackets_right( bb_3, be_3, bb_1, be_1 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eMiddle_b_1 = bb_1;
    refalrts::use( eMiddle_b_1 );
    eMiddle_e_1 = be_1;
    refalrts::use( eMiddle_e_1 );
    eScanned_b_1 = bb_4;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_4;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum1_1, bb_2, be_2 ) ) 
      break;
    eInfo2_b_1 = bb_2;
    refalrts::use( eInfo2_b_1 );
    eInfo2_e_1 = be_2;
    refalrts::use( eInfo2_e_1 );
    if( ! refalrts::svar_left( sNum2_1, bb_3, be_3 ) ) 
      break;
    eInfo1_b_1 = bb_3;
    refalrts::use( eInfo1_b_1 );
    eInfo1_e_1 = be_3;
    refalrts::use( eInfo1_e_1 );
#else
    // e.Begin (~1 (~2 s.Num1 e.Info2 )~2 e.Middle (~3 s.Num2 e.Info1 )~3 )~1 (~4 e.Scanned )~4
    refalrts::Iter bb_4 = 0;
    refalrts::Iter be_4 = 0;
    refalrts::Iter n12;
    if( (n12 = refalrts::brackets_right( bb_4, be_4, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n12 );
    refalrts::Iter n14 = 0; // Right
    if( ! refalrts::brackets_match( n14, n12 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n1;
    if( (n1 = refalrts::brackets_right( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n1 );
    refalrts::Iter n11 = 0; // Right
    if( ! refalrts::brackets_match( n11, n1 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_2, be_2, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n5 = 0; // Right
    if( ! refalrts::brackets_match( n5, n2 ) ) 
      break;
    refalrts::Iter bb_3 = 0;
    refalrts::Iter be_3 = 0;
    refalrts::Iter n7;
    if( (n7 = refalrts::brackets_right( bb_3, be_3, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n7 );
    refalrts::Iter n10 = 0; // Right
    if( ! refalrts::brackets_match( n10, n7 ) ) 
      break;
    eBegin_b_1 = bb_0;
    refalrts::use( eBegin_b_1 );
    eBegin_e_1 = be_0;
    refalrts::use( eBegin_e_1 );
    eMiddle_b_1 = bb_1;
    refalrts::use( eMiddle_b_1 );
    eMiddle_e_1 = be_1;
    refalrts::use( eMiddle_e_1 );
    eScanned_b_1 = bb_4;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_4;
    refalrts::use( eScanned_e_1 );
    if( ! refalrts::svar_left( sNum1_1, bb_2, be_2 ) ) 
      break;
    eInfo2_b_1 = bb_2;
    refalrts::use( eInfo2_b_1 );
    eInfo2_e_1 = be_2;
    refalrts::use( eInfo2_e_1 );
    if( ! refalrts::svar_left( sNum2_1, bb_3, be_3 ) ) 
      break;
    eInfo1_b_1 = bb_3;
    refalrts::use( eInfo1_b_1 );
    eInfo1_e_1 = be_3;
    refalrts::use( eInfo1_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & BuildResult_Aux, (void*) "BuildResult_Aux"},
      {refalrts::icSpliceEVar, & eBegin_b_1, & eBegin_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icFunc, (void*) & CmdInsertElem, (void*) "CmdInsertElem"},
      {refalrts::icFunc, (void*) & ElSeq, (void*) "ElSeq"},
      {refalrts::icSpliceSTVar, & sNum1_1},
      {refalrts::icSpliceSTVar, & sNum2_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_open_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_name( n16, & BuildResult_Aux, "BuildResult_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_open_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_open_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_name( n19, & CmdInsertElem, "CmdInsertElem" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_name( n20, & ElSeq, "ElSeq" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n21 = 0;
    if( ! refalrts::alloc_close_bracket( n21 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n22 = 0;
    if( ! refalrts::alloc_close_bracket( n22 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n23 = 0;
    if( ! refalrts::alloc_close_call( n23 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n23 );
    refalrts::push_stack( n15 );
    res = refalrts::splice_elem( res, n23 );
    refalrts::link_brackets( n17, n22 );
    res = refalrts::splice_elem( res, n22 );
    refalrts::link_brackets( n18, n21 );
    res = refalrts::splice_elem( res, n21 );
    res = refalrts::splice_stvar( res, sNum2_1 );
    res = refalrts::splice_stvar( res, sNum1_1 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_elem( res, n19 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, eBegin_b_1, eBegin_e_1 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_elem( res, n15 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
    // (~1 e.Scanned )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eScanned_b_1 = bb_1;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_1;
    refalrts::use( eScanned_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eScanned_b_1;
    refalrts::use( eScanned_b_1 );
    static refalrts::Iter eScanned_e_1;
    refalrts::use( eScanned_e_1 );
#ifdef OLD_PATTERN
    // (~1 e.Scanned )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eScanned_b_1 = bb_1;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_1;
    refalrts::use( eScanned_e_1 );
#else
    // (~1 e.Scanned )~1
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n2 = 0; // Right
    if( ! refalrts::brackets_match( n2, n0 ) ) 
      break;
    if( ! empty_seq( bb_0, be_0 ) )
      break;
    eScanned_b_1 = bb_1;
    refalrts::use( eScanned_b_1 );
    eScanned_e_1 = be_1;
    refalrts::use( eScanned_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icSpliceEVar, & eScanned_b_1, & eScanned_e_1},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    res = refalrts::splice_evar( res, eScanned_b_1, eScanned_e_1 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Group_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end);

static refalrts::FnResult Group(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    // (~1 & Var e.Info )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Var, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_name( n5, & Group, "Group" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_call( n6 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    refalrts::reinit_open_call( n1 );
    //}}} REINITS
    refalrts::link_brackets( n0, n3 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_elem( res, n1 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n0 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
#ifdef OLD_PATTERN
    // (~1 & Var e.Info )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::function_left( & Var, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#else
    // (~1 & Var e.Info )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    refalrts::Iter n1;
    if( (n1 = refalrts::function_left( & Var, bb_1, be_1 )) == 0 ) 
      break;
    refalrts::use( n1 );
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Group, (void*) "Group"},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_bracket( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_close_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_call( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_name( n8, & Group, "Group" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n9 );
    refalrts::push_stack( n7 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    refalrts::link_brackets( n5, n6 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    // (~1 s.Reuse s.Num e.Info )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
    if( ! refalrts::svar_left( sReuse_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Group_Aux, "Group_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Inc, "Inc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
    if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_close_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_call( n13 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n12 );
    refalrts::link_brackets( n11, n4 );
    refalrts::push_stack( n13 );
    refalrts::push_stack( n6 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sNum_2 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elems( res, n8, n9 );
    res = refalrts::splice_stvar( res, sReuse_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
    static refalrts::Iter sNum_1;
    refalrts::use( sNum_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter sNum_2;
    refalrts::use( sNum_2 );
#ifdef OLD_PATTERN
    // (~1 s.Reuse s.Num e.Info )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
    if( ! refalrts::svar_left( sReuse_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#else
    // (~1 s.Reuse s.Num e.Info )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
    if( ! refalrts::svar_left( sReuse_1, bb_1, be_1 ) ) 
      break;
    if( ! refalrts::svar_left( sNum_1, bb_1, be_1 ) ) 
      break;
    eInfo_b_1 = bb_1;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_1;
    refalrts::use( eInfo_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Group_Aux, (void*) "Group_Aux"},
      {refalrts::icSpliceSTVar, & sReuse_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Inc, (void*) "Inc"},
      {refalrts::icSpliceSTVar, & sNum_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icCopySTVar, & sNum_1},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    if( ! refalrts::copy_stvar( sNum_2, sNum_1 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Group_Aux, "Group_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Inc, "Inc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_bracket( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_open_bracket( n12 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_close_bracket( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_close_bracket( n14 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n15 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    refalrts::link_brackets( n11, n14 );
    res = refalrts::splice_elem( res, n14 );
    refalrts::link_brackets( n12, n13 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sNum_2 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_stvar( res, sNum_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_stvar( res, sReuse_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    static refalrts::Iter tKey_1;
    refalrts::use( tKey_1 );
    static refalrts::Iter eVal_b_1;
    refalrts::use( eVal_b_1 );
    static refalrts::Iter eVal_e_1;
    refalrts::use( eVal_e_1 );
    // (~1 t.Key e.Val )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
    if( ! refalrts::tvar_left( tKey_1, bb_1, be_1 ) ) 
      break;
    eVal_b_1 = bb_1;
    refalrts::use( eVal_b_1 );
    eVal_e_1 = be_1;
    refalrts::use( eVal_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Group_Aux, "Group_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_call( n9 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n0, n8 );
    refalrts::link_brackets( n7, n3 );
    refalrts::push_stack( n9 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n3 );
    res = refalrts::splice_evar( res, eVal_b_1, eVal_e_1 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_elem( res, n0 );
    res = refalrts::splice_stvar( res, tKey_1 );
    res = refalrts::splice_elems( res, n5, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    static refalrts::Iter tKey_1;
    refalrts::use( tKey_1 );
    static refalrts::Iter eVal_b_1;
    refalrts::use( eVal_b_1 );
    static refalrts::Iter eVal_e_1;
    refalrts::use( eVal_e_1 );
#ifdef OLD_PATTERN
    // (~1 t.Key e.Val )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
    if( ! refalrts::tvar_left( tKey_1, bb_1, be_1 ) ) 
      break;
    eVal_b_1 = bb_1;
    refalrts::use( eVal_b_1 );
    eVal_e_1 = be_1;
    refalrts::use( eVal_e_1 );
#else
    // (~1 t.Key e.Val )~1 e.Tail
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n0;
    if( (n0 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n0 );
    refalrts::Iter n3 = 0; // Right
    if( ! refalrts::brackets_match( n3, n0 ) ) 
      break;
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
    if( ! refalrts::tvar_left( tKey_1, bb_1, be_1 ) ) 
      break;
    eVal_b_1 = bb_1;
    refalrts::use( eVal_b_1 );
    eVal_e_1 = be_1;
    refalrts::use( eVal_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Group_Aux, (void*) "Group_Aux"},
      {refalrts::icSpliceSTVar, & tKey_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eVal_b_1, & eVal_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n5 = 0;
    if( ! refalrts::alloc_open_call( n5 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_name( n6, & Group_Aux, "Group_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_open_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_bracket( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_close_bracket( n9 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_bracket( n10 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_close_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n11 );
    refalrts::push_stack( n5 );
    res = refalrts::splice_elem( res, n11 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    refalrts::link_brackets( n7, n10 );
    res = refalrts::splice_elem( res, n10 );
    refalrts::link_brackets( n8, n9 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_evar( res, eVal_b_1, eVal_e_1 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_stvar( res, tKey_1 );
    res = refalrts::splice_elem( res, n6 );
    res = refalrts::splice_elem( res, n5 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
#ifdef OLD_PATTERN
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#else
    //
    if( ! empty_seq( bb_0, be_0 ) )
      break;
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}

static refalrts::FnResult Group_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
    static refalrts::Iter sReuse_2;
    refalrts::use( sReuse_2 );
    static refalrts::Iter sNext_1;
    refalrts::use( sNext_1 );
    static refalrts::Iter sNext_2;
    refalrts::use( sNext_2 );
    static refalrts::Iter eGroup_b_1;
    refalrts::use( eGroup_b_1 );
    static refalrts::Iter eGroup_e_1;
    refalrts::use( eGroup_e_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    // s.Reuse s.Next (~1 e.Group )~1 (~2 s.Reuse s.Next e.Info )~2 e.Tail
    if( ! refalrts::svar_left( sReuse_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sNext_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n2 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n5;
    if( (n5 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n5 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n5 ) ) 
      break;
    if( ! refalrts::repeated_stvar_left( sReuse_2, sReuse_1, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::repeated_stvar_left( sNext_2, sNext_1, bb_2, be_2 ) ) 
      break;
    eGroup_b_1 = bb_1;
    refalrts::use( eGroup_b_1 );
    eGroup_e_1 = be_1;
    refalrts::use( eGroup_e_1 );
    eInfo_b_1 = bb_2;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_2;
    refalrts::use( eInfo_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & Group_Aux, "Group_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & Inc, "Inc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_close_call( n16 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n2, n9 );
    refalrts::link_brackets( n5, n4 );
    refalrts::push_stack( n16 );
    refalrts::push_stack( n11 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n16 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sNext_2 );
    res = refalrts::splice_elem( res, n5 );
    res = refalrts::splice_evar( res, eGroup_b_1, eGroup_e_1 );
    res = refalrts::splice_elem( res, n2 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_stvar( res, sNext_1 );
    res = refalrts::splice_elems( res, n13, n14 );
    res = refalrts::splice_stvar( res, sReuse_1 );
    res = refalrts::splice_elems( res, n11, n12 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
    static refalrts::Iter sNext_1;
    refalrts::use( sNext_1 );
    static refalrts::Iter sNext_2;
    refalrts::use( sNext_2 );
    static refalrts::Iter eGroup_b_1;
    refalrts::use( eGroup_b_1 );
    static refalrts::Iter eGroup_e_1;
    refalrts::use( eGroup_e_1 );
    static refalrts::Iter eInfo_b_1;
    refalrts::use( eInfo_b_1 );
    static refalrts::Iter eInfo_e_1;
    refalrts::use( eInfo_e_1 );
    static refalrts::Iter eTail_b_1;
    refalrts::use( eTail_b_1 );
    static refalrts::Iter eTail_e_1;
    refalrts::use( eTail_e_1 );
    static refalrts::Iter sReuse_2;
    refalrts::use( sReuse_2 );
#ifdef OLD_PATTERN
    // s.Reuse s.Next (~1 e.Group )~1 (~2 s.Reuse s.Next e.Info )~2 e.Tail
    if( ! refalrts::svar_left( sReuse_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sNext_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    if( ! refalrts::brackets_left( bb_2, be_2, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::repeated_stvar_left( sReuse_2, sReuse_1, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::repeated_stvar_left( sNext_2, sNext_1, bb_2, be_2 ) ) 
      break;
    eGroup_b_1 = bb_1;
    refalrts::use( eGroup_b_1 );
    eGroup_e_1 = be_1;
    refalrts::use( eGroup_e_1 );
    eInfo_b_1 = bb_2;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_2;
    refalrts::use( eInfo_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#else
    // s.Reuse s.Next (~1 e.Group )~1 (~2 s.Reuse s.Next e.Info )~2 e.Tail
    if( ! refalrts::svar_left( sReuse_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sNext_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n2 ) ) 
      break;
    refalrts::Iter bb_2 = 0;
    refalrts::Iter be_2 = 0;
    refalrts::Iter n5;
    if( (n5 = refalrts::brackets_left( bb_2, be_2, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n5 );
    refalrts::Iter n9 = 0; // Right
    if( ! refalrts::brackets_match( n9, n5 ) ) 
      break;
    if( ! refalrts::repeated_stvar_left( sReuse_2, sReuse_1, bb_2, be_2 ) ) 
      break;
    if( ! refalrts::repeated_stvar_left( sNext_2, sNext_1, bb_2, be_2 ) ) 
      break;
    eGroup_b_1 = bb_1;
    refalrts::use( eGroup_b_1 );
    eGroup_e_1 = be_1;
    refalrts::use( eGroup_e_1 );
    eInfo_b_1 = bb_2;
    refalrts::use( eInfo_b_1 );
    eInfo_e_1 = be_2;
    refalrts::use( eInfo_e_1 );
    eTail_b_1 = bb_0;
    refalrts::use( eTail_b_1 );
    eTail_e_1 = be_0;
    refalrts::use( eTail_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Group_Aux, (void*) "Group_Aux"},
      {refalrts::icSpliceSTVar, & sReuse_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Inc, (void*) "Inc"},
      {refalrts::icSpliceSTVar, & sNext_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eGroup_b_1, & eGroup_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceSTVar, & sNext_2},
      {refalrts::icSpliceEVar, & eInfo_b_1, & eInfo_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icSpliceEVar, & eTail_b_1, & eTail_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n11 = 0;
    if( ! refalrts::alloc_open_call( n11 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n12 = 0;
    if( ! refalrts::alloc_name( n12, & Group_Aux, "Group_Aux" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n13 = 0;
    if( ! refalrts::alloc_open_call( n13 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n14 = 0;
    if( ! refalrts::alloc_name( n14, & Inc, "Inc" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n15 = 0;
    if( ! refalrts::alloc_close_call( n15 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n16 = 0;
    if( ! refalrts::alloc_open_bracket( n16 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n17 = 0;
    if( ! refalrts::alloc_open_bracket( n17 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n18 = 0;
    if( ! refalrts::alloc_close_bracket( n18 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n19 = 0;
    if( ! refalrts::alloc_close_bracket( n19 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n20 = 0;
    if( ! refalrts::alloc_close_call( n20 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n20 );
    refalrts::push_stack( n11 );
    res = refalrts::splice_elem( res, n20 );
    res = refalrts::splice_evar( res, eTail_b_1, eTail_e_1 );
    refalrts::link_brackets( n16, n19 );
    res = refalrts::splice_elem( res, n19 );
    refalrts::link_brackets( n17, n18 );
    res = refalrts::splice_elem( res, n18 );
    res = refalrts::splice_evar( res, eInfo_b_1, eInfo_e_1 );
    res = refalrts::splice_stvar( res, sNext_2 );
    res = refalrts::splice_elem( res, n17 );
    res = refalrts::splice_evar( res, eGroup_b_1, eGroup_e_1 );
    res = refalrts::splice_elem( res, n16 );
    refalrts::push_stack( n15 );
    refalrts::push_stack( n13 );
    res = refalrts::splice_elem( res, n15 );
    res = refalrts::splice_stvar( res, sNext_1 );
    res = refalrts::splice_elem( res, n14 );
    res = refalrts::splice_elem( res, n13 );
    res = refalrts::splice_stvar( res, sReuse_1 );
    res = refalrts::splice_elem( res, n12 );
    res = refalrts::splice_elem( res, n11 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  do {
    refalrts::Iter bb_0 = arg_begin;
    refalrts::Iter be_0 = arg_end;
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_left( bb_0, be_0 );
    refalrts::move_right( bb_0, be_0 );
#ifdef OPTIMIZE_RESULT
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
    static refalrts::Iter sNext_1;
    refalrts::use( sNext_1 );
    static refalrts::Iter eGroup_b_1;
    refalrts::use( eGroup_b_1 );
    static refalrts::Iter eGroup_e_1;
    refalrts::use( eGroup_e_1 );
    static refalrts::Iter eOther_b_1;
    refalrts::use( eOther_b_1 );
    static refalrts::Iter eOther_e_1;
    refalrts::use( eOther_e_1 );
    // s.Reuse s.Next (~1 e.Group )~1 e.Other
    if( ! refalrts::svar_left( sReuse_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sNext_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n2 ) ) 
      break;
    eGroup_b_1 = bb_1;
    refalrts::use( eGroup_b_1 );
    eGroup_e_1 = be_1;
    refalrts::use( eGroup_e_1 );
    eOther_b_1 = bb_0;
    refalrts::use( eOther_b_1 );
    eOther_e_1 = be_0;
    refalrts::use( eOther_e_1 );

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    //{{{ ALLOCS
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_call( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_name( n7, & Group, "Group" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_close_call( n8 ) )
      return refalrts::cNoMemory;
    //}}} ALLOCS
    //{{{ REINITS
    //}}} REINITS
    refalrts::link_brackets( n2, n4 );
    refalrts::push_stack( n8 );
    refalrts::push_stack( n6 );
    res = refalrts::splice_elem( res, n8 );
    res = refalrts::splice_evar( res, eOther_b_1, eOther_e_1 );
    res = refalrts::splice_elems( res, n6, n7 );
    res = refalrts::splice_elem( res, n4 );
    res = refalrts::splice_evar( res, eGroup_b_1, eGroup_e_1 );
    res = refalrts::splice_elem( res, n2 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#else
    static refalrts::Iter eGroup_b_1;
    refalrts::use( eGroup_b_1 );
    static refalrts::Iter eGroup_e_1;
    refalrts::use( eGroup_e_1 );
    static refalrts::Iter eOther_b_1;
    refalrts::use( eOther_b_1 );
    static refalrts::Iter eOther_e_1;
    refalrts::use( eOther_e_1 );
    static refalrts::Iter sReuse_1;
    refalrts::use( sReuse_1 );
    static refalrts::Iter sNext_1;
    refalrts::use( sNext_1 );
#ifdef OLD_PATTERN
    // s.Reuse s.Next (~1 e.Group )~1 e.Other
    if( ! refalrts::svar_left( sReuse_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sNext_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    if( ! refalrts::brackets_left( bb_1, be_1, bb_0, be_0 ) ) 
      break;
    eGroup_b_1 = bb_1;
    refalrts::use( eGroup_b_1 );
    eGroup_e_1 = be_1;
    refalrts::use( eGroup_e_1 );
    eOther_b_1 = bb_0;
    refalrts::use( eOther_b_1 );
    eOther_e_1 = be_0;
    refalrts::use( eOther_e_1 );
#else
    // s.Reuse s.Next (~1 e.Group )~1 e.Other
    if( ! refalrts::svar_left( sReuse_1, bb_0, be_0 ) ) 
      break;
    if( ! refalrts::svar_left( sNext_1, bb_0, be_0 ) ) 
      break;
    refalrts::Iter bb_1 = 0;
    refalrts::Iter be_1 = 0;
    refalrts::Iter n2;
    if( (n2 = refalrts::brackets_left( bb_1, be_1, bb_0, be_0 )) == 0 ) 
      break;
    refalrts::use( n2 );
    refalrts::Iter n4 = 0; // Right
    if( ! refalrts::brackets_match( n4, n2 ) ) 
      break;
    eGroup_b_1 = bb_1;
    refalrts::use( eGroup_b_1 );
    eGroup_e_1 = be_1;
    refalrts::use( eGroup_e_1 );
    eOther_b_1 = bb_0;
    refalrts::use( eOther_b_1 );
    eOther_e_1 = be_0;
    refalrts::use( eOther_e_1 );
#endif
#ifdef INTERPRET
    const static refalrts::ResultAction raa[] = {
      {refalrts::icBracket, 0, 0, refalrts::ibOpenBracket},
      {refalrts::icSpliceEVar, & eGroup_b_1, & eGroup_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseBracket},
      {refalrts::icBracket, 0, 0, refalrts::ibOpenCall},
      {refalrts::icFunc, (void*) & Group, (void*) "Group"},
      {refalrts::icSpliceEVar, & eOther_b_1, & eOther_e_1},
      {refalrts::icBracket, 0, 0, refalrts::ibCloseCall},
      {refalrts::icEnd}
    };
    refalrts::Iter allocs[2*sizeof(raa)/sizeof(raa[0])];
    refalrts::FnResult res = refalrts::interpret_array( raa, allocs, arg_begin, arg_end );
    return res;
  } while ( 0 );
#else

    refalrts::reset_allocator();
    refalrts::Iter res = arg_begin;
    refalrts::Iter n6 = 0;
    if( ! refalrts::alloc_open_bracket( n6 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n7 = 0;
    if( ! refalrts::alloc_close_bracket( n7 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n8 = 0;
    if( ! refalrts::alloc_open_call( n8 ) )
      return refalrts::cNoMemory;
    refalrts::Iter n9 = 0;
    if( ! refalrts::alloc_name( n9, & Group, "Group" ) )
      return refalrts::cNoMemory;
    refalrts::Iter n10 = 0;
    if( ! refalrts::alloc_close_call( n10 ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( n10 );
    refalrts::push_stack( n8 );
    res = refalrts::splice_elem( res, n10 );
    res = refalrts::splice_evar( res, eOther_b_1, eOther_e_1 );
    res = refalrts::splice_elem( res, n9 );
    res = refalrts::splice_elem( res, n8 );
    refalrts::link_brackets( n6, n7 );
    res = refalrts::splice_elem( res, n7 );
    res = refalrts::splice_evar( res, eGroup_b_1, eGroup_e_1 );
    res = refalrts::splice_elem( res, n6 );
    refalrts::use( res );
    refalrts::splice_to_freelist( arg_begin, arg_end );
    return refalrts::cSuccess;
  } while ( 0 );
#endif
#endif

  return refalrts::cRecognitionImpossible;
}


//End of file
