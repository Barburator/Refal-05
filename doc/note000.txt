  ...

  Результаты.

  [1] В процессе лабы были разработаны следующие программы.

  ...

  * srefc -- собственно, сам компилятор языка. О нём далее будет сказано доста-
точно подробно.

  [2] Было опробовано несколько методов лексического анализа.

  ...

  [3] Особенности компилятора.
  В данной лабе при построении компилятора я опробовал для себя несколько новых
приёмов. В частности, использован трёхуровневый упрощённый алгоритм разбора и
независимая генерация различных элементов кода. Для генерации отдельных предло-
жений создавался абстрактный алгоритм (для каждого предложения) в виде последо-
вательности императивных команд. Затем этот алгоритм уже преобразовывался в
код, причём отдельные команды генерировались почти независимо друг от друга.
  ...

  (3.1) Краткий обзор языка.
  ...

  (3.2) Несколько слов о стандартных функциях.
  ...

  (3.3) Особенности синтаксического анализа.
  ...

  (3.4) Реализация виртуальной Рефал-машины.
  ...

  (3.5) Генерация предложений.
  ...

  Поддиапазоны аргумента и результата представляются парой итераторов двусвязно-
го списка (обычных указателей на узлы). При этом первый итератор указывает на
первый узел поддиапазона, второй итератор -- на последний. Пустая последователь-
ность представляется парой итераторов, установленных в NULL. В начале я пытался
использовать обозначение диапазонов в стиле STL -- указателями на первый элемент
и на элемент, следующий за последним. Однако, для правильного обращения с подоб-
ными поддиапазонами нужно более тщательно планировать последовательности команд
построения результата, т.к. в результате переноса (splicing) элементов, находя-
щихся непосредственно за рассматриваемым диапазонам, переместится и элемент, на
который указывает концевой итератор -- пара [first, last) больше не будет ука-
зывать на корректный диапазон. При использовании диапазонов [first, last] при
любых операциях с соседними диапазонами итераторы на текущий диапазон не изме-
нятся.
  Операции для распознавания жёстких элементов образца представлены элементарны-
ми функциями с суффиксами _left и _right (за исключением move_left и move_
right). Все они имеют примерно такой формат:
  bool ***_left( описание жёсткого элемента, Iter& first, Iter& last);
  bool ***_right( описание жёсткого элемента, Iter& first, Iter& last);
где *** -- тип жёсткого элемента (имя функции, число, символ, структурные скоб-
ки, повторная переменная, st-переменная). Описание жёсткого элемента представля-
ет собой набор параметров, характеризующих жёсткий элемент (значение для атомов,
ссылки на правый и левый конец подвыражения для структурных скобок, ссылку на
терм для s- и t-переменных, для повторных переменных -- описание образца (указа-
тель на терм для st-переменных, пара итераторов для e-переменных) и местораспо-
ложение самой переменной (ссылка на итератор для st- и на пару для e-перемен-
ных)). Сами функции возвращают true в случае успешного распознавания, перемещая
при этом итераторы first и last так, чтобы вновь созданный диапазон [first,
last] указывал на нераспознанную часть выражения. Пример:
  'abcdef' => { char_left } => 'bcdef'
  F G H => { function_right } => F G
  Если же распознать жёсткий элемент невозможно, то возвращается false, при этом
связанный список поля зрения не изменяется, не меняются значения переменных, пе-
реданных по ссылке.
  Предусловием для этих функций является правильное задание параметров описания
жёсткого элемента и правильное указание поддиапазона [first, last] (указывают на
концы, либо оба равны нулю).
  Постусловием является в случае правильно составленного алгоритма соблюдение
Общих требований 1-3.

  Для итерации используется простой цикл for по открытой e-переменной. Если на
некоторой итерации при некоторой длине e-переменной распознавание произошло ус-
пешно, то выполняется код выделения памяти и построения результата, который мо-
жет завершиться только выдачей сообщений refalrts::cNoMemory или refalrts::
cSuccess. В случае неудачного распознавания оставшихся элементов образца, ите-
рация завершается при помощи оператора continue и e-переменная удлиняется. Если
переменную уже удлинить нельзя, то происходит продвижение к концу обработчика
предложения: если этот цикл не вложен в другой цикл по e-переменной, то проис-
ходит переход к следующему предложению, иначе -- завершается также и итерация
внешнего цикла по e-переменной (элементарно -- из-за того, что мы достигли конца
тела цикла). Псевдокод:

  …

  При невозможности распознавания должна осуществляться возможность отката с
восстановлением предыдущего состояния (выполнения Правила 6), т.к. в процессе
распознавания изменяются переменные типа bb_N и be_N -- границы подвыражений
в скобках. Для восстановления значения используется следующее свойство языка C++
-- возможность объявлять переменные во вложенных блоках с тем же именем, что
и во внешнем блоке с сокрытием последних. Таким образом, в блоке инициализации
цикла for определяются переменные bb_N и be_N типа refalrts::Iter, которые ини-
циализированы значением одноимённых переменных во внешнем блоке. Таким образом,
для сохранения значения не приходится заводить переменные с новыми именами или
вложенным переменным давать другие имена (это бы пришлось делать при генерации
кода на Паскале). Но, поскольку результат инициализации refalrts::Iter bb_N =
bb_N; не определён, то приходится заводить промежуточную переменную:
    refalrts::Iter bb_N_stk = bb_N;
    refalrts::Iter be_N_stk = be_N;
    for(
      refalrts::Iter
        ...
        bb_N = bb_N_stk,
        be_N = be_N_stk,
        ...;
      ...;
      ...;
    ) {
      ...
    }
  К сожалению, здесь допущена ошибка.
  ...

  (3.5) Ограничения исследовательского прототипа.
  Полученный результат является исключительно исследовательским прототипом, для
использования в реальной жизни он не предназначен. Поэтому я его оставил его не-
доделанным. Недостатки самого языка (необходимость предварительного объявления
функций, отсутствие модульности и модель компоновки в стиле C, поддержка только
базисного подмножества и др.) недоделками я не считаю, т.к. это недостатки имен-
но языка, а не компилятора. Вот список недоделок.
  ...
  (4) Код генерируется довольно прямолинейно: отдельные команды абстрактного им-
перативного языка (алгоритма) генерируются независимо друг от друга. Часто пере-
менные дублируют друг друга (например, при наличии закрытых e-переменных внутри
скобок можно было бы избежать использования итераторов bb_N и be_N).
  (5) При более тщательной проработке алгоритма можно было бы использовать ука-
зания диапазонов в стиле STL. При этом можно было бы не использовать переменные
eVarName_e для указания конца e-переменных -- конец в таком случае ограничивал-
ся следующей за ней переменной.
  (6) Можно было бы повторно использовать литеральные элементы образца (атомы и
скобки) вместо выделения их из списка свободных блоков. Также можно повторно
использовать неиспльзуемые литеральные элементы и st-переменные, переинициализи-
руя их.
  (7) Если заглянуть в реализацию RTS, то можно заметить, что код распознавания
отдельных атомов, пар скобок, повторных переменных во многом похож, функции
***_left и ***_right похожи как близнецы-братья. В принципе, компилятор вместо
вставки кода для вызова функций мог бы вставлять операторы, представляющие собой
тело функции. Хотя это привело бы к резкому возрастанию объёма сгенерированного
кода.
  (8) Не производится никакой оптимизации. Из-за того, что отдельные предложения
генерируются независимо друг от друга, одни и те же операции (в случае, если
функция имеет определённый формат аргумента -- а так почти всегда) выполняются
многократно. В неэффективности этого можно убедиться, если посмотреть на код ав-
томата лексического анализатора в файлах Lexer.sref и Lexer.cpp. Надежды на то,
что одинаковые вычисления будут объединены компилятором C++ мало -- в ходе рас-
познавания вызываются внешние функции (см. п. 7), которые потенциально могут
иметь побочный эффект. Хотя, если бы предложения обрабатывались бы совместно,
линейное перечисление обработчиков можно было бы заменить деревом. Т.е. вместо

  /*
    Все три предложения имеют общий формат.
    Также первые два предложения имеют много общего в образце.
  */

  do {
    // распознавание первого предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  do {
    // распознавание второго предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  do {
    // распознавание третьего предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  return refalrts::cRecognitionImpossible;

можно было бы написать

  do {
    // распознавание общего для трёх предложений формата
    if( неудача распознавания )
      break;

    do {
      // распознавание общих элементов для первых двух предложений.
      if( неудача распознавания )
        break;

      do {
        // распознавание первого выражения
        if( неудача распознавания )
          break;
        // построение результата
        return refalrts::cNoMemory;
        return refalrts::cSuccess;
      } while(0)

      do {
        // распознавание второго выражения
        if( неудача распознавания )
          break;
        // построение результата
        return refalrts::cNoMemory;
        return refalrts::cSuccess;
      } while(0)

    } while(0);

    do {
      // распознавание второго выражения
      if( неудача распознавания )
        break;
      // построение результата
      return refalrts::cNoMemory;
      return refalrts::cSuccess;
    } while(0);

  } while(0);

  return refalrts::cRecognitionImpossible;

  В этом случае после неудачи распознавания первого предложения во втором при-
дётся выполнить минимум вычислений для распознавания, т.к. часть выражения уже
распознана.
  (9) Скудная библиотека стандартных внешних ("встроенных") функций. Этот недос-
таток при желании легко устраним.

  Выводы.

  [1] Компилятор, транслирующий Рефал в Си++, написал. О результатах исследова-
ния трансляции Рефал->C++ можно прочитать в разделе Результаты настоящего файла.
Те возможности языка, которые планировались в Цели лабы, были реализованы.
  Полученный компилятор работает, хотя и не без недостатков (см. выше).
  [2] Был написан самокомпилятор, а это значит, что языком можно пользоваться
для написания достаточно нетривиальных приложений (таких, как компилятор), а не
только Hello, World и Fibonacci программировать.
  [3] При исправлении некоторых ошибок и недоделок язык можно использовать и как
C++-back-end для Модульного Рефала (разумеется, адоптировав его под другой уро-
вень модульности). Причём можно использовать двояко: (1) генерация файлов на
Простом Рефале, а затем запуск компилятора Простого Рефала -- также как осущест-
вляется компиляция в back-end'е Рефала 5 и (2) интеграция кода самого компилято-
ра Простого Рефала в компилятор Модульного Рефала. Второй вариант облегчается
тем, что у нас имеется препроцессор, транслирующий Простой в Модульный Рефал.
  [4] Имеет смысл разработать генераторы лексического и синтаксического анализа-
торов. Это действительно удобно.
  [5] Если (когда) будет разрабатываться front-end для Модульного Рефала. порож-
дающий код на императивном языке, то целесообразно будет использовать границы
в стиле STL и более тщательное планирование сгенерированного алгоритма.
