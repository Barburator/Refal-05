  Цель лабы. Написать прототип компилятора Рефал -> Си++. Ставится задача толь-
ко исследовать компиляцию функций на Рефале в код на Си++. При этом такие зада-
чи, как обеспечение продвинутой модульности, концептуальной целостности языка и 
др. не ставятся. Достаточно обеспечить модульность (модель компоновки) языка Си
(все имена функций должны быть объявлены перед первым использованием, функции из
других единиц компоновки должны быть объявлены как extern, локальные функции со-
ответствуют статическим функциям языка Си, глобальные -- нестатическим). Доста-
точно, чтобы язык поддерживал 3 вида атомов: ascii-символы, макроцифры (перепол-
нение для простоты не проверяется), имена функций. Т.к. все функции сначала дол-
жны быть объявлены, имена функций, которые используются только как флаги, должны
быть объявлены как empty (как в Рефале-2). При этом раз уж имена соответствуют
фунциям, пускай одноимённые локальные функции разных единиц трансляции при срав-
нении на равенство (использование одноимённых переменных) являются неравными
друг другу (в отличие от Рефала-2 и Рефала-7, в которых равенство двух имён оп-
ределяется их именами). Встроенных функций нет, все функции, которые используют-
ся в программе, или объявлены в текущей единице трансляции, или являются внешни-
ми. Таких полезных расширений как абстрактные типы данных, не будет. Используе-
мое подмножество Рефала -- базисный Рефал.
  Поскольку, несмотря на ограничения, язык будет достаточно продвинутым, будет
вестись разработка самокомпилятора. Поэтому сначала язык будет реализован как
препроцессор, переводящий этот Рефал (назовём его Simple Refal), в Модульный
Рефал, который будет написан конечно же на Модульнолм Рефале.
  В дальнейшем, в случае удачной разработки, сам Модульный Рефал может использо-
вать этот язык как back-end для получения готовых .exe-шников.

  Результаты.

  [1] В процессе лабы были разработаны следующие программы.

  ...

  * srefc -- собственно, сам компилятор языка. О нём далее будет сказано доста-
точно подробно.

  [2] Было опробовано несколько методов лексического анализа.

  ...

  [3] Особенности компилятора.
  В данной лабе при построении компилятора я опробовал для себя несколько новых
приёмов. В частности, использован трёхуровневый упрощённый алгоритм разбора и
независимая генерация различных элементов кода. Для генерации отдельных предло-
жений создавался абстрактный алгоритм (для каждого предложения) в виде последо-
вательности императивных команд. Затем этот алгоритм уже преобразовывался в
код, причём отдельные команды генерировались почти независимо друг от друга.
  ...

  (3.1) Краткий обзор языка.
  ...

  (3.2) Несколько слов о стандартных функциях.
  ...

  Также к компилятору прилагается стандартное расширение библиотеки LibraryEx,
которое целиком написано на Рефале и содержит такие полезные функции, как Map,
Reduce, MapReduce, LoadFile, SaveFile и ряд других. Приводить их описания не
буду, т.к. их семантику можно легко понять из исходного кода.

  (3.3) Особенности синтаксического анализа.
  ...

  (3.4) Реализация виртуальной Рефал-машины.
  Виртуальная Рефал-машина была реализована по классической схеме с использова-
нием поля зрения. Поле зрения представляет собой двусвязанный список узлов, каж-
дый из которых представляет собой либо атом, либо ту или иную скобку (одну из
(, ), <, >). Узлы содержат связи с соседними узлами, поле типа и поле информа-
ции, которое представляет собой объединение (union) нескольких полей различных
типов. Узлы-числа в поле информации содержат unsigned long, узлы-символы --
char, узлы-функции содержат указатель на функцию и указатель на const char, со-
держащий имя функции. Узлы, соответствующие структурным скобкам, содержат связи
на сопряжённые им скобки. Указатели на скобки конкретизации находятся в стеке
вызовов в том порядке, в котором они должны вызываться. Если вызов функции за-
мещается активным выражением с другими скобками конкретизации, то эти скобки
конкретизации помещаются на вершину стека в правильном порядке -- так осуществ-
ляется сохранение инварианта стека. Для реализации данного стека используется
поле информации в узлах скобок (как в Рефале 2).
  Функция на Си++, соответствующая функции на Рефале, при выполнении может либо
заменить свой вызов в поле зрения, вернув при этом refalrts::cSuccess, либо за-
вершиться неудачно вследствие невозможности сопоставления или отсутствия памяти,
возратив при этом соответственно refalrts::cRecognitionImpossible или refalrts::
cNoMemory. При этом, если функция завершилась неудачно, она не изменяет свой ар-
гумент.
  Внутренне функция состоит из обработчиков отдельных предложений, каждое из ко-
торых либо может завершить функцию успешно (выполнить return refalrts::cSuccess)
или сообщить о невозможности выделения памяти (выполнить return refalrts::cNoMe-
mory). Если обработчик не завершил функцию с выдачей одного из этих сообщений,
то управление передаётся следующему обработчику, в случае последнего обработчика
-- оператору return refalrts::cRecognitionImpossible; в конце функции.
  Выполнение обработчика предложения проходит через три фазы:
  1. Распознаётся аргумент. В процессе распознавания аргумент не меняется. Если
распознавание невозможно, то выполняется выход из обработчика.
  2. Копируются переменные и строятся элементы результата, заданные литералами,
включая структурные и функциональные скобки (готовые скобки и атомы из обазца не
используются -- это сделано в целях упрощения компилятора). На этой стадии функ-
ция может выработать сообщение refalrts::cNoMemory. Новые элементы строятся
внутри списка свободных блоков (см. ниже). Аргумент функции при аварийном завер-
шении никак не изменяется.
  3. Создаётся результат из переменных образца и элементов, построение результа-
та осуществляется при помощи операций над двусвязанными списками, не нарушающими
инвариант -- перенос части цепочки из одного места в другое с исключением из
исходного местаположения (splicing). После построения результата остатки образ-
ца переносятся в список свободных блоков. Все операции в этой фазе не могут за-
вершиться неуспешно -- данная фаза завершается выдачей refalrts::cSuccess.
  Для распределения памяти используется двусвязанный список свободных узлов. Все
операции, выделяющие память (копирующие переменные или создающие новые узлы),
создают свой аргумент внутри этого списка. В дальнейшем участки списка с вновь
созданными элементами переносятся в список поля зрения при построении результа-
та. Подобная стратегия обеспечивает непротиворечивость обоих списков при выдаче
сообщения refalrts::cNoMemory -- созданные элементы остаются в списке свободных
блоков, аргумент не изменяется.

  (3.5) Генерация предложений.
  Генерация предложений осуществляется в две стадии: сначала по промежуточному
представлению создаётся обработчик на абстрактном императивном языке (т.е. пред-
ложение преобразуется в последовательность команд обработки), а затем уже обра-
ботчик переводится с абстактного императивного представления переводится на
Си++, причём отдельные команды транслируются практически независимо друг от дру-
га. Операции двух последних фаз: выделение новой памяти и сборка результата реа-
лизуются сравнительно несложно, а вот распознавание образца довольно интересно.

  Приведу правила сопоставления с образцом так, как они описаны в руководстве
к Рефалу 5, а затем прокомментирую, как они реализованы в настоящем компиляторе.

    Общие требования к отображению P на E (сопоставлению E : P )

  1. Если узел N2 расположен в P правее узла N1, то проекция  N2 в E может либо
совпадать с проекцией  N1, либо располагаться справа от нее (линии проектирова-
ния не могут пересекаться).
  2. Скобки и символы должны совпадать со своими проекциями.
  3. Проекции переменных должны удовлетворять синтаксическим требованиям их зна-
чений; т.е., быть символами, термами или произвольными выражениями для s-, t- и
e-переменных соответственно. Различные вхождения одной переменной должны иметь
одинаковые проекции. 

    Правила отображения

  1. После того, как отображена скобка, следующей подлежит отображению парная ей
скобка.
  2. Если в результате предыдущих шагов оба конца вхождения некоторой e-перемен-
ной уже отображены, но эта переменная еще не имеет значения (ни одно другое ее
вхождение не было отображено), то эта переменная отображается следующей. Такие
вхождения называются закрытыми e-переменными. Две закрытые e-переменные могут
появиться одновременно; в этом случае та, что слева, отображается первой.
  3. Вхождение переменной, которая уже получила значение, является повторным.
Скобки, символы, s-переменные, t-переменные и повторные вхождения e-переменных в
P являются жесткими элементами. Если один из концов жесткого элемента отображен,
проекция второго конца определена однозначно. Если Правила 1 и 2 неприменимы, и
имеется несколько жестких элементов с одним спроектированным концом, то из них
выбирается самый левый. Если возможно отобразить этот элемент, не вступая в про-
тиворечие с общими требованиями  1-3, приведенными выше, тогда он отображается,
и процесс продолжается дальше. В противном случае объявляется тупиковая ситуация.
  4. Если Правила 1-3 неприменимы и имеются несколько e-переменных с отображен-
ным левым концом, то выбирается самая левая из них. Она называется открытой
e-переменной. Первоначально она получает пустое значение, т.е., ее правый конец
проектируется на тот же узел, что и левый. Другие значения могут присваиваться
открытым переменным через удлинение (см. Правило 6).
  5. Если все элементы Р отображены, это значит, что процесс сопоставления ус-
пешно завершен.
  6. В тупиковой ситуации процесс возвращается назад к последней открытой e-пе-
ременной (т.е., к той, что имеет максимальный номер проекции), и ее значение
удлиняется; т.е., проекция ее правого конца в Е подвигается на один терм вправо.
После этого процесс возобновляется. Если переменную нельзя удлинить (из-за Общих
требований 1-3), удлиняется предшествующая открытая переменная, и т.д. Если не
имеется подлежащих удлинению открытых переменных, процесс сопоставления не удал-
ся.

  Однако, очевидно, что порядок отображения жёстких элементов и закрытых e-пере-
менных несущественнен с точки зрения окончательного результата. Важен лишь поря-
док отображения открытых e-переменных. Поэтому в моём случае при создании алго-
ритма распознавания образца (промежуточное абстрактное императивное представле-
ние в коде называется алгоритмом) порядок отображения жёстких элементов несколь-
ко другой, чем в описанных выше Правилах.
  Алгоритм распознавания образца моделируется так. Рассмотрим метод для случая
"плоского" выражения -- выражения без структурных скобок, затем обобщим на иера-
рхический случай. В образец вводятся два указателя -- левый и правый (обозначим
их как [ и ]). Эти указатели могут располагаться между отдельными термами образ-
ца или непосредственно справа или слева вне образца (таково изначальное положе-
ние правого и левого указателей соответственно). Далее, итеративно выполняется
просмотр образца и перемещение указателей по следующим правилам:
  1) Если справа от [ находится жёсткий элемент, то создаётся команда распозна-
вания этого жёсткого элемента от левого конца выражения и указатель сдвигается
на один элемент вправо.
  2) Аналогично, если слева от ] находится жёсткий элемент, то создаётся коман-
да распознавания этого жёсткого элемента от правого конца и указатель сдвигает-
ся на один элемент вправо.
  При этом, если при выполнении правил 1) или 2) распознаётся переменная, то
она запоминается как распознанная и в дальнейшем отождествляется как повторная.
  3) Если между указателями оказывается нераспознанная e-переменная: [e.Index],
то создаётся команда отождествления остатка выражения с данной e-переменной. При
этом процесс распознавания выражения завершается.
  4) Если указатели [ и ] встречаются, то создаётся команда проверки оставшегося
выражения на пустоту.
  5) Если справа от указателя [ и слева от указателя ] оказываются нераспознан-
ные e-переменные, то создаётся команда-маркер открытой e-переменной и указатель
[ сдвигается вправо на один эемент. В дальнейшем все команды между этим марке-
ром и до конца помещаются во вложенный цикл, в котором открытая переменная за
каждую итерацию увеличиватеся на терм и пробуется выполнение оставшихся команд.

  Пример.
    s.X 'a' 2 e.Y s.Z
    [ s.X 'a' 2 e.Y s.Z ] => svar_left(s.X),   s.X [ 'a' 2 e.Y s.Z ]
    s.X [ 'a' 2 e.Y s.Z ] => char_left('a'),   s.X 'a' [ 2 e.Y s.Z ]
    s.X 'a' [ 2 e.Y s.Z ] => numb_left( 2 ),   s.X 'a' 2 [ e.Y s.Z ]
    s.X 'a' 2 [ e.Y s.Z ] => svar_right(s.Z),  s.X 'a' 2 [ e.Y ] s.Z
    s.Z 'a' 2 [ e.Y ] s.Z => rest_evar(e.Y),   конец распознавания
  
    s.X 5 t.Z
    [ s.X 5 t.Z ]         => svar_left(s.X),   s.X [ 5 t.Z ]
    s.X [ 5 t.Z ]         => numb_left( 5 ),   s.X 5 [ t.Z ]
    s.X 5 [ t.Z ]         => tvar_left(t.Z),   s.X 5 t.Z [ ]
    s.X 5 t.Z [ ]         => rest_empty,       конец распознавания

    1 e.X 2 e.Y 3
    [ 1 e.X 2 e.Y 3 ]     => numb_left( 1 ),   1 [ e.X 2 e.Y 3 ]
    1 [ e.X 2 e.Y 3 ]     => numb_right( 3 ),  1 [ e.X 2 e.Y ] 3
    1 [ e.X 2 e.Y ] 3     => E_CYCLE( e.X ),   1 e.X [ 2 e.Y ] 3
    1 e.X [ 2 e.Y ] 3     => numb_left( 2 ),   1 e.X 2 [ e.Y ] 3
    1 e.X 2 [ e.Y ] 3     => rest_evar(e.Y),   конец распознавания

  Этот метод легко расширяется на случай скобочной структуры: указатели вводятся
не только для всего образца, но и для каждой отдельной пары скобок. Чтобы разли-
чать выражения в различных скобках, каждой паре скобок можно присвоить индивиду-
альный целочисленный индекс начиная с 1. Точно также получают свой индивидуаль-
ный индекс и указатели, при этом полный образец получает указатели с индексом 0.
Механизм распознавания для такого случая описывается псевдокодом на Рефале:

    PatternMatching {
      // Распознавание слева

      //1
      e.Left [_N t.Атом e.Right =
        atom_left( t.Atom, выражение N )
        <PatternMatchign e.Left t.Атом [_N e.Right>;

      //2
      e.Left [_N t.ПовторнаяПеременная e.Right =
        repeatedvar_left( t.ПовторнаяПеременная, выражение N )
        <PatternMatching e.Left t.ПовторнаяПеременная [_N e.Right>;

      //3
      e.Left [_N t.st-переменная e.Right =
        stvar_left( t.st-переменная, выражение N )
        Запомнить t.st-переменную как распознанную
        <PatternMathcing e.Left t.st-переменная [_N e.Right>;

      //4
      e.Left [_N (_M e.Inner )_M e.Right =
        инициализировать выражение M
        bracket_left( выражение M, выражение N )
        <PatternMatching
          e.Left (_M [_M e.Inner ]_M )_M [_N e.Right
        >;

      // Распознавание справа

      //5
      e.Left t.Атом ]_N e.Right =
        atom_right( t.Атом, выражение N )
        <PatternMatching e.Left ]_N t.Атом e.Right>;

      //6
      e.Left t.ПовторнаяПеременная ]_N e.Right =
        repeated_right( t.ПовторнаяПеременная, выражение N )
        <PatternMatching e.Left ]_N t.ПовторнаяПеременная e.Right>;

      //7
      e.Left t.st-переменная ]_N e.Right =
        stvar_right( t.st-переменная, выражение N )
        <PatternMatching e.Left ]_N t.st-переменная e.Right>;

      //8
      e.Left (_M e.Inner )_M ]_N e.Right =
        инициализировать выражение M
        brackets_right( выражение M, выражение N )
        <PatternMatching
          e.Left ]_N (_M [_M e.Inner ]_M )_M e.Right
        >;

      // Аннигиляция указателей и открытые e-переменные

      //9
      e.Left [_N t.Закрытая-e-переменная ]_N e.Right =
        closed_e( t.Закрытая-e-переменная, выражение N )
        Запомнить t.Закрытую-e-переменную как распознанную
        <PatternMatching e.Left t.Закрытая-e-переменная e.Right>;

      //10
      e.Left [_N ]_N e.Right =
        empty_expression( выражение N )
        <PatternMatching e.Left e.Right>;

      //11
      e.Left [_N t.Нераспознанная-e-переменная-1 e.Inner
      t.Нераспознанная-e-переменная-2 ]_N e.Right =
        E-CYCLE( t.Нераспознанная-e-переменная-1, выражение N )
        Запомнить t.Нераспознанную-e-переменную-1 как распознанную
        <PatternMatching
          e.Left t.Нераспознанная-e-переменная-1
          [_N e.Inner t.Нераспознанная-e-переменная-2 ]_N e.Right
        >;

      // Завершение цикла -- указателей не осталось

      //12
      e.Pattern = ;
    }

  Инициализация:

    Инициализировать выражение 0 аргументом
    <PatternMatching [_0 e.Pattern ]_0>;

  В псевдокоде обозначения [_N, ]_N, (_N, )_N обозначали соответственно пронуме-
рованные указатели и структурные скобки. С точностью до порядка отображения жёс-
тких элементов, данный алгоритм порождает порядок отображения, порождаемый Пра-
вилами 1-6. Покажем это.
  Правило 1 автоматически выполняется, если примитивные команды распознавания,
из которых строится алгоритм, распознают две скобоки одновременно. В настоящем
компиляторе так оно и есть. Предложения 4 и 8 как раз и порождают абстрактные
команды, выполняющие эту функцию.
  Для общности рассуждений будем считать, что аргумент, подлежащий распознава-
нию, погружён в пару скобок с номером 0: (_0 e.Pattern )_0. Это упростит описа-
ние, т.к. не надо будет явно выделять случаи расположения элементов непосредст-
венно рядом с краем. Таким образом, в начале обработки образец имеет вид (_0,
[_0 e.Pattern ]_0 )_0.
  Можно убедиться, что указатели разбивают каждое подвыражение на три части:
справа и слева находятся уже спроектированные элементы, непосредственно рядом
с указателями находятся элементы с одним спроектированным концом, а между ними
элементы со свободными концами. Если имеются жёсткие элементы со спроектирован-
ным левым концом, то предложения 1-4 создадут команды их распознавания. Анало-
гично, если есть жёсткие элементы со спроектированным правым концом, то они об-
рабатываются предложениями 5-8. Таким образом, с точностью до порядка распозна-
вания жёстких элементов, предложения 1-8 реализуют Правило 3.
  Если же имеется закрытая e-переменная, то она будет обработана предложением 9
-- реализация Правила 2.
  Правила 4 и 6 реализуются уже в самом сгенерированном коде -- все команды на-
чиная с команды-маркера E-CYCLE и до конца алгоритма построения выражения поме-
щаются во вложенный цикл (если после маркера E-CYCLE имеется другой маркер E-
CYCLE, то код между ним и концом помещается в другой вложенный цикл и т.д.).
Перед выполнением цикла сохраняются все указатели, которые могут измениться в
цикле, в начале каждой итерации указатели восстанавливаются, в конце каждой ите-
рации происходит удлинение открытой e-переменной на один терм. Если распознава-
ние образца возможно, то выполняются фазы 2 и 3, которые могут завершиться толь-
ко возвратом refalrts::cSuccess и refalrts::cNoMemory. Если же распознавание
при итерации по e-переменной невозможно, то запускается следующая итерация опе-
ратором continue языка C++. При неуспешном распознавании вне итерации происходит
выход из обработчика предложения и переход к следующему предложению или команде
return refalrts::cRecognitionImpossible.
  Каждый обработчик предложения находится внутри цикла do { ... } while(0);,
поэтому выйти из обработчика можно выполнив оператор break вне циклов по e-пере-
менным. Таким образом обработчик предложения выглядит примерно так:

  do {
    // ... Распознавание вне циклов по e-переменным
    if( на каком-то этапе распознавание невожможно )
      break;

    // итерация по открытой e-переменной
    // ... Сохранение нужных указателей
    for(
      инициализация цикла;
      пока удлинение возможно;
      удлинение на терм
    ) {
      // ... Восстановление нужных указателей

      // ... Распознавание внутри цикла
      if( на каком-то этапе распознавание невожможно )
        continue;

      // Образец разобран -- фаза 2 -- выделение памяти

      if( на каком-то этапе памяти не хватило )
        return refalrts::cNoMemory

      // ... Построение результата -- фаза 3
      return refalrts::cSuccess;
    }
  } while(0);

  Правило 5 реализуется за счёт выполнения предложения 12 -- если не осталось
указателей, которые находятся рядом с нераспознанными элементами (предшествующие
предложения обрабатывают все возможные случаи расположения указателей), то рас-
познавание завершается.

  Поддиапазоны аргумента и результата представляются парой итераторов двусвязно-
го списка (обычных указателей на узлы). При этом первый итератор указывает на
первый узел поддиапазона, второй итератор -- на последний. Пустая последователь-
ность представляется парой итераторов, установленных в NULL. В начале я пытался
использовать обозначение диапазонов в стиле STL -- указателями на первый элемент
и на элемент, следующий за последним. Однако, для правильного обращения с подоб-
ными поддиапазонами нужно более тщательно планировать последовательности команд
построения результата, т.к. в результате переноса (splicing) элементов, находя-
щихся непосредственно за рассматриваемым диапазонам, переместится и элемент, на
который указывает концевой итератор -- пара [first, last) больше не будет ука-
зывать на корректный диапазон. При использовании диапазонов [first, last] при
любых операциях с соседними диапазонами итераторы на текущий диапазон не изме-
нятся.
  Операции для распознавания жёстких элементов образца представлены элементарны-
ми функциями с суффиксами _left и _right (за исключением move_left и move_
right). Все они имеют примерно такой формат:
  bool ***_left( описание жёсткого элемента, Iter& first, Iter& last);
  bool ***_right( описание жёсткого элемента, Iter& first, Iter& last);
где *** -- тип жёсткого элемента (имя функции, число, символ, структурные скоб-
ки, повторная переменная, st-переменная). Описание жёсткого элемента представля-
ет собой набор параметров, характеризующих жёсткий элемент (значение для атомов,
ссылки на правый и левый конец подвыражения для структурных скобок, ссылку на
терм для s- и t-переменных, для повторных переменных -- описание образца (указа-
тель на терм для st-переменных, пара итераторов для e-переменных) и местораспо-
ложение самой переменной (ссылка на итератор для st- и на пару для e-перемен-
ных)). Сами функции возвращают true в случае успешного распознавания, перемещая
при этом итераторы first и last так, чтобы вновь созданный диапазон [first,
last] указывал на нераспознанную часть выражения. Пример:
  'abcdef' => { char_left } => 'bcdef'
  F G H => { function_right } => F G
  Если же распознать жёсткий элемент невозможно, то возвращается false, при этом
связанный список поля зрения не изменяется, не меняются значения переменных, пе-
реданных по ссылке.
  Предусловием для этих функций является правильное задание параметров описания
жёсткого элемента и правильное указание поддиапазона [first, last] (указывают на
концы, либо оба равны нулю).
  Постусловием является в случае правильно составленного алгоритма соблюдение
Общих требований 1-3.

  Для итерации используется простой цикл for по открытой e-переменной. Если на
некоторой итерации при некоторой длине e-переменной распознавание произошло ус-
пешно, то выполняется код выделения памяти и построения результата, который мо-
жет завершиться только выдачей сообщений refalrts::cNoMemory или refalrts::
cSuccess. В случае неудачного распознавания оставшихся элементов образца, ите-
рация завершается при помощи оператора continue и e-переменная удлиняется. Если
переменную уже удлинить нельзя, то происходит продвижение к концу обработчика
предложения: если этот цикл не вложен в другой цикл по e-переменной, то проис-
ходит переход к следующему предложению, иначе -- завершается также и итерация
внешнего цикла по e-переменной (элементарно -- из-за того, что мы достигли конца
тела цикла). Псевдокод:
  do {
    // распознавание до открытой e-переменной
    ...
    if( где-то распозавание не удалось )
      break;
    ...
    for(
      /* Инициализация */;
      /* Растяжение дальше возможно */;
      /* Удлинение переменной */;
    ) {
     ...
     if( где-то распознавание не удалось )
       continue;
     ...
      for(
        /* Инициализация */;
        /* Растяжение дальше возможно */;
        /* Удлинение переменной */;
      ) {
        ...
        //Выделение памяти
        ...
        if( нет памяти )
          return refalrts::cNoMemory;
        ...
        // Построение результата
        ...
        return refalrts::cSuccess;
      }
    }
  } while( 0 );

  При невозможности распознавания должна осуществляться возможность отката с
восстановлением предыдущего состояния (выполнения Правила 6), т.к. в процессе
распознавания изменяются переменные типа bb_N и be_N -- границы подвыражений
в скобках. Для восстановления значения используется следующее свойство языка C++
-- возможность объявлять переменные во вложенных блоках с тем же именем, что
и во внешнем блоке с сокрытием последних. Таким образом, в блоке инициализации
цикла for определяются переменные bb_N и be_N типа refalrts::Iter, которые ини-
циализированы значением одноимённых переменных во внешнем блоке. Таким образом,
для сохранения значения не приходится заводить переменные с новыми именами или
вложенным переменным давать другие имена (это бы пришлось делать при генерации
кода на Паскале). Но, поскольку результат инициализации refalrts::Iter bb_N =
bb_N; не определён, то приходится заводить промежуточную переменную:
    refalrts::Iter bb_N_stk = bb_N;
    refalrts::Iter be_N_stk = be_N;
    for(
      refalrts::Iter
        ...
        bb_N = bb_N_stk,
        be_N = be_N_stk,
        ...;
      ...;
      ...;
    ) {
      ...
    }
  К сожалению, здесь допущена ошибка. Данный механизм превосходно работает, но
сохраняется лишь значение границ того подвыражения, в котором находится откры-
тая e-переменная. Если внутри итерации модифицируются границы других подвыраже-
ний, то эти изменения сохраняются и дальнейшее распознавание происходит непра-
вильно. Например, при распознавании образца
  e.Begin (_1 e.Inner )_1 (_2 e.Any 'X' e.Inner )_2
модифицируются границы пары скобок №2, что приводит к невозможности сопоставле-
ния данного образца, например с выражением ('er') ('super') ('any' 'X' 'super').
  В принципе, эту ошибку легко устранить, сохраняя все распознанные к этому эта-
пу скобки (даже если они не модифицируются), но уже лень. Данный компилятор я не
собираюсь сопровождать (по крайней мере, в обозримом будущем).
  Также имело бы смысл сохранять ***_stk переменные не как указатели (refalrts::
Iter -- синоним (typedef) для указателей), а как ссылки на них (refalrts::Iter&)
-- согласно Стандарту ссылки определяются как просто другое имя переменной --
поэтому выделения памяти может для них даже и не происходить. Но я верю в силу
оптимизации современных компиляторов, которые способны устранить промежуточное
присваивание в цепочке b = a; c = b; если b больше нигде не используется и явля-
ется простым встроенным типом данных вроде указателя.
  Однако мне (не)повезло: компилятор успешно компилирует самого себя и нормально
работает не смотря на эту ошибку. Если бы эта ошибка приводила к неверным ре-
зультатам, то я бы её исправил и конечный результат имел бы на одну ошибку мень-
ше.

  (3.5) Ограничения исследовательского прототипа.
  Полученный результат является исключительно исследовательским прототипом, для
использования в реальной жизни он не предназначен. Поэтому я его оставил его не-
доделанным. Недостатки самого языка (необходимость предварительного объявления
функций, отсутствие модульности и модель компоновки в стиле C, поддержка только
базисного подмножества и др.) недоделками я не считаю, т.к. это недостатки имен-
но языка, а не компилятора. Вот список недоделок.
  ...
  (3) Есть неисправленыые ошибки, такие как ошибка сохранения состояния при от-
катах в открытых e-переменных (см. выше).
  (4) Код генерируется довольно прямолинейно: отдельные команды абстрактного им-
перативного языка (алгоритма) генерируются независимо друг от друга. Часто пере-
менные дублируют друг друга (например, при наличии закрытых e-переменных внутри
скобок можно было бы избежать использования итераторов bb_N и be_N).
  (5) При более тщательной проработке алгоритма можно было бы использовать ука-
зания диапазонов в стиле STL. При этом можно было бы не использовать переменные
eVarName_e для указания конца e-переменных -- конец в таком случае ограничивал-
ся следующей за ней переменной.
  (6) Можно было бы повторно использовать литеральные элементы образца (атомы и
скобки) вместо выделения их из списка свободных блоков. Также можно повторно
использовать неиспльзуемые литеральные элементы и st-переменные, переинициализи-
руя их.
  (7) Если заглянуть в реализацию RTS, то можно заметить, что код распознавания
отдельных атомов, пар скобок, повторных переменных во многом похож, функции
***_left и ***_right похожи как близнецы-братья. В принципе, компилятор вместо
вставки кода для вызова функций мог бы вставлять операторы, представляющие собой
тело функции. Хотя это привело бы к резкому возрастанию объёма сгенерированного
кода.
  (8) Не производится никакой оптимизации. Из-за того, что отдельные предложения
генерируются независимо друг от друга, одни и те же операции (в случае, если
функция имеет определённый формат аргумента -- а так почти всегда) выполняются
многократно. В неэффективности этого можно убедиться, если посмотреть на код ав-
томата лексического анализатора в файлах Lexer.sref и Lexer.cpp. Надежды на то,
что одинаковые вычисления будут объединены компилятором C++ мало -- в ходе рас-
познавания вызываются внешние функции (см. п. 7), которые потенциально могут
иметь побочный эффект. Хотя, если бы предложения обрабатывались бы совместно,
линейное перечисление обработчиков можно было бы заменить деревом. Т.е. вместо

  /*
    Все три предложения имеют общий формат.
    Также первые два предложения имеют много общего в образце.
  */

  do {
    // распознавание первого предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  do {
    // распознавание второго предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  do {
    // распознавание третьего предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  return refalrts::cRecognitionImpossible;

можно было бы написать

  do {
    // распознавание общего для трёх предложений формата
    if( неудача распознавания )
      break;

    do {
      // распознавание общих элементов для первых двух предложений.
      if( неудача распознавания )
        break;

      do {
        // распознавание первого выражения
        if( неудача распознавания )
          break;
        // построение результата
        return refalrts::cNoMemory;
        return refalrts::cSuccess;
      } while(0)

      do {
        // распознавание второго выражения
        if( неудача распознавания )
          break;
        // построение результата
        return refalrts::cNoMemory;
        return refalrts::cSuccess;
      } while(0)

    } while(0);

    do {
      // распознавание второго выражения
      if( неудача распознавания )
        break;
      // построение результата
      return refalrts::cNoMemory;
      return refalrts::cSuccess;
    } while(0);

  } while(0);

  return refalrts::cRecognitionImpossible;

  В этом случае после неудачи распознавания первого предложения во втором при-
дётся выполнить минимум вычислений для распознавания, т.к. часть выражения уже
распознана.
  (9) Скудная библиотека стандартных внешних ("встроенных") функций. Этот недос-
таток при желании легко устраним.

  Выводы.

  [1] Компилятор, транслирующий Рефал в Си++, написал. О результатах исследова-
ния трансляции Рефал->C++ можно прочитать в разделе Результаты настоящего файла.
Те возможности языка, которые планировались в Цели лабы, были реализованы.
  Полученный компилятор работает, хотя и не без недостатков (см. выше).
  [2] Был написан самокомпилятор, а это значит, что языком можно пользоваться
для написания достаточно нетривиальных приложений (таких, как компилятор), а не
только Hello, World и Fibonacci программировать.
  [3] При исправлении некоторых ошибок и недоделок язык можно использовать и как
C++-back-end для Модульного Рефала (разумеется, адоптировав его под другой уро-
вень модульности). Причём можно использовать двояко: (1) генерация файлов на
Простом Рефале, а затем запуск компилятора Простого Рефала -- также как осущест-
вляется компиляция в back-end'е Рефала 5 и (2) интеграция кода самого компилято-
ра Простого Рефала в компилятор Модульного Рефала. Второй вариант облегчается
тем, что у нас имеется препроцессор, транслирующий Простой в Модульный Рефал.
  [4] Имеет смысл разработать генераторы лексического и синтаксического анализа-
торов. Это действительно удобно.
  [5] Если (когда) будет разрабатываться front-end для Модульного Рефала. порож-
дающий код на императивном языке, то целесообразно будет использовать границы
в стиле STL и более тщательное планирование сгенерированного алгоритма.
