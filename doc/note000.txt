  ...

  Результаты.

  [1] В процессе лабы были разработаны следующие программы.

  ...

  * srefc -- собственно, сам компилятор языка. О нём далее будет сказано доста-
точно подробно.

  [2] Было опробовано несколько методов лексического анализа.

  ...

  [3] Особенности компилятора.
  В данной лабе при построении компилятора я опробовал для себя несколько новых
приёмов. В частности, использован трёхуровневый упрощённый алгоритм разбора и
независимая генерация различных элементов кода. Для генерации отдельных предло-
жений создавался абстрактный алгоритм (для каждого предложения) в виде последо-
вательности императивных команд. Затем этот алгоритм уже преобразовывался в
код, причём отдельные команды генерировались почти независимо друг от друга.
  ...

  (3.1) Краткий обзор языка.
  ...

  (3.2) Несколько слов о стандартных функциях.
  ...

  (3.3) Особенности синтаксического анализа.
  ...

  (3.4) Реализация виртуальной Рефал-машины.
  ...

  (3.5) Генерация предложений.
  Генерация предложений осуществляется в две стадии: сначала по промежуточному
представлению создаётся обработчик на абстрактном императивном языке (т.е. пред-
ложение преобразуется в последовательность команд обработки), а затем уже обра-
ботчик переводится с абстактного императивного представления переводится на
Си++, причём отдельные команды транслируются практически независимо друг от дру-
га. Операции двух последних фаз: выделение новой памяти и сборка результата реа-
лизуются сравнительно несложно, а вот распознавание образца довольно интересно.

  Приведу правила сопоставления с образцом так, как они описаны в руководстве
к Рефалу 5, а затем прокомментирую, как они реализованы в настоящем компиляторе.

    Общие требования к отображению P на E (сопоставлению E : P )

  1. Если узел N2 расположен в P правее узла N1, то проекция  N2 в E может либо
совпадать с проекцией  N1, либо располагаться справа от нее (линии проектирова-
ния не могут пересекаться).
  2. Скобки и символы должны совпадать со своими проекциями.
  3. Проекции переменных должны удовлетворять синтаксическим требованиям их зна-
чений; т.е., быть символами, термами или произвольными выражениями для s-, t- и
e-переменных соответственно. Различные вхождения одной переменной должны иметь
одинаковые проекции. 

    Правила отображения

  1. После того, как отображена скобка, следующей подлежит отображению парная ей
скобка.
  2. Если в результате предыдущих шагов оба конца вхождения некоторой e-перемен-
ной уже отображены, но эта переменная еще не имеет значения (ни одно другое ее
вхождение не было отображено), то эта переменная отображается следующей. Такие
вхождения называются закрытыми e-переменными. Две закрытые e-переменные могут
появиться одновременно; в этом случае та, что слева, отображается первой.
  3. Вхождение переменной, которая уже получила значение, является повторным.
Скобки, символы, s-переменные, t-переменные и повторные вхождения e-переменных в
P являются жесткими элементами. Если один из концов жесткого элемента отображен,
проекция второго конца определена однозначно. Если Правила 1 и 2 неприменимы, и
имеется несколько жестких элементов с одним спроектированным концом, то из них
выбирается самый левый. Если возможно отобразить этот элемент, не вступая в про-
тиворечие с общими требованиями  1-3, приведенными выше, тогда он отображается,
и процесс продолжается дальше. В противном случае объявляется тупиковая ситуация.
  4. Если Правила 1-3 неприменимы и имеются несколько e-переменных с отображен-
ным левым концом, то выбирается самая левая из них. Она называется открытой
e-переменной. Первоначально она получает пустое значение, т.е., ее правый конец
проектируется на тот же узел, что и левый. Другие значения могут присваиваться
открытым переменным через удлинение (см. Правило 6).
  5. Если все элементы Р отображены, это значит, что процесс сопоставления ус-
пешно завершен.
  6. В тупиковой ситуации процесс возвращается назад к последней открытой e-пе-
ременной (т.е., к той, что имеет максимальный номер проекции), и ее значение
удлиняется; т.е., проекция ее правого конца в Е подвигается на один терм вправо.
После этого процесс возобновляется. Если переменную нельзя удлинить (из-за Общих
требований 1-3), удлиняется предшествующая открытая переменная, и т.д. Если не
имеется подлежащих удлинению открытых переменных, процесс сопоставления не удал-
ся.

  Однако, очевидно, что порядок отображения жёстких элементов и закрытых e-пере-
менных несущественнен с точки зрения окончательного результата. Важен лишь поря-
док отображения открытых e-переменных. Поэтому в моём случае при создании алго-
ритма распознавания образца (промежуточное абстрактное императивное представле-
ние в коде называется алгоритмом) порядок отображения жёстких элементов несколь-
ко другой, чем в описанных выше Правилах.
  Алгоритм распознавания образца моделируется так. Рассмотрим метод для случая
"плоского" выражения -- выражения без структурных скобок, затем обобщим на иера-
рхический случай. В образец вводятся два указателя -- левый и правый (обозначим
их как [ и ]). Эти указатели могут располагаться между отдельными термами образ-
ца или непосредственно справа или слева вне образца (таково изначальное положе-
ние правого и левого указателей соответственно). Далее, итеративно выполняется
просмотр образца и перемещение указателей по следующим правилам:
  1) Если справа от [ находится жёсткий элемент, то создаётся команда распозна-
вания этого жёсткого элемента от левого конца выражения и указатель сдвигается
на один элемент вправо.
  2) Аналогично, если слева от ] находится жёсткий элемент, то создаётся коман-
да распознавания этого жёсткого элемента от правого конца и указатель сдвигает-
ся на один элемент вправо.
  При этом, если при выполнении правил 1) или 2) распознаётся переменная, то
она запоминается как распознанная и в дальнейшем отождествляется как повторная.
  3) Если между указателями оказывается нераспознанная e-переменная: [e.Index],
то создаётся команда отождествления остатка выражения с данной e-переменной. При
этом процесс распознавания выражения завершается.
  4) Если указатели [ и ] встречаются, то создаётся команда проверки оставшегося
выражения на пустоту.
  5) Если справа от указателя [ и слева от указателя ] оказываются нераспознан-
ные e-переменные, то создаётся команда-маркер открытой e-переменной и указатель
[ сдвигается вправо на один эемент. В дальнейшем все команды между этим марке-
ром и до конца помещаются во вложенный цикл, в котором открытая переменная за
каждую итерацию увеличиватеся на терм и пробуется выполнение оставшихся команд.

  Пример.
    s.X 'a' 2 e.Y s.Z
    [ s.X 'a' 2 e.Y s.Z ] => svar_left(s.X),   s.X [ 'a' 2 e.Y s.Z ]
    s.X [ 'a' 2 e.Y s.Z ] => char_left('a'),   s.X 'a' [ 2 e.Y s.Z ]
    s.X 'a' [ 2 e.Y s.Z ] => numb_left( 2 ),   s.X 'a' 2 [ e.Y s.Z ]
    s.X 'a' 2 [ e.Y s.Z ] => svar_right(s.Z),  s.X 'a' 2 [ e.Y ] s.Z
    s.Z 'a' 2 [ e.Y ] s.Z => rest_evar(e.Y),   конец распознавания
  
    s.X 5 t.Z
    [ s.X 5 t.Z ]         => svar_left(s.X),   s.X [ 5 t.Z ]
    s.X [ 5 t.Z ]         => numb_left( 5 ),   s.X 5 [ t.Z ]
    s.X 5 [ t.Z ]         => tvar_left(t.Z),   s.X 5 t.Z [ ]
    s.X 5 t.Z [ ]         => rest_empty,       конец распознавания

    1 e.X 2 e.Y 3
    [ 1 e.X 2 e.Y 3 ]     => numb_left( 1 ),   1 [ e.X 2 e.Y 3 ]
    1 [ e.X 2 e.Y 3 ]     => numb_right( 3 ),  1 [ e.X 2 e.Y ] 3
    1 [ e.X 2 e.Y ] 3     => E_CYCLE( e.X ),   1 e.X [ 2 e.Y ] 3
    1 e.X [ 2 e.Y ] 3     => numb_left( 2 ),   1 e.X 2 [ e.Y ] 3
    1 e.X 2 [ e.Y ] 3     => rest_evar(e.Y),   конец распознавания

  Этот метод легко расширяется на случай скобочной структуры: указатели вводятся
не только для всего образца, но и для каждой отдельной пары скобок. Чтобы разли-
чать выражения в различных скобках, каждой паре скобок можно присвоить индивиду-
альный целочисленный индекс начиная с 1. Точно также получают свой индивидуаль-
ный индекс и указатели, при этом полный образец получает указатели с индексом 0.
Механизм распознавания для такого случая описывается псевдокодом на Рефале:

    PatternMatching {
      // Распознавание слева

      //1
      e.Left [_N t.Атом e.Right =
        atom_left( t.Atom, выражение N )
        <PatternMatchign e.Left t.Атом [_N e.Right>;

      //2
      e.Left [_N t.ПовторнаяПеременная e.Right =
        repeatedvar_left( t.ПовторнаяПеременная, выражение N )
        <PatternMatching e.Left t.ПовторнаяПеременная [_N e.Right>;

      //3
      e.Left [_N t.st-переменная e.Right =
        stvar_left( t.st-переменная, выражение N )
        Запомнить t.st-переменную как распознанную
        <PatternMathcing e.Left t.st-переменная [_N e.Right>;

      //4
      e.Left [_N (_M e.Inner )_M e.Right =
        инициализировать выражение M
        bracket_left( выражение M, выражение N )
        <PatternMatching
          e.Left (_M [_M e.Inner ]_M )_M [_N e.Right
        >;

      // Распознавание справа

      //5
      e.Left t.Атом ]_N e.Right =
        atom_right( t.Атом, выражение N )
        <PatternMatching e.Left ]_N t.Атом e.Right>;

      //6
      e.Left t.ПовторнаяПеременная ]_N e.Right =
        repeated_right( t.ПовторнаяПеременная, выражение N )
        <PatternMatching e.Left ]_N t.ПовторнаяПеременная e.Right>;

      //7
      e.Left t.st-переменная ]_N e.Right =
        stvar_right( t.st-переменная, выражение N )
        <PatternMatching e.Left ]_N t.st-переменная e.Right>;

      //8
      e.Left (_M e.Inner )_M ]_N e.Right =
        инициализировать выражение M
        brackets_right( выражение M, выражение N )
        <PatternMatching
          e.Left ]_N (_M [_M e.Inner ]_M )_M e.Right
        >;

      // Аннигиляция указателей и открытые e-переменные

      //9
      e.Left [_N t.Закрытая-e-переменная ]_N e.Right =
        closed_e( t.Закрытая-e-переменная, выражение N )
        Запомнить t.Закрытую-e-переменную как распознанную
        <PatternMatching e.Left t.Закрытая-e-переменная e.Right>;

      //10
      e.Left [_N ]_N e.Right =
        empty_expression( выражение N )
        <PatternMatching e.Left e.Right>;

      //11
      e.Left [_N t.Нераспознанная-e-переменная-1 e.Inner
      t.Нераспознанная-e-переменная-2 ]_N e.Right =
        E-CYCLE( t.Нераспознанная-e-переменная-1, выражение N )
        Запомнить t.Нераспознанную-e-переменную-1 как распознанную
        <PatternMatching
          e.Left t.Нераспознанная-e-переменная-1
          [_N e.Inner t.Нераспознанная-e-переменная-2 ]_N e.Right
        >;

      // Завершение цикла -- указателей не осталось

      //12
      e.Pattern = ;
    }

  Инициализация:

    Инициализировать выражение 0 аргументом
    <PatternMatching [_0 e.Pattern ]_0>;

  В псевдокоде обозначения [_N, ]_N, (_N, )_N обозначали соответственно пронуме-
рованные указатели и структурные скобки. С точностью до порядка отображения жёс-
тких элементов, данный алгоритм порождает порядок отображения, порождаемый Пра-
вилами 1-6. Покажем это.
  Правило 1 автоматически выполняется, если примитивные команды распознавания,
из которых строится алгоритм, распознают две скобоки одновременно. В настоящем
компиляторе так оно и есть. Предложения 4 и 8 как раз и порождают абстрактные
команды, выполняющие эту функцию.
  Для общности рассуждений будем считать, что аргумент, подлежащий распознава-
нию, погружён в пару скобок с номером 0: (_0 e.Pattern )_0. Это упростит описа-
ние, т.к. не надо будет явно выделять случаи расположения элементов непосредст-
венно рядом с краем. Таким образом, в начале обработки образец имеет вид (_0,
[_0 e.Pattern ]_0 )_0.
  Можно убедиться, что указатели разбивают каждое подвыражение на три части:
справа и слева находятся уже спроектированные элементы, непосредственно рядом
с указателями находятся элементы с одним спроектированным концом, а между ними
элементы со свободными концами. Если имеются жёсткие элементы со спроектирован-
ным левым концом, то предложения 1-4 создадут команды их распознавания. Анало-
гично, если есть жёсткие элементы со спроектированным правым концом, то они об-
рабатываются предложениями 5-8. Таким образом, с точностью до порядка распозна-
вания жёстких элементов, предложения 1-8 реализуют Правило 3.
  Если же имеется закрытая e-переменная, то она будет обработана предложением 9
-- реализация Правила 2.
  Правила 4 и 6 реализуются уже в самом сгенерированном коде -- все команды на-
чиная с команды-маркера E-CYCLE и до конца алгоритма построения выражения поме-
щаются во вложенный цикл (если после маркера E-CYCLE имеется другой маркер E-
CYCLE, то код между ним и концом помещается в другой вложенный цикл и т.д.).
Перед выполнением цикла сохраняются все указатели, которые могут измениться в
цикле, в начале каждой итерации указатели восстанавливаются, в конце каждой ите-
рации происходит удлинение открытой e-переменной на один терм. Если распознава-
ние образца возможно, то выполняются фазы 2 и 3, которые могут завершиться толь-
ко возвратом refalrts::cSuccess и refalrts::cNoMemory. Если же распознавание
при итерации по e-переменной невозможно, то запускается следующая итерация опе-
ратором continue языка C++. При неуспешном распознавании вне итерации происходит
выход из обработчика предложения и переход к следующему предложению или команде
return refalrts::cRecognitionImpossible.

  …

  Правило 5 реализуется за счёт выполнения предложения 12 -- если не осталось
указателей, которые находятся рядом с нераспознанными элементами (предшествующие
предложения обрабатывают все возможные случаи расположения указателей), то рас-
познавание завершается.

  Поддиапазоны аргумента и результата представляются парой итераторов двусвязно-
го списка (обычных указателей на узлы). При этом первый итератор указывает на
первый узел поддиапазона, второй итератор -- на последний. Пустая последователь-
ность представляется парой итераторов, установленных в NULL. В начале я пытался
использовать обозначение диапазонов в стиле STL -- указателями на первый элемент
и на элемент, следующий за последним. Однако, для правильного обращения с подоб-
ными поддиапазонами нужно более тщательно планировать последовательности команд
построения результата, т.к. в результате переноса (splicing) элементов, находя-
щихся непосредственно за рассматриваемым диапазонам, переместится и элемент, на
который указывает концевой итератор -- пара [first, last) больше не будет ука-
зывать на корректный диапазон. При использовании диапазонов [first, last] при
любых операциях с соседними диапазонами итераторы на текущий диапазон не изме-
нятся.
  Операции для распознавания жёстких элементов образца представлены элементарны-
ми функциями с суффиксами _left и _right (за исключением move_left и move_
right). Все они имеют примерно такой формат:
  bool ***_left( описание жёсткого элемента, Iter& first, Iter& last);
  bool ***_right( описание жёсткого элемента, Iter& first, Iter& last);
где *** -- тип жёсткого элемента (имя функции, число, символ, структурные скоб-
ки, повторная переменная, st-переменная). Описание жёсткого элемента представля-
ет собой набор параметров, характеризующих жёсткий элемент (значение для атомов,
ссылки на правый и левый конец подвыражения для структурных скобок, ссылку на
терм для s- и t-переменных, для повторных переменных -- описание образца (указа-
тель на терм для st-переменных, пара итераторов для e-переменных) и местораспо-
ложение самой переменной (ссылка на итератор для st- и на пару для e-перемен-
ных)). Сами функции возвращают true в случае успешного распознавания, перемещая
при этом итераторы first и last так, чтобы вновь созданный диапазон [first,
last] указывал на нераспознанную часть выражения. Пример:
  'abcdef' => { char_left } => 'bcdef'
  F G H => { function_right } => F G
  Если же распознать жёсткий элемент невозможно, то возвращается false, при этом
связанный список поля зрения не изменяется, не меняются значения переменных, пе-
реданных по ссылке.
  Предусловием для этих функций является правильное задание параметров описания
жёсткого элемента и правильное указание поддиапазона [first, last] (указывают на
концы, либо оба равны нулю).
  Постусловием является в случае правильно составленного алгоритма соблюдение
Общих требований 1-3.

  Для итерации используется простой цикл for по открытой e-переменной. Если на
некоторой итерации при некоторой длине e-переменной распознавание произошло ус-
пешно, то выполняется код выделения памяти и построения результата, который мо-
жет завершиться только выдачей сообщений refalrts::cNoMemory или refalrts::
cSuccess. В случае неудачного распознавания оставшихся элементов образца, ите-
рация завершается при помощи оператора continue и e-переменная удлиняется. Если
переменную уже удлинить нельзя, то происходит продвижение к концу обработчика
предложения: если этот цикл не вложен в другой цикл по e-переменной, то проис-
ходит переход к следующему предложению, иначе -- завершается также и итерация
внешнего цикла по e-переменной (элементарно -- из-за того, что мы достигли конца
тела цикла). Псевдокод:

  …

  При невозможности распознавания должна осуществляться возможность отката с
восстановлением предыдущего состояния (выполнения Правила 6), т.к. в процессе
распознавания изменяются переменные типа bb_N и be_N -- границы подвыражений
в скобках. Для восстановления значения используется следующее свойство языка C++
-- возможность объявлять переменные во вложенных блоках с тем же именем, что
и во внешнем блоке с сокрытием последних. Таким образом, в блоке инициализации
цикла for определяются переменные bb_N и be_N типа refalrts::Iter, которые ини-
циализированы значением одноимённых переменных во внешнем блоке. Таким образом,
для сохранения значения не приходится заводить переменные с новыми именами или
вложенным переменным давать другие имена (это бы пришлось делать при генерации
кода на Паскале). Но, поскольку результат инициализации refalrts::Iter bb_N =
bb_N; не определён, то приходится заводить промежуточную переменную:
    refalrts::Iter bb_N_stk = bb_N;
    refalrts::Iter be_N_stk = be_N;
    for(
      refalrts::Iter
        ...
        bb_N = bb_N_stk,
        be_N = be_N_stk,
        ...;
      ...;
      ...;
    ) {
      ...
    }
  К сожалению, здесь допущена ошибка. Данный механизм превосходно работает, но
сохраняется лишь значение границ того подвыражения, в котором находится откры-
тая e-переменная. Если внутри итерации модифицируются границы других подвыраже-
ний, то эти изменения сохраняются и дальнейшее распознавание происходит непра-
вильно. Например, при распознавании образца
  e.Begin (_1 e.Inner )_1 (_2 e.Any 'X' e.Inner )_2
модифицируются границы пары скобок №2, что приводит к невозможности сопоставле-
ния данного образца, например с выражением ('er') ('super') ('any' 'X' 'super').
  В принципе, эту ошибку легко устранить, сохраняя все распознанные к этому эта-
пу скобки (даже если они не модифицируются), но уже лень. Данный компилятор я не
собираюсь сопровождать (по крайней мере, в обозримом будущем).
  Также имело бы смысл сохранять ***_stk переменные не как указатели (refalrts::
Iter -- синоним (typedef) для указателей), а как ссылки на них (refalrts::Iter&)
-- согласно Стандарту ссылки определяются как просто другое имя переменной --
поэтому выделения памяти может для них даже и не происходить. Но я верю в силу
оптимизации современных компиляторов, которые способны устранить промежуточное
присваивание в цепочке b = a; c = b; если b больше нигде не используется и явля-
ется простым встроенным типом данных вроде указателя.
  Однако мне (не)повезло: компилятор успешно компилирует самого себя и нормально
работает не смотря на эту ошибку. Если бы эта ошибка приводила к неверным ре-
зультатам, то я бы её исправил и конечный результат имел бы на одну ошибку мень-
ше.

  (3.5) Ограничения исследовательского прототипа.
  Полученный результат является исключительно исследовательским прототипом, для
использования в реальной жизни он не предназначен. Поэтому я его оставил его не-
доделанным. Недостатки самого языка (необходимость предварительного объявления
функций, отсутствие модульности и модель компоновки в стиле C, поддержка только
базисного подмножества и др.) недоделками я не считаю, т.к. это недостатки имен-
но языка, а не компилятора. Вот список недоделок.
  ...
  (3) Есть неисправленыые ошибки, такие как ошибка сохранения состояния при от-
катах в открытых e-переменных (см. выше).
  (4) Код генерируется довольно прямолинейно: отдельные команды абстрактного им-
перативного языка (алгоритма) генерируются независимо друг от друга. Часто пере-
менные дублируют друг друга (например, при наличии закрытых e-переменных внутри
скобок можно было бы избежать использования итераторов bb_N и be_N).
  (5) При более тщательной проработке алгоритма можно было бы использовать ука-
зания диапазонов в стиле STL. При этом можно было бы не использовать переменные
eVarName_e для указания конца e-переменных -- конец в таком случае ограничивал-
ся следующей за ней переменной.
  (6) Можно было бы повторно использовать литеральные элементы образца (атомы и
скобки) вместо выделения их из списка свободных блоков. Также можно повторно
использовать неиспльзуемые литеральные элементы и st-переменные, переинициализи-
руя их.
  (7) Если заглянуть в реализацию RTS, то можно заметить, что код распознавания
отдельных атомов, пар скобок, повторных переменных во многом похож, функции
***_left и ***_right похожи как близнецы-братья. В принципе, компилятор вместо
вставки кода для вызова функций мог бы вставлять операторы, представляющие собой
тело функции. Хотя это привело бы к резкому возрастанию объёма сгенерированного
кода.
  (8) Не производится никакой оптимизации. Из-за того, что отдельные предложения
генерируются независимо друг от друга, одни и те же операции (в случае, если
функция имеет определённый формат аргумента -- а так почти всегда) выполняются
многократно. В неэффективности этого можно убедиться, если посмотреть на код ав-
томата лексического анализатора в файлах Lexer.sref и Lexer.cpp. Надежды на то,
что одинаковые вычисления будут объединены компилятором C++ мало -- в ходе рас-
познавания вызываются внешние функции (см. п. 7), которые потенциально могут
иметь побочный эффект. Хотя, если бы предложения обрабатывались бы совместно,
линейное перечисление обработчиков можно было бы заменить деревом. Т.е. вместо

  /*
    Все три предложения имеют общий формат.
    Также первые два предложения имеют много общего в образце.
  */

  do {
    // распознавание первого предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  do {
    // распознавание второго предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  do {
    // распознавание третьего предложения
    if( неудача распознавания )
      break;
    // построение результата
    return refalrts::cNoMemory;
    return refalrts::cSuccess;
  } while(0);

  return refalrts::cRecognitionImpossible;

можно было бы написать

  do {
    // распознавание общего для трёх предложений формата
    if( неудача распознавания )
      break;

    do {
      // распознавание общих элементов для первых двух предложений.
      if( неудача распознавания )
        break;

      do {
        // распознавание первого выражения
        if( неудача распознавания )
          break;
        // построение результата
        return refalrts::cNoMemory;
        return refalrts::cSuccess;
      } while(0)

      do {
        // распознавание второго выражения
        if( неудача распознавания )
          break;
        // построение результата
        return refalrts::cNoMemory;
        return refalrts::cSuccess;
      } while(0)

    } while(0);

    do {
      // распознавание второго выражения
      if( неудача распознавания )
        break;
      // построение результата
      return refalrts::cNoMemory;
      return refalrts::cSuccess;
    } while(0);

  } while(0);

  return refalrts::cRecognitionImpossible;

  В этом случае после неудачи распознавания первого предложения во втором при-
дётся выполнить минимум вычислений для распознавания, т.к. часть выражения уже
распознана.
  (9) Скудная библиотека стандартных внешних ("встроенных") функций. Этот недос-
таток при желании легко устраним.

  Выводы.

  [1] Компилятор, транслирующий Рефал в Си++, написал. О результатах исследова-
ния трансляции Рефал->C++ можно прочитать в разделе Результаты настоящего файла.
Те возможности языка, которые планировались в Цели лабы, были реализованы.
  Полученный компилятор работает, хотя и не без недостатков (см. выше).
  [2] Был написан самокомпилятор, а это значит, что языком можно пользоваться
для написания достаточно нетривиальных приложений (таких, как компилятор), а не
только Hello, World и Fibonacci программировать.
  [3] При исправлении некоторых ошибок и недоделок язык можно использовать и как
C++-back-end для Модульного Рефала (разумеется, адоптировав его под другой уро-
вень модульности). Причём можно использовать двояко: (1) генерация файлов на
Простом Рефале, а затем запуск компилятора Простого Рефала -- также как осущест-
вляется компиляция в back-end'е Рефала 5 и (2) интеграция кода самого компилято-
ра Простого Рефала в компилятор Модульного Рефала. Второй вариант облегчается
тем, что у нас имеется препроцессор, транслирующий Простой в Модульный Рефал.
  [4] Имеет смысл разработать генераторы лексического и синтаксического анализа-
торов. Это действительно удобно.
  [5] Если (когда) будет разрабатываться front-end для Модульного Рефала. порож-
дающий код на императивном языке, то целесообразно будет использовать границы
в стиле STL и более тщательное планирование сгенерированного алгоритма.
