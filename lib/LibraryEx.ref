*===============================================================================
* Расширения библиотеки и функции, реализуемые средствами самого Рефала-05
*===============================================================================


* Основные перечисления
$EENUM Success, Fails;


$ENTRY Apply {
  s.Fn e.Argument = <s.Fn e.Argument>;

  (t.Closure e.Bounded) e.Argument =
    <Apply t.Closure e.Bounded e.Argument>;
}

$ENTRY Map {
  t.Fn t.Next e.Tail = <Apply t.Fn t.Next> <Map t.Fn e.Tail>;

  t.Fn = ;
}

$ENTRY Reduce {
  t.Fn t.Acc t.Next e.Tail =
    <Reduce
      t.Fn <Apply t.Fn t.Acc t.Next> e.Tail
    >;

  t.Fn t.Acc = t.Acc;
}

$ENTRY Fetch {
  e.Argument t.Function =
    <Apply t.Function e.Argument>;
}

$ENTRY MapReduce {
  t.Fn t.Acc e.Tail =
    <DoMapReduce t.Fn t.Acc () e.Tail>;
}

DoMapReduce {
  t.Fn t.Acc (e.Scanned) t.Next e.Tail =
    <DoMapReduce
      t.Fn
      <MapReduce-AddScanned
        <Apply t.Fn t.Acc t.Next> (e.Scanned)
      >
      e.Tail
    >;

  t.Fn t.Acc (e.Scanned) = t.Acc e.Scanned;
}

MapReduce-AddScanned {
  t.Acc e.StepScanned (e.Scanned) =
    t.Acc (e.Scanned e.StepScanned);
}

$ENTRY UnBracket {
  (e.Expr) = e.Expr;
}

$ENTRY DelAccumulator {
  t.Acc e.Tail = e.Tail;
}

LOAD-SAVE-HANDLE { = 20; }

$ENTRY LoadFile {
  e.FileName =
    <Open 'r' <LOAD-SAVE-HANDLE> e.FileName>
    <DoLoadFile <Get <LOAD-SAVE-HANDLE>>>
    <Close <LOAD-SAVE-HANDLE>>;
}

DoLoadFile {
  /* пусто */ 0 = /* конец файла, пропускаем тут пустую строку */;

  e.Line 0 = (e.Line) /* конец файла */;

  e.Line = (e.Line) <DoLoadFile <Get <LOAD-SAVE-HANDLE>>>;
}

$ENTRY SaveFile {
  (e.FileName) e.Lines =
    <Open 'w' <LOAD-SAVE-HANDLE> e.FileName>
    <Map WriteBracketLine e.Lines>
    <Close <LOAD-SAVE-HANDLE>>;
}

WriteBracketLine {
  (e.Line) = <Putout <LOAD-SAVE-HANDLE> e.Line>;
}

$ENTRY Inc {
  s.Num = <Add s.Num 1>;
}

$ENTRY Dec {
  s.Num = <Sub s.Num 1>;
}

$ENTRY ArgList {
  = <DoArgList 0>;
}

DoArgList {
  s.Next = <SwDoArgList <Inc s.Next> <Arg s.Next>>;
}

SwDoArgList {
  s.Next = ;

  s.Next e.Arg = (e.Arg) <DoArgList s.Next>;
}

$ENTRY Trim {
  ' ' e.Line = <Trim e.Line>;
  '\t' e.Line = <Trim e.Line>;
  '\r' e.Line = <Trim e.Line>;
  '\n' e.Line = <Trim e.Line>;
  e.Line = <Trim-R e.Line>;
}

Trim-R {
  e.Line ' ' = <Trim-R e.Line>;
  e.Line '\t' = <Trim-R e.Line>;
  e.Line '\r' = <Trim-R e.Line>;
  e.Line '\n' = <Trim-R e.Line>;
  e.Line = e.Line;
}

/**
  <Seq s.F1 s.F2 ... s.Fn> == s.Compose

  <s.Compose e.X> == <s.Fn ... <s.F2 <s.F1 e.X>>...>
*/
$ENTRY Seq {
  t.Func = t.Func;
  t.Func e.Funcs = (Seq-Aux t.Func (e.Funcs));
  /* пусто */ = Id;
}

Seq-Aux {
  t.Func (e.Funcs) e.Arg = <Fetch <Apply t.Func e.Arg> <Seq e.Funcs>>;
}

Id { e.Arg = e.Arg; }
