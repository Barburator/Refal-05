*$FROM Library
$EXTERN Open, Get, FOpen, FClose, FWriteLine, Add, Sub, Success, IntFromStr,
  Arg;


* Расширения библиотеки и функции, реализуемые
* средствами самого Простого Рефала

$ENTRY Apply {
  s.Fn e.Argument = <s.Fn e.Argument>;

  (t.Closure e.Bounded) e.Argument =
    <Apply t.Closure e.Bounded e.Argument>;
}

$ENTRY Map {
  t.Fn t.Next e.Tail = <Apply t.Fn t.Next> <Map t.Fn e.Tail>;

  t.Fn = ;
}

$ENTRY Reduce {
  t.Fn t.Acc t.Next e.Tail =
    <Reduce
      t.Fn <Apply t.Fn t.Acc t.Next> e.Tail
    >;

  t.Fn t.Acc = t.Acc;
}

$ENTRY Fetch {
  e.Argument t.Function =
    <Apply t.Function e.Argument>;
}

$ENTRY MapReduce {
  t.Fn t.Acc e.Tail =
    <DoMapReduce t.Fn t.Acc () e.Tail>;
}

DoMapReduce {
  t.Fn t.Acc (e.Scanned) t.Next e.Tail =
    <DoMapReduce
      t.Fn
      <MapReduce-AddScanned
        <Apply t.Fn t.Acc t.Next> (e.Scanned)
      >
      e.Tail
    >;

  t.Fn t.Acc (e.Scanned) = t.Acc e.Scanned;
}

MapReduce-AddScanned {
  t.Acc e.StepScanned (e.Scanned) =
    t.Acc (e.Scanned e.StepScanned);
}

$ENTRY UnBracket {
  (e.Expr) = e.Expr;
}

$ENTRY DelAccumulator {
  t.Acc e.Tail = e.Tail;
}

LOAD-SAVE-HANDLE { = 20; }

$ENTRY LoadFile {
  e.FileName =
    <Open 'r' <LOAD-SAVE-HANDLE> e.FileName>
    <DoLoadFile <Get <LOAD-SAVE-HANDLE>>>;
}

DoLoadFile {
  /* пусто */ 0 = /* <Close <LOAD-SAVE-HANDLE>> */;

  e.Line 0 = (e.Line) /* <Close <LOAD-SAVE-HANDLE>> */;

  e.Line = (e.Line) <DoLoadFile <Get <LOAD-SAVE-HANDLE>>>;
}

$ENTRY SaveFile {
  (e.FileName) e.Lines =
    <FClose
      <Reduce
        WriteBracketLine
        <FOpen 'w' e.FileName>
        e.Lines
      >
    >;
}

WriteBracketLine {
  t.File (e.Line) = <FWriteLine t.File e.Line>;
}

$ENTRY Inc {
  s.Num = <Add s.Num 1>;
}

$ENTRY Dec {
  s.Num = <Sub s.Num 1>;
}

FastIntFromStr-Guard {
  Success s.Number = s.Number;
}

$ENTRY FastIntFromStr {
  e.Digits =
    <FastIntFromStr-Guard
      <IntFromStr e.Digits>
    >;
}

$ENTRY ArgList {
  = <DoArgList 0>;
}

DoArgList {
  s.Next = <SwDoArgList <Inc s.Next> <Arg s.Next>>;
}

SwDoArgList {
  s.Next = ;

  s.Next e.Arg = (e.Arg) <DoArgList s.Next>;
}

$ENTRY Type {
  'A' e.X = 'LuA' e.X; 'B' e.X = 'LuB' e.X; 'C' e.X = 'LuC' e.X;
  'D' e.X = 'LuD' e.X; 'E' e.X = 'LuE' e.X; 'F' e.X = 'LuF' e.X;
  'G' e.X = 'LuG' e.X; 'H' e.X = 'LuH' e.X; 'I' e.X = 'LuI' e.X;
  'J' e.X = 'LuJ' e.X; 'K' e.X = 'LuK' e.X; 'L' e.X = 'LuL' e.X;
  'M' e.X = 'LuM' e.X; 'N' e.X = 'LuN' e.X; 'O' e.X = 'LuO' e.X;
  'P' e.X = 'LuP' e.X; 'Q' e.X = 'LuQ' e.X; 'R' e.X = 'LuR' e.X;
  'S' e.X = 'LuS' e.X; 'T' e.X = 'LuT' e.X; 'U' e.X = 'LuU' e.X;
  'V' e.X = 'LuV' e.X; 'W' e.X = 'LuW' e.X; 'X' e.X = 'LuX' e.X;
  'Y' e.X = 'LuY' e.X; 'Z' e.X = 'LuZ' e.X;

  'a' e.X = 'Lla' e.X; 'b' e.X = 'Llb' e.X; 'c' e.X = 'Llc' e.X;
  'd' e.X = 'Lld' e.X; 'e' e.X = 'Lle' e.X; 'f' e.X = 'Llf' e.X;
  'g' e.X = 'Llg' e.X; 'h' e.X = 'Llh' e.X; 'i' e.X = 'Lli' e.X;
  'j' e.X = 'Llj' e.X; 'k' e.X = 'Llk' e.X; 'l' e.X = 'Lll' e.X;
  'm' e.X = 'Llm' e.X; 'n' e.X = 'Lln' e.X; 'o' e.X = 'Llo' e.X;
  'p' e.X = 'Llp' e.X; 'q' e.X = 'Llq' e.X; 'r' e.X = 'Llr' e.X;
  's' e.X = 'Lls' e.X; 't' e.X = 'Llt' e.X; 'u' e.X = 'Llu' e.X;
  'v' e.X = 'Llv' e.X; 'w' e.X = 'Llw' e.X; 'x' e.X = 'Llx' e.X;
  'y' e.X = 'Lly' e.X; 'z' e.X = 'Llz' e.X;

  '0' e.X = 'D00' e.X; '1' e.X = 'D01' e.X; '2' e.X = 'D02' e.X;
  '3' e.X = 'D03' e.X; '4' e.X = 'D04' e.X; '5' e.X = 'D05' e.X;
  '6' e.X = 'D06' e.X; '7' e.X = 'D07' e.X; '8' e.X = 'D08' e.X;
  '9' e.X = 'D09' e.X;

  /* пусто */ = '*0' /* пусто */;
  e.Other = '??' e.Other;
}

$ENTRY Trim {
  ' ' e.Line = <Trim e.Line>;
  '\t' e.Line = <Trim e.Line>;
  '\r' e.Line = <Trim e.Line>;
  '\n' e.Line = <Trim e.Line>;
  e.Line = <Trim-R e.Line>;
}

Trim-R {
  e.Line ' ' = <Trim-R e.Line>;
  e.Line '\t' = <Trim-R e.Line>;
  e.Line '\r' = <Trim-R e.Line>;
  e.Line '\n' = <Trim-R e.Line>;
  e.Line = e.Line;
}

/**
  <Seq s.F1 s.F2 ... s.Fn> == s.Compose

  <s.Compose e.X> == <s.Fn ... <s.F2 <s.F1 e.X>>...>
*/
$ENTRY Seq {
  t.Func = t.Func;
  t.Func e.Funcs = (Seq-Aux t.Func (e.Funcs));
  /* пусто */ = Id;
}

Seq-Aux {
  t.Func (e.Funcs) e.Arg = <Fetch <Apply t.Func e.Arg> <Seq e.Funcs>>;
}

Id { e.Arg = e.Arg; }
