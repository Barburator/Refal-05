%%
#include <stdio.h>
#include <string.h>
#include <vector>
#include <ctype.h>
#include <stdlib.h>
%%


/**
   1. <Mu s.Func e.Arg> == <s.Func e.Arg>
*/
$ENTRY Mu {
  s.Func e.Arg = <s.Func e.Arg>;
}


/**
   2. <Add s.NUMBER s.NUMBER> == s.NUMBER
*/
%%
#define ARITHM_OP(op, check) \
  struct r05_node *func_name, *sX, *sY; \
  func_name = arg_begin->next; \
  \
  sX = func_name->next; \
  if (sX->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  sY = sX->next; \
  if (sY->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  if (sY->next != arg_end) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  check \
  \
  sX->info.number = sX->info.number op sY->info.number; \
  \
  r05_splice_to_freelist(arg_begin, func_name); \
  r05_splice_to_freelist(sY, arg_end); \
  \
  return R05_SUCCESS;

#define NO_CHECK
#define CHECK_ZERODIV \
  if (sY->info.number == 0) { \
    r05_builtin_error("divide by zero"); \
  }
%%


$ENTRY Add {
%%
  ARITHM_OP(+, NO_CHECK)
%%
}


/**
   3. <Ars s.ArgNo> == e.Argument

      s.ArgNo ::= s.NUMBER
      e.Argument ::= s.CHAR*
*/
$ENTRY Arg {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *parg_no = callable->next;
  int arg_no;

  if (
    parg_no == arg_end
    || R05_DATATAG_NUMBER != parg_no->tag
    || parg_no->next != arg_end
  ) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  arg_no = (int) parg_no->info.number;

  r05_reset_allocator();
  r05_alloc_string(r05_arg(arg_no));
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 4 Br
$EENUM Br;


/**
   5. <Card> == s.CHAR* 0?
*/
%%
static void read_from_stream(FILE *input);
%%

$ENTRY Card {
%%
  struct r05_node *callee = arg_begin->next;

  if (callee->next != arg_end) {
    r05_recognition_impossible();
  }

  r05_reset_allocator();
  read_from_stream(stdin);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


%%
static void read_from_stream(FILE *input) {
  int cur_char;

  while (cur_char = fgetc(input), cur_char != EOF && cur_char != '\n') {
    r05_alloc_char(cur_char);
  }

  if (cur_char == EOF) {
    r05_alloc_number(0);
  }
}
%%


/**
   6. <Chr e.Expr> == e.Expr’

   В e.Expr’ все числа заменены на литеры с соответствующими кодами
*/
$ENTRY Chr {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_NUMBER) {
      p->tag = R05_DATATAG_CHAR;
      p->info.char_ = (unsigned char) p->info.number;
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


* 7 Cp
$EENUM Cp;

* 8 Dg
$EENUM Dg;

* 9 Dgall
$EENUM Dgall;


/**
  10. <Div s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Div {
%%
  ARITHM_OP(/, CHECK_ZERODIV);
%%
}


/**
  11. <Divmod s.NUMBER s.NUMBER> == s.Div s.Mod
      s.Div, s.Mod ::= s.NUMBER
*/
$ENTRY Divmod {
  s.X s.Y = <Div s.X s.Y> <Mod s.X s.Y>;
}


/**
  12. <Explode s.FUNCTION> == s.CHAR+
*/
$ENTRY Explode {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *ident = callable->next;

  if (
     ident == arg_end
     || R05_DATATAG_FUNCTION != ident->tag
     || ident->next != arg_end
  ) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  r05_reset_allocator();
  r05_alloc_string(ident->info.function.name);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 13 First
$EENUM First;


/**
  14. <Get s.FileNo> == s.Char* 0?
      s.FileNo ::= s.NUMBER
*/
%%
FILE *open_numbered(unsigned int no, const char mode);
%%

$ENTRY Get {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pfile_no = callable->next;
  FILE *stream;

  if (
    pfile_no == arg_end
    || R05_DATATAG_NUMBER != pfile_no->tag
    || pfile_no->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  stream = open_numbered((unsigned int) pfile_no->info.number, 'r');

  r05_reset_allocator();
  read_from_stream(stream);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


%%
enum { FILE_LIMIT = 40 };

static FILE *s_streams[FILE_LIMIT] = { NULL };

enum { UINT_DIGITS = (sizeof(unsigned int) * 8 + 2) / 3 };

FILE *open_numbered(unsigned int file_no, const char mode) {
  char mode_str[] = { mode, '\0' };

  file_no %= FILE_LIMIT;
  if (file_no == 0 && mode == 'r') {
    return stdin;
  } else if (file_no == 0 && mode == 'w') {
    return stderr;
  }

  if (s_streams[file_no] == NULL) {
    static const char filename_format[] = "REFAL%u.DAT";
    char filename[sizeof(filename_format) + UINT_DIGITS];

    sprintf(filename, filename_format, file_no);
    s_streams[file_no] = fopen(filename, mode_str);

    if (s_streams[file_no] == NULL) {
      static const char error_format[] = "Can't open REFAL%u.DAT as \"%c\"";
      char error[sizeof(error_format) + UINT_DIGITS];

      sprintf(error, error_format, file_no, mode);
      perror(error_format);
      r05_builtin_error("Can't open file");
    }
  }

  return s_streams[file_no];
}
%%


* 15 Implode
$EENUM Implode;

* 16 Last
$EENUM Last;

* 17 Lenw
$EENUM Lenw;


/**
  18. <Lower e.Expr> == e.Expr’

  В e.Expr’ все буквы приведены к нижнему регистру
*/
$ENTRY Lower {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_CHAR) {
      p->info.char_ = tolower(p->info.char_);
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


/**
  19. <Mod s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Mod {
%%
  ARITHM_OP(%, CHECK_ZERODIV);
%%
}


/**
  18. <Mul s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Mul {
%%
  ARITHM_OP(*, NO_CHECK)
%%
}


/**
  21. <Numb s.Digit* e.Skipped> == s.NUMBER
      s.Digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

      Если аргумент не начинается с последовательности цифр,
      функция возвращает 0.
*/
$ENTRY Numb {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p;
  r05_number result = 0;

  for (
    p = callee->next;
    p != arg_end && R05_DATATAG_CHAR == p->tag && isdigit(p->info.char_);
    p = p->next
  ) {
    result = 10 * result + (p->info.char_ - '0');
  }

  arg_begin->tag = R05_DATATAG_NUMBER;
  arg_begin->info.number = result;

  r05_splice_to_freelist(callee, arg_end);

  return R05_SUCCESS;
%%
}


/**
  22. <Open s.Mode s.FileNo e.FileName> == []
      s.Mode ::=
          'r' | 'w' | 'a'
        |  r  |  w  |  a
        |  rb |  wb |  ab
*/
$EENUM r, w, a, rb, wb, ab;

%%
static void ensure_close_stream(unsigned int file_no);
%%

$ENTRY Open {
%%
  struct r05_node *eFileName_b, *eFileName_e, *sMode, *sFileNo;
  unsigned int file_no;
  char mode_str[2] = { '.', '\0' };
  const char *mode = mode_str;
  char filename[FILENAME_MAX + 1] = { '\0' };
  size_t filename_len;

  r05_prepare_argument(&eFileName_b, &eFileName_e, arg_begin, arg_end);

  if (
    ! r05_svar_left(&sMode, &eFileName_b, &eFileName_e)
    || (R05_DATATAG_CHAR != sMode->tag && R05_DATATAG_FUNCTION != sMode->tag)
    || ! r05_svar_left(&sFileNo, &eFileName_b, &eFileName_e)
    || R05_DATATAG_NUMBER != sFileNo->tag
  ) {
    r05_recognition_impossible();
    return R05_RECOGNITION_IMPOSSIBLE;  /* suppress warning */
  }

  filename_len =
    r05_read_chars(filename, FILENAME_MAX, &eFileName_b, &eFileName_e);

  if (filename_len == 0) {
    r05_recognition_impossible();
    return R05_RECOGNITION_IMPOSSIBLE;  /* suppress warning */
  }

  filename[filename_len] = '\0';

  if (R05_DATATAG_CHAR == sMode->tag) {
    char mode = sMode->info.char_;
    if (mode != 'r' && mode != 'w' && mode != 'a') {
      r05_builtin_error("Bad file mode, expected 'r', 'w' or 'a'");
      return R05_RECOGNITION_IMPOSSIBLE;        /* suppress warning */
    }
    mode_str[0] = mode;
  } else {
    mode = sMode->info.function.name;
  }

  if (! r05_empty_seq(eFileName_b, eFileName_e)) {
    static const char error_format[] =
      "Very long file name, maximum available is %u";
    char error[sizeof(error_format) + UINT_DIGITS];

    sprintf(error, error_format, (unsigned int) FILENAME_MAX);
    r05_builtin_error(error);
  }

  file_no = sFileNo->info.number % FILE_LIMIT;

  ensure_close_stream(file_no);

  s_streams[file_no] = fopen(filename, mode);
  if (s_streams[file_no] == NULL) {
    char mode_buffer[100] = { '\0' };
    static const char error_format[] = "Can't open %s for \"%s\"";
    char error[sizeof(error_format) + FILENAME_MAX + sizeof(mode_buffer)];

    strncpy(mode_buffer, mode, sizeof(mode_buffer) - 1);
    sprintf(error, error_format, filename, mode_buffer);
    perror(error);
    r05_builtin_error(error);
    return R05_RECOGNITION_IMPOSSIBLE;  /* suppress warning */
  }

  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}

%%
static void ensure_close_stream(unsigned int file_no) {
  if (s_streams[file_no] != NULL && fclose(s_streams[file_no]) == EOF) {
    perror("fclose()");
    r05_builtin_error("Can't close stream");
  }

  s_streams[file_no] = NULL;
}
%%


/**
  23. <Ord e.Expr> == e.Expr’

  В e.Expr’ все литеры заменены на их коды ASCII
*/
$ENTRY Ord {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_CHAR) {
      p->tag = R05_DATATAG_NUMBER;
      p->info.number = (unsigned char) p->info.char_;
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


/**
  24. <Print e.Expr> == e.Expr
*/
%%
enum output_func_type {
  PRINT, PROUT, PUT, PUTOUT,
};

static enum r05_fnresult output_func(
  struct r05_node *arg_begin, struct r05_node *arg_end,
  enum output_func_type type
);
%%

$ENTRY Print {
%%
  return output_func(arg_begin, arg_end, PRINT);
%%
}

%%
static enum r05_fnresult output_func(
  struct r05_node *arg_begin, struct r05_node *arg_end,
  enum output_func_type type
) {
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p, *before_expr;
  FILE *output;

  if (type == PRINT || type == PROUT) {
    before_expr = callee;
    output = stdout;
  } else if (type == PUT || type == PUTOUT) {
    struct r05_node *pfile_no = callee->next;

    if (R05_DATATAG_NUMBER != pfile_no->tag) {
      r05_recognition_impossible();
      return R05_RECOGNITION_IMPOSSIBLE;        /* suppress warning */
    }

    before_expr = pfile_no;
    output = open_numbered((unsigned int) pfile_no->info.number, 'w');
  } else {
    r05_switch_default_violation(type);
  }

#define CHECK_PRINTF(printf_call) \
  ((printf_call) >= 0 ? (void) 0 \
  : r05_builtin_error("Error in call " #printf_call))

  for (p = before_expr->next; p != arg_end; p = p->next) {
    switch (p->tag) {
      case R05_DATATAG_CHAR:
        CHECK_PRINTF(fprintf(output, "%c", p->info.char_));
        break;

      case R05_DATATAG_FILE:
        CHECK_PRINTF(fprintf(output, "*%p", p->info.file));
        break;

      case R05_DATATAG_FUNCTION:
        CHECK_PRINTF(fprintf(output, "%s ", p->info.function.name));
        break;

      case R05_DATATAG_NUMBER:
        CHECK_PRINTF(fprintf(output, "%lu ", (long unsigned int) p->info.number));
        break;

      case R05_DATATAG_OPEN_BRACKET:
        CHECK_PRINTF(fprintf(output, "("));
        break;

      case R05_DATATAG_CLOSE_BRACKET:
        CHECK_PRINTF(fprintf(output, ")"));
        break;

      default:
        r05_switch_default_violation(p->tag);
    }
  }

  CHECK_PRINTF(fprintf(output, "\n"));

#undef CHECK_PRINTF

  if (type == PRINT || type == PUT) {
    r05_splice_to_freelist(arg_begin, before_expr);
    r05_splice_to_freelist(arg_end, arg_end);
  } else if (type == PROUT || type == PUTOUT) {
    r05_splice_to_freelist(arg_begin, arg_end);
  } else {
    r05_switch_default_violation(type);
  }

  return R05_SUCCESS;
}
%%


/**
  25. <Prout e.Expr> == []
*/
$ENTRY Prout {
%%
  return output_func(arg_begin, arg_end, PROUT);
%%
}


/**
  26. <Put s.FileNo e.Expr> == e.Expr
*/
$ENTRY Put {
%%
  return output_func(arg_begin, arg_end, PUT);
%%
}


/**
  27. <Putout s.FileNo e.Expr> == []
*/
$ENTRY Putout {
%%
  return output_func(arg_begin, arg_end, PUTOUT);
%%
}


* 28 Rp
$EENUM Rp;

* 29 Step
$EENUM Step;


/**
  30. <Sub s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Sub {
%%
  ARITHM_OP(-, NO_CHECK)
%%
}


/**
  31. <Symb s.NUMBER> == s.CHAR+
*/
$ENTRY Symb {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pnumber = callable->next;
  r05_number number;

  /*
    Длина десятичного числа = 0,3 * длина двоичного числа,
    т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
  */
  enum { cMaxNumberLen = 8 * sizeof(r05_number) * 3 / 10 + 2 };

  char buffer[cMaxNumberLen + 1] = { '\0' };
  char *cur_digit = buffer + cMaxNumberLen;

  if (
    pnumber == arg_end
    || R05_DATATAG_NUMBER != pnumber->tag
    || pnumber->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  number = pnumber->info.number;

  r05_reset_allocator();

  if (number > 0) {
    while (number != 0) {
      -- cur_digit;
      *cur_digit = (number % 10) + '0';
      number /= 10;
    }

    r05_alloc_string(cur_digit);
  } else {
    r05_alloc_string("0");
  }

  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 32 Time
$EENUM Time;

* 33 Type
** $EENUM Type;

/**
  34. <Upper e.Expr> == e.Expr’

  В e.Expr’ все буквы приведены к верхнему регистру
*/
$ENTRY Upper {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_CHAR) {
      p->info.char_ = toupper(p->info.char_);
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


* 35 Sysfun
$EENUM Sysfun;

* 45 Freeze
$EENUM Freeze;

* 46 Freezer
$EENUM Freezer;

* 47 Dn
$EENUM Dn;

* 48 Up
$EENUM Up;

* 49 Ev-met
$EENUM Ev-met;

* 50 Residue
$EENUM Residue;

* 51 GetEnv
** $EENUM GetEnv;

* 52 System
** $EENUM System;

* 53 Exit
** $EENUM Exit;


/**
  54. <Close s.FileNo> == []
*/
$ENTRY Close {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pfile_no = callable->next;
  unsigned int file_no;

  if (
    pfile_no == arg_end
    || R05_DATATAG_NUMBER != pfile_no->tag
    || pfile_no->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  file_no = (unsigned int) pfile_no->info.number % FILE_LIMIT;
  ensure_close_stream(file_no);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 55 ExistFile
** $EENUM ExistFile;

* 56 GetCurrentDirectory
$EENUM GetCurrentDirectory;

* 57 RemoveFile
$EENUM RemoveFile;

* 58 Implode_Ext
$EENUM Implode_Ext;

* 59 Explode_Ext
$EENUM Explode_Ext;

* 60 TimeElapsed
$EENUM TimeElapsed;

/**
  61. <Compare s.X s.Y>
        == '-' | '0' | '+'
      s.X, s.Y ::= s.NUMBER

  Функция возвращает знак разности между s.X и s.Y
*/
$ENTRY Compare {
%%
  struct r05_node *func_name, *sX, *sY;

  func_name = arg_begin->next;
  sX = func_name->next;
  if (sX->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  sY = sX->next;
  if (sY->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  if (sY->next != arg_end) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  sX->info.char_ =
    sX->info.number < sY->info.number ? '-' :
    sX->info.number > sY->info.number ? '+' :
    '0';
  sX->tag = R05_DATATAG_CHAR;

  r05_splice_to_freelist(arg_begin, func_name);
  r05_splice_to_freelist(sY, arg_end);

  return R05_SUCCESS;
%%
}

* 62 DeSysfun
$EENUM DeSysfun;

* 63 XMLParse
$EENUM XMLParse;

* 64 Random
$EENUM Random;

* 65 RandomDigit
$EENUM RandomDigit;

* 66 Write
$EENUM Write;


/**
  67. <ListOfBuiltin> == (s.No s.Name s.Type)*

      s.No ::= s.NUMBER
      s.Name ::= s.FUNCTION
      s.Type ::= special | regular
*/
$EENUM special, regular;

$ENTRY ListOfBuiltin {
  = (1 Mu special)
    (2 Add regular)
    (3 Arg regular)
    (4 Br regular)
    (5 Card regular)
    (6 Chr regular)
    (7 Cp regular)
    (8 Dg regular)
    (9 Dgall regular)
    (10 Div regular)
    (11 Divmod regular)
    (12 Explode regular)
    (13 First regular)
    (14 Get regular)
    (15 Implode regular)
    (16 Last regular)
    (17 Lenw regular)
    (18 Lower regular)
    (19 Mod regular)
    (20 Mul regular)
    (21 Numb regular)
    (22 Open regular)
    (23 Ord regular)
    (24 Print regular)
    (25 Prout regular)
    (26 Put regular)
    (27 Putout regular)
    (28 Rp regular)
    (29 Step regular)
    (30 Sub regular)
    (31 Symb regular)
    (32 Time regular)
*    (33 Type regular)  /* in LibraryEx */
    (34 Upper regular)
    (35 Sysfun regular)
    /* (42 "Imp$$" regular) */
    /* (43 "Stop$$" regular) */
    /* (44 "" regular) */
    (45 Freeze regular)
    (46 Freezer regular)
    (47 Dn regular)
    (48 Up special)
    (49 Ev-met special)
    (50 Residue special)
    (51 GetEnv regular)
    (52 System regular)
    (53 Exit regular)
    (54 Close regular)
    (55 ExistFile regular)
    (56 GetCurrentDirectory regular)
    (57 RemoveFile regular)
    (58 Implode_Ext regular)
    (59 Explode_Ext regular)
    (60 TimeElapsed regular)
    (61 Compare regular)
    (62 DeSysfun regular)
    (63 XMLParse regular)
    (64 Random regular)
    (65 RandomDigit regular)
    (66 Write regular)
    (67 ListOfBuiltin regular)
    (68 SizeOf regular)
    (69 GetPID regular)
    (70 int4fab_1 regular)
    (71 GetPPID regular);
}


* 68 SizeOf
$EENUM SizeOf;

* 69 GetPID
$EENUM GetPID;

* 70 int4fab_1
$EENUM int4fab_1;

* 71 GetPPID
$EENUM GetPPID;



*===============================================================================
* Библиотека "встроенных" функций
*===============================================================================

* Основные перечисления

$EENUM Success, Fails, True, False;


%%
namespace {

enum r05_fnresult string_from_seq(
  std::vector<char>& string, struct r05_node *begin, struct r05_node *end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  for ( ; ; ) {
    unsigned read = r05_read_chars(buffer, cBufLen, &begin, &end);

    if (read == 0) {
      break;
    }

    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);

    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь r05_empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (r05_empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return R05_SUCCESS;
  } else {
    // здесь begin->tag != cDataChar
    return R05_RECOGNITION_IMPOSSIBLE;
  }
}

} // unnamed namespace
%%


$ENTRY ExistFile {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eFileName_b_1;
    struct r05_node *eFileName_e_1;
    // e.FileName
    eFileName_b_1 = bb_0;
    eFileName_e_1 = be_0;

    std::vector<char> fname;

    enum r05_fnresult fname_res =
      string_from_seq(fname, eFileName_b_1, eFileName_e_1);

    if (fname_res != R05_SUCCESS)
      return fname_res;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *ans = 0;
    if (FILE *f = fopen(&fname[0], "r")) {
      // Файл существует
      fclose(f);

      refalrts::alloc_name(ans, r05c_True, "True");
    } else {
      // Файл по-видимому не существует
      refalrts::alloc_name(ans, r05c_False, "False");
    }

    refalrts::splice_elem(res, ans);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY GetEnv {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    struct r05_node *eEnvName_b_1;
    struct r05_node *eEnvName_e_1;
    // e.EnvName
    eEnvName_b_1 = bb_0;
    eEnvName_e_1 = be_0;

    std::vector<char> envname;

    enum r05_fnresult envname_res =
      string_from_seq(envname, eEnvName_b_1, eEnvName_e_1);

    if (envname_res != R05_SUCCESS)
      return envname_res;

    r05_reset_allocator();

    const char *envres = getenv(& envname[0]);

    if (envres != 0) {
      struct r05_node *env_begin;
      struct r05_node *env_end;

      refalrts::alloc_string(env_begin, env_end, envres);

      refalrts::splice_evar(arg_begin, env_begin, env_end);

      //struct r05_node *char_pos;
      //
      //for (const char *env = envres; *env != '\0'; ++ env) {
      //  refalrts::alloc_char(char_pos, *env);
      //  refalrts::splice_elem(res, char_pos);
      //}
    }

    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY Exit {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sCode_1;
    // s.Code
    if (! r05_svar_left(&sCode_1, &bb_0, &be_0))
      break;
    if (sCode_1->tag != R05_DATATAG_NUMBER)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    r05_exit((int) sCode_1->info.number);
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY System {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eCommand_b_1;
    struct r05_node *eCommand_e_1;
    // e.Command
    eCommand_b_1 = bb_0;
    eCommand_e_1 = be_0;

    std::vector<char> command;

    enum r05_fnresult read_res =
      string_from_seq(command, eCommand_b_1, eCommand_e_1);

    if (read_res != R05_SUCCESS)
      return read_res;

    fflush(stdout);
    fflush(stderr);

    system(&command[0]);

    r05_reset_allocator();
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}
