%%
#include <stdio.h>
#include <string.h>
#include <vector>
#include <ctype.h>
#include <stdlib.h>

//FROM refalrts

//------------------------------------------------------------------------------

// Операции распределителя памяти

namespace refalrts{

namespace allocator {

bool alloc_node(struct r05_Node *&node);

struct r05_Node *free_ptr();

} // namespace allocator

} // namespace refalrts
%%


*===============================================================================
* Библиотека "встроенных" функций
*===============================================================================

* Основные перечисления

$EENUM Success, Fails, True, False;

* Математические операции


%%

#define ARITHM_OP(op, check) \
  struct r05_Node *func_name = arg_begin->next; \
  \
  struct r05_Node *sX = func_name->next; \
  if (sX->tag != r05_cDataNumber) { \
    return r05_cRecognitionImpossible; \
  } \
  \
  struct r05_Node *sY = sX->next; \
  if (sY->tag != r05_cDataNumber) { \
    return r05_cRecognitionImpossible; \
  } \
  \
  if (sY->next != arg_end) { \
    return r05_cRecognitionImpossible; \
  } \
  \
  check \
  \
  sX->info.number = sX->info.number op sY->info.number; \
  \
  refalrts::splice_to_freelist(arg_begin, func_name); \
  refalrts::splice_to_freelist(sY, arg_end); \
  \
  return r05_cSuccess;

#define NO_CHECK
#define CHECK_ZERODIV \
  if (sY->info.number == 0) { \
    return r05_cRecognitionImpossible; \
  }

%%


$ENTRY Add {
%%
  ARITHM_OP(+, NO_CHECK)
%%
}

$ENTRY Sub {
%%
  ARITHM_OP(-, NO_CHECK)
%%
}

$ENTRY Mul {
%%
  ARITHM_OP(*, NO_CHECK)
%%
}

$ENTRY Div {
%%
  ARITHM_OP(/, CHECK_ZERODIV);
%%
}

$ENTRY Mod {
%%
  ARITHM_OP(%, CHECK_ZERODIV);
%%
}


* Ввод-вывод


%%
enum r05_FnResult write_to_stream(
  FILE *out, struct r05_Node *str_begin, struct r05_Node *str_end
) {
  if (ferror(out)) {
    return r05_cRecognitionImpossible;
  }

  int printf_res;

  for (
    struct r05_Node *p = str_begin;
    ! refalrts::empty_seq(p, str_end);
    refalrts::move_left(p, str_end)
  ) {
    switch(p->tag) {
      case r05_cDataChar: {
        printf_res = fprintf(out, "%c", p->info.char_);
        if (printf_res < 0) {
          return r05_cRecognitionImpossible;
        } else {
          break;
        }
      }

      case r05_cDataNumber: {
        printf_res = fprintf(out, "%lu ", p->info.number);
        if (printf_res < 0) {
          return r05_cRecognitionImpossible;
        } else {
          break;
        }
      }

      case r05_cDataFunction: {
        if (p->info.function.name[0] != '\0') {
          printf_res = fprintf(out, "%s ", p->info.function.name);
        } else {
          printf_res = fprintf(out, "&%p ", p->info.function.ptr);
        }

        if (printf_res < 0) {
          return r05_cRecognitionImpossible;
        } else {
          break;
        }
      }

      case r05_cDataOpenBracket: {
        printf_res = fprintf(out, "(");
        if (printf_res < 0) {
          return r05_cRecognitionImpossible;
        } else {
          break;
        }
      }

      case r05_cDataCloseBracket: {
        printf_res = fprintf(out, ")");
        if (printf_res < 0) {
          return r05_cRecognitionImpossible;
        } else {
          break;
        }
      }

      case r05_cDataFile: {
        printf_res = fprintf(out, "*%p", p->info.file);
        if (printf_res < 0) {
          return r05_cRecognitionImpossible;
        } else {
          break;
        }
      }

      default:
        r05_switch_default_violation(p->tag);
    }
  }

  printf_res = fprintf(out, "\n");
  if (printf_res < 0) {
    return r05_cRecognitionImpossible;
  } else {
    return r05_cSuccess;
  }
}
%%


$ENTRY WriteLine {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *eLine_b_1;
    struct r05_Node *eLine_e_1;
    eLine_b_1 = bb_0;
    refalrts::use(eLine_b_1);
    eLine_e_1 = be_0;
    refalrts::use(eLine_e_1);

    enum r05_FnResult fnres =
      write_to_stream(stdout, eLine_b_1, eLine_e_1);

    if (fnres != r05_cSuccess)
      return fnres;

    refalrts::reset_allocator();
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return fnres;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY FWriteLine {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sFileHandle_1;
    struct r05_Node *eLine_b_1;
    struct r05_Node *eLine_e_1;
    // s.FileHandle e.Line
    if (! refalrts::svar_left(sFileHandle_1, bb_0, be_0))
      break;
    if (sFileHandle_1->tag != r05_cDataFile)
      break;
    eLine_b_1 = bb_0;
    refalrts::use(eLine_b_1);
    eLine_e_1 = be_0;
    refalrts::use(eLine_e_1);

    enum r05_FnResult write_result =
      write_to_stream(
        static_cast<FILE*>(sFileHandle_1->info.file), eLine_b_1, eLine_e_1
      );

    if (write_result != r05_cSuccess)
      return write_result;

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;
    refalrts::splice_stvar(res, sFileHandle_1);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

%%
enum r05_FnResult read_from_stream(
  FILE *input, struct r05_Node *&begin, struct r05_Node *&end
) {
  struct r05_Node *before_begin = refalrts::allocator::free_ptr()->prev;
  struct r05_Node *cur_char_node = 0;

  int cur_char;

  for ( ; ; ) {
    cur_char = getc(input);
    if (EOF == cur_char) {
      if (! refalrts::alloc_number(cur_char_node, 0UL)) {
        return r05_cNoMemory;
      }
      break;
    } else if ('\n' == cur_char) {
      break;
    } else {
      /*
        Пользуемся тем фактом, что в данной реализации размещёные в свободной
        памяти узлы располагаются в последовательных адресах, которые будут
        начинаться с before_begin->next.
      */
      if (! refalrts::alloc_char(cur_char_node, static_cast<char>(cur_char))) {
        return r05_cNoMemory;
      }
    }
  }

  if (cur_char_node != 0) {
    begin = before_begin->next;
    end = cur_char_node;
  } else {
    begin = 0;
    end = 0;
  }

  return r05_cSuccess;
}
%%

$ENTRY ReadLine {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;

    struct r05_Node *str_begin, *str_end;

    enum r05_FnResult fn_result = read_from_stream(stdin, str_begin, str_end);

    if (fn_result != r05_cSuccess)
      return fn_result;

    res = refalrts::splice_evar(res, str_begin, str_end);
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY FReadLine {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sFileHandle_1;
    // s.FileHandle
    if (! refalrts::svar_left(sFileHandle_1, bb_0, be_0))
      break;
    if (sFileHandle_1->tag != r05_cDataFile)
      break;
    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;

    struct r05_Node *str_begin, *str_end;

    enum r05_FnResult fn_result =
      read_from_stream(
        static_cast<FILE*>(sFileHandle_1->info.file), str_begin, str_end
      );

    if (fn_result != r05_cSuccess)
      return fn_result;

    res = refalrts::splice_evar(res, str_begin, str_end);
    res = refalrts::splice_stvar(res, sFileHandle_1);
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}


%%
namespace {

enum r05_FnResult string_from_seq(
  std::vector<char>& string, struct r05_Node *begin, struct r05_Node *end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  for ( ; ; ) {
    unsigned read = refalrts::read_chars(buffer, cBufLen, begin, end);

    if (read == 0) {
      break;
    }

    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);

    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь refalrts::empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (refalrts::empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return r05_cSuccess;
  } else {
    // здесь begin->tag != cDataChar
    return r05_cRecognitionImpossible;
  }
}

} // unnamed namespace
%%


$ENTRY FOpen {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *eFileName_b_1;
    struct r05_Node *eFileName_e_1;

    const char *mode;

    if (refalrts::char_left('r', bb_0, be_0)) {
      mode = "r";
    } else if (refalrts::char_left('w', bb_0, be_0)) {
      mode = "w";
    } else {
      break;
    }

    eFileName_b_1 = bb_0;
    refalrts::use(eFileName_b_1);
    eFileName_e_1 = be_0;
    refalrts::use(eFileName_e_1);

    std::vector<char> filename;

    enum r05_FnResult fname_read =
      string_from_seq(filename, eFileName_b_1, eFileName_e_1);

    if (r05_cSuccess != fname_read)
      return fname_read;

    if (filename.empty())
      return r05_cRecognitionImpossible;

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;

    struct r05_Node *file_ptr = 0;
    if (! refalrts::allocator::alloc_node(file_ptr))
      return r05_cNoMemory;

    file_ptr->tag = r05_cDataFile;

    if (FILE *f = fopen(&filename[0], mode)) {
      file_ptr->info.file = f;
    } else {
      return r05_cRecognitionImpossible;
    }

    res = refalrts::splice_elem(res, file_ptr);
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY FClose {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sFileHandle_1;
    // s.FileHandle
    if (! refalrts::svar_left(sFileHandle_1, bb_0, be_0))
      break;
    if (sFileHandle_1->tag != r05_cDataFile)
      break;
    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    int fclose_res =
      fclose(static_cast<FILE*>(sFileHandle_1->info.file));

    if (EOF == fclose_res) {
      return r05_cRecognitionImpossible;
    } else {
      /* Ничего не делаем */;
    }

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}


%%
/*
  Глобальные переменные, хранящие параметры вызова
  (устанавливаются в refalrts.cpp).
*/

extern char **g_argv;
extern int g_argc;
%%


$ENTRY Arg {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sParamNumber_1;
    // s.ParamNumber
    if (! refalrts::svar_left(sParamNumber_1, bb_0, be_0))
      break;
    if (sParamNumber_1->tag != r05_cDataNumber)
      break;
    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();

    int arg_number = sParamNumber_1->info.number;

    struct r05_Node *res_begin = 0;
    struct r05_Node *res_end = 0;

    if (arg_number < g_argc) {
      if (! refalrts::alloc_string(res_begin, res_end, g_argv[arg_number]))
        return r05_cNoMemory;

      refalrts::splice_evar(arg_begin, res_begin, res_end);
    }

    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY ExistFile {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *eFileName_b_1;
    struct r05_Node *eFileName_e_1;
    // e.FileName
    eFileName_b_1 = bb_0;
    refalrts::use(eFileName_b_1);
    eFileName_e_1 = be_0;
    refalrts::use(eFileName_e_1);

    std::vector<char> fname;

    enum r05_FnResult fname_res =
      string_from_seq(fname, eFileName_b_1, eFileName_e_1);

    if (fname_res != r05_cSuccess)
      return fname_res;

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;

    struct r05_Node *ans = 0;
    if (FILE *f = fopen(&fname[0], "r")) {
      // Файл существует
      fclose(f);

      if (! refalrts::alloc_name(ans, True, "True")) {
        return r05_cNoMemory;
      }
    } else {
      // Файл по-видимому не существует
      if (! refalrts::alloc_name(ans, False, "False")) {
        return r05_cNoMemory;
      }
    }

    res = refalrts::splice_elem(res, ans);
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY GetEnv {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);
    struct r05_Node *eEnvName_b_1;
    struct r05_Node *eEnvName_e_1;
    // e.EnvName
    eEnvName_b_1 = bb_0;
    refalrts::use(eEnvName_b_1);
    eEnvName_e_1 = be_0;
    refalrts::use(eEnvName_e_1);

    std::vector<char> envname;

    enum r05_FnResult envname_res =
      string_from_seq(envname, eEnvName_b_1, eEnvName_e_1);

    if (envname_res != r05_cSuccess)
      return envname_res;

    refalrts::reset_allocator();

    const char *envres = getenv(& envname[0]);

    if (envres != 0) {
      struct r05_Node *env_begin;
      struct r05_Node *env_end;

      if (! refalrts::alloc_string(env_begin, env_end, envres))
        return r05_cNoMemory;

      refalrts::splice_evar(arg_begin, env_begin, env_end);

      //struct r05_Node *char_pos;
      //
      //for (const char *env = envres; *env != '\0'; ++ env) {
      //  if (! refalrts::alloc_char(char_pos, *env))
      //    return r05_cNoMemory;
      //
      //  refalrts::splice_elem(res, char_pos);
      //}
    }

    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY Exit {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sCode_1;
    // s.Code
    if (! refalrts::svar_left(sCode_1, bb_0, be_0))
      break;
    if (sCode_1->tag != r05_cDataNumber)
      break;
    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    refalrts::set_return_code(sCode_1->info.number);

    refalrts::reset_allocator();
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cExit;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY System {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *eCommand_b_1;
    struct r05_Node *eCommand_e_1;
    // e.Command
    eCommand_b_1 = bb_0;
    refalrts::use(eCommand_b_1);
    eCommand_e_1 = be_0;
    refalrts::use(eCommand_e_1);

    std::vector<char> command;

    enum r05_FnResult read_res =
      string_from_seq(command, eCommand_b_1, eCommand_e_1);

    if (read_res != r05_cSuccess)
      return read_res;

    fflush(stdout);
    fflush(stderr);

    system(&command[0]);

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

* Работа с типами символов

$ENTRY IntFromStr {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *eNumber_b_1;
    struct r05_Node *eNumber_e_1;
    // e.NoNumber
    eNumber_b_1 = bb_0;
    refalrts::use(eNumber_b_1);
    eNumber_e_1 = be_0;
    refalrts::use(eNumber_e_1);

    bool start_is_digit =
      ! refalrts::empty_seq(eNumber_b_1, eNumber_e_1)
      && (r05_cDataChar == eNumber_b_1->tag)
      && isdigit(eNumber_b_1->info.char_);

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;

    if (! start_is_digit) {
      struct r05_Node *fail_pos = 0;
      if (! refalrts::alloc_name(fail_pos, Fails, "Fails"))
        return r05_cNoMemory;

      res = refalrts::splice_evar(res, eNumber_b_1, eNumber_e_1);
      res = refalrts::splice_elem(res, fail_pos);
    } else {
      r05_Number acc = 0;

      for ( ; ; ) {
        if (refalrts::empty_seq(eNumber_b_1, eNumber_e_1)) {
          break;
        } else if (eNumber_b_1->tag != r05_cDataChar) {
          break;
        } else if (! isdigit(eNumber_b_1->info.char_)) {
          break;
        } else {
          (acc *= 10) += eNumber_b_1->info.char_ - '0';
        }

        refalrts::move_left(eNumber_b_1, eNumber_e_1);
      }

      struct r05_Node *success_pos = 0;
      struct r05_Node *number_pos = 0;

      if (! refalrts::alloc_name(success_pos, Success, "Success"))
        return r05_cNoMemory;

      if (! refalrts::alloc_number(number_pos, acc))
        return r05_cNoMemory;

      res = refalrts::splice_evar(res, eNumber_b_1, eNumber_e_1);
      res = refalrts::splice_elem(res, number_pos);
      res = refalrts::splice_elem(res, success_pos);
    }

    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY StrFromInt {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sNumber_1;
    // s.Number
    if (! refalrts::svar_left(sNumber_1, bb_0, be_0))
      break;
    if (sNumber_1->tag != r05_cDataNumber)
      break;
    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;

    struct r05_Node *char_pos = 0;
    if (r05_Number num = sNumber_1->info.number) {
      // Длина десятичного числа = 0,3 * длина двоичного числа,
      // т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
      enum { cMaxNumberLen = 8 * sizeof(r05_Number) * 3 / 10 + 2 };

      char buffer[cMaxNumberLen + 1] = { 0 };
      char *lim_digit = buffer + cMaxNumberLen;
      char *cur_digit = lim_digit;

      while (num != 0) {
        -- cur_digit;
        *cur_digit = static_cast<char>((num % 10) + '0');
        num /= 10;
      }

      struct r05_Node *num_begin;
      struct r05_Node *num_end;
      bool allocated = refalrts::alloc_chars(
        num_begin, num_end, cur_digit, unsigned(lim_digit - cur_digit)
      );

      if (! allocated)
        return r05_cNoMemory;

      refalrts::splice_evar(res, num_begin, num_end);
    } else {
      if (! refalrts::alloc_char(char_pos, '0'))
        return r05_cNoMemory;

      refalrts::splice_elem(res, char_pos);
    }

    refalrts::splice_to_freelist(arg_begin, arg_end);

    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY Chr {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sCode_1;
    // s.Code
    if (! refalrts::svar_left(sCode_1, bb_0, be_0))
      break;
    if (sCode_1->tag != r05_cDataNumber)
      break;
    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    char result = static_cast<char>(sCode_1->info.number);

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;
    struct r05_Node *n0 = 0;
    if (! refalrts::alloc_char(n0, result))
      return r05_cNoMemory;
    res = refalrts::splice_elem(res, n0);
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY Ord {
%%
  do {
    struct r05_Node *bb_0 = arg_begin;
    struct r05_Node *be_0 = arg_end;
    refalrts::move_left(bb_0, be_0);
    refalrts::move_left(bb_0, be_0);
    refalrts::move_right(bb_0, be_0);

    struct r05_Node *sChar_1;
    // s.Char
    if (! refalrts::svar_left(sChar_1, bb_0, be_0))
      break;
    if (sChar_1->tag != r05_cDataChar)
      break;
    if (! refalrts::empty_seq(bb_0, be_0))
      break;

    r05_Number result = static_cast<unsigned char>(sChar_1->info.char_);

    refalrts::reset_allocator();
    struct r05_Node *res = arg_begin;
    struct r05_Node *n0 = 0;
    if (! refalrts::alloc_number(n0, result))
      return r05_cNoMemory;
    res = refalrts::splice_elem(res, n0);
    refalrts::use(res);
    refalrts::splice_to_freelist(arg_begin, arg_end);
    return r05_cSuccess;
  } while (0);

  return r05_cRecognitionImpossible;
%%
}

$ENTRY Compare {
%%
  struct r05_Node *func_name = arg_begin->next;

  struct r05_Node *sX = func_name->next;
  if (sX->tag != r05_cDataNumber) {
    return r05_cRecognitionImpossible;
  }

  struct r05_Node *sY = sX->next;
  if (sY->tag != r05_cDataNumber) {
    return r05_cRecognitionImpossible;
  }

  if (sY->next != arg_end) {
    return r05_cRecognitionImpossible;
  }

  sX->info.char_ =
    sX->info.number < sY->info.number ? '-' :
    sX->info.number > sY->info.number ? '+' :
    '0';
  sX->tag = r05_cDataChar;

  refalrts::splice_to_freelist(arg_begin, func_name);
  refalrts::splice_to_freelist(sY, arg_end);

  return r05_cSuccess;
%%
}
