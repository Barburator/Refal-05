%%
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
%%


/**
   1. <Mu s.Func e.Arg> == <s.Func e.Arg>
*/
$ENTRY Mu {
  s.Func e.Arg = <s.Func e.Arg>;
}


/**
   2. <Add s.NUMBER s.NUMBER> == s.NUMBER
*/
%%
#define ARITHM_OP(op, check) \
  struct r05_node *func_name, *sX, *sY; \
  func_name = arg_begin->next; \
  \
  sX = func_name->next; \
  if (sX->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  sY = sX->next; \
  if (sY->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  if (sY->next != arg_end) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  check \
  \
  sX->info.number = sX->info.number op sY->info.number; \
  \
  r05_splice_to_freelist(arg_begin, func_name); \
  r05_splice_to_freelist(sY, arg_end); \
  \
  return R05_SUCCESS;

#define NO_CHECK
#define CHECK_ZERODIV \
  if (sY->info.number == 0) { \
    r05_builtin_error("divide by zero"); \
  }
%%


$ENTRY Add {
%%
  ARITHM_OP(+, NO_CHECK)
%%
}


/**
   3. <Ars s.ArgNo> == e.Argument

      s.ArgNo ::= s.NUMBER
      e.Argument ::= s.CHAR*
*/
$ENTRY Arg {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *parg_no = callable->next;
  int arg_no;

  if (
    parg_no == arg_end
    || R05_DATATAG_NUMBER != parg_no->tag
    || parg_no->next != arg_end
  ) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  arg_no = (int) parg_no->info.number;

  r05_reset_allocator();
  r05_alloc_string(r05_arg(arg_no));
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 4 Br
$EENUM Br;


/**
   5. <Card> == s.CHAR* 0?
*/
%%
static void read_from_stream(FILE *input);
%%

$ENTRY Card {
%%
  struct r05_node *callee = arg_begin->next;

  if (callee->next != arg_end) {
    r05_recognition_impossible();
  }

  r05_reset_allocator();
  read_from_stream(stdin);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


%%
static void read_from_stream(FILE *input) {
  int cur_char;

  while (cur_char = fgetc(input), cur_char != EOF && cur_char != '\n') {
    r05_alloc_char((char) cur_char);
  }

  if (cur_char == EOF) {
    r05_alloc_number(0);
  }
}
%%


/**
   6. <Chr e.Expr> == e.Expr’

   В e.Expr’ все числа заменены на литеры с соответствующими кодами
*/
$ENTRY Chr {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_NUMBER) {
      p->tag = R05_DATATAG_CHAR;
      p->info.char_ = (unsigned char) p->info.number;
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


* 7 Cp
$EENUM Cp;

* 8 Dg
$EENUM Dg;

* 9 Dgall
$EENUM Dgall;


/**
  10. <Div s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Div {
%%
  ARITHM_OP(/, CHECK_ZERODIV);
%%
}


/**
  11. <Divmod s.NUMBER s.NUMBER> == s.Div s.Mod
      s.Div, s.Mod ::= s.NUMBER
*/
$ENTRY Divmod {
  s.X s.Y = <Div s.X s.Y> <Mod s.X s.Y>;
}


/**
  12. <Explode s.FUNCTION> == s.CHAR+
*/
$ENTRY Explode {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *ident = callable->next;

  if (
     ident == arg_end
     || R05_DATATAG_FUNCTION != ident->tag
     || ident->next != arg_end
  ) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  r05_reset_allocator();
  r05_alloc_string(ident->info.function->name);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 13 First
$EENUM First;


/**
  14. <Get s.FileNo> == s.Char* 0?
      s.FileNo ::= s.NUMBER
*/
%%
FILE *open_numbered(unsigned int no, const char mode);
%%

$ENTRY Get {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pfile_no = callable->next;
  FILE *stream;

  if (
    pfile_no == arg_end
    || R05_DATATAG_NUMBER != pfile_no->tag
    || pfile_no->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  stream = open_numbered((unsigned int) pfile_no->info.number, 'r');

  r05_reset_allocator();
  read_from_stream(stream);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


%%
enum { FILE_LIMIT = 40 };

static FILE *s_streams[FILE_LIMIT] = { NULL };

enum { UINT_DIGITS = (sizeof(unsigned int) * 8 + 2) / 3 };

FILE *open_numbered(unsigned int file_no, const char mode) {
  char mode_str[2] = "*";

  /*
    Ложное предупреждение BCC 5.5:
    компилятор не допускает инициализацию структур и массивов переменными.
  */
  mode_str[0] = mode;
  file_no %= FILE_LIMIT;
  if (file_no == 0 && mode == 'r') {
    return stdin;
  } else if (file_no == 0 && mode == 'w') {
    return stderr;
  }

  if (s_streams[file_no] == NULL) {
    static const char filename_format[] = "REFAL%u.DAT";
    char filename[sizeof(filename_format) + UINT_DIGITS];

    sprintf(filename, filename_format, file_no);
    s_streams[file_no] = fopen(filename, mode_str);

    if (s_streams[file_no] == NULL) {
      static const char error_format[] = "Can't open REFAL%u.DAT as \"%c\"";
      char error[sizeof(error_format) + UINT_DIGITS];

      sprintf(error, error_format, file_no, mode);
      perror(error_format);
      r05_builtin_error("Can't open file");
    }
  }

  return s_streams[file_no];
}
%%


* 15 Implode
$EENUM Implode;

* 16 Last
$EENUM Last;

* 17 Lenw
$EENUM Lenw;


/**
  18. <Lower e.Expr> == e.Expr’

  В e.Expr’ все буквы приведены к нижнему регистру
*/
$ENTRY Lower {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_CHAR) {
      p->info.char_ = (char) tolower(p->info.char_);
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


/**
  19. <Mod s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Mod {
%%
  ARITHM_OP(%, CHECK_ZERODIV);
%%
}


/**
  18. <Mul s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Mul {
%%
  ARITHM_OP(*, NO_CHECK)
%%
}


/**
  21. <Numb s.Digit* e.Skipped> == s.NUMBER
      s.Digit ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'

      Если аргумент не начинается с последовательности цифр,
      функция возвращает 0.
*/
$ENTRY Numb {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p;
  r05_number result = 0;

  for (
    p = callee->next;
    p != arg_end && R05_DATATAG_CHAR == p->tag && isdigit(p->info.char_);
    p = p->next
  ) {
    result = 10 * result + (p->info.char_ - '0');
  }

  arg_begin->tag = R05_DATATAG_NUMBER;
  arg_begin->info.number = result;

  r05_splice_to_freelist(callee, arg_end);

  return R05_SUCCESS;
%%
}


/**
  22. <Open s.Mode s.FileNo e.FileName> == []
      s.Mode ::=
          'r' | 'w' | 'a'
        |  r  |  w  |  a
        |  rb |  wb |  ab
*/
$EENUM r, w, a, rb, wb, ab;

%%
static void ensure_close_stream(unsigned int file_no);
%%

$ENTRY Open {
%%
  struct r05_node *eFileName_b, *eFileName_e, *sMode, *sFileNo;
  unsigned int file_no;
  char mode_str[2] = { '.', '\0' };
  const char *mode = mode_str;
  char filename[FILENAME_MAX + 1] = { '\0' };
  size_t filename_len;

  r05_prepare_argument(&eFileName_b, &eFileName_e, arg_begin, arg_end);

  if (
    ! r05_svar_left(&sMode, &eFileName_b, &eFileName_e)
    || (R05_DATATAG_CHAR != sMode->tag && R05_DATATAG_FUNCTION != sMode->tag)
    || ! r05_svar_left(&sFileNo, &eFileName_b, &eFileName_e)
    || R05_DATATAG_NUMBER != sFileNo->tag
  ) {
    r05_recognition_impossible();
#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  filename_len =
    r05_read_chars(filename, FILENAME_MAX, &eFileName_b, &eFileName_e);

  if (filename_len == 0) {
    r05_recognition_impossible();
#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  filename[filename_len] = '\0';

  if (R05_DATATAG_CHAR == sMode->tag) {
    char mode = sMode->info.char_;
    if (mode != 'r' && mode != 'w' && mode != 'a') {
      r05_builtin_error("Bad file mode, expected 'r', 'w' or 'a'");
#ifndef R05_NORETURN_DEFINED
      return R05_RECOGNITION_IMPOSSIBLE;
#endif
    }
    mode_str[0] = mode;
  } else {
    mode = sMode->info.function->name;
  }

  if (! r05_empty_seq(eFileName_b, eFileName_e)) {
    static const char error_format[] =
      "Very long file name, maximum available is %u";
    char error[sizeof(error_format) + UINT_DIGITS];

    sprintf(error, error_format, (unsigned int) FILENAME_MAX);
    r05_builtin_error(error);
  }

  file_no = sFileNo->info.number % FILE_LIMIT;

  ensure_close_stream(file_no);

  s_streams[file_no] = fopen(filename, mode);
  if (s_streams[file_no] == NULL) {
    char mode_buffer[100] = { '\0' };
    static const char error_format[] = "Can't open %s for \"%s\"";
    char error[sizeof(error_format) + FILENAME_MAX + sizeof(mode_buffer)];

    strncpy(mode_buffer, mode, sizeof(mode_buffer) - 1);
    sprintf(error, error_format, filename, mode_buffer);
    perror(error);
    r05_builtin_error(error);
#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}

%%
static void ensure_close_stream(unsigned int file_no) {
  if (s_streams[file_no] != NULL && fclose(s_streams[file_no]) == EOF) {
    perror("fclose()");
    r05_builtin_error("Can't close stream");
  }

  s_streams[file_no] = NULL;
}
%%


/**
  23. <Ord e.Expr> == e.Expr’

  В e.Expr’ все литеры заменены на их коды ASCII
*/
$ENTRY Ord {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_CHAR) {
      p->tag = R05_DATATAG_NUMBER;
      p->info.number = (unsigned char) p->info.char_;
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


/**
  24. <Print e.Expr> == e.Expr
*/
%%
enum output_func_type {
  PRINT, PROUT, PUT, PUTOUT,
};

static enum r05_fnresult output_func(
  struct r05_node *arg_begin, struct r05_node *arg_end,
  enum output_func_type type
);
%%

$ENTRY Print {
%%
  return output_func(arg_begin, arg_end, PRINT);
%%
}

%%
static enum r05_fnresult output_func(
  struct r05_node *arg_begin, struct r05_node *arg_end,
  enum output_func_type type
) {
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p, *before_expr;
  FILE *output;

  if (type == PRINT || type == PROUT) {
    before_expr = callee;
    output = stdout;
  } else if (type == PUT || type == PUTOUT) {
    struct r05_node *pfile_no = callee->next;

    if (R05_DATATAG_NUMBER != pfile_no->tag) {
      r05_recognition_impossible();
#ifndef R05_NORETURN_DEFINED
      return R05_RECOGNITION_IMPOSSIBLE;
#endif
    }

    before_expr = pfile_no;
    output = open_numbered((unsigned int) pfile_no->info.number, 'w');
  } else {
    r05_switch_default_violation(type);
#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

#define CHECK_PRINTF(printf_call) \
  ((printf_call) >= 0 ? (void) 0 \
  : r05_builtin_error("Error in call " #printf_call))

  for (p = before_expr->next; p != arg_end; p = p->next) {
    switch (p->tag) {
      case R05_DATATAG_CHAR:
        CHECK_PRINTF(fprintf(output, "%c", p->info.char_));
        break;

      case R05_DATATAG_FUNCTION:
        CHECK_PRINTF(fprintf(output, "%s ", p->info.function->name));
        break;

      case R05_DATATAG_NUMBER:
        CHECK_PRINTF(fprintf(output, "%lu ", (long unsigned int) p->info.number));
        break;

      case R05_DATATAG_OPEN_BRACKET:
        CHECK_PRINTF(fprintf(output, "("));
        break;

      case R05_DATATAG_CLOSE_BRACKET:
        CHECK_PRINTF(fprintf(output, ")"));
        break;

      default:
        r05_switch_default_violation(p->tag);
    }
  }

  CHECK_PRINTF(fprintf(output, "\n"));

#undef CHECK_PRINTF

  if (type == PRINT || type == PUT) {
    r05_splice_to_freelist(arg_begin, before_expr);
    r05_splice_to_freelist(arg_end, arg_end);
  } else if (type == PROUT || type == PUTOUT) {
    r05_splice_to_freelist(arg_begin, arg_end);
  } else {
    r05_switch_default_violation(type);
  }

  return R05_SUCCESS;
}
%%


/**
  25. <Prout e.Expr> == []
*/
$ENTRY Prout {
%%
  return output_func(arg_begin, arg_end, PROUT);
%%
}


/**
  26. <Put s.FileNo e.Expr> == e.Expr
*/
$ENTRY Put {
%%
  return output_func(arg_begin, arg_end, PUT);
%%
}


/**
  27. <Putout s.FileNo e.Expr> == []
*/
$ENTRY Putout {
%%
  return output_func(arg_begin, arg_end, PUTOUT);
%%
}


* 28 Rp
$EENUM Rp;

* 29 Step
$EENUM Step;


/**
  30. <Sub s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Sub {
%%
  ARITHM_OP(-, NO_CHECK)
%%
}


/**
  31. <Symb s.NUMBER> == s.CHAR+
*/
$ENTRY Symb {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pnumber = callable->next;
  r05_number number;

  /*
    Длина десятичного числа = 0,3 * длина двоичного числа,
    т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
  */
  enum { cMaxNumberLen = 8 * sizeof(r05_number) * 3 / 10 + 2 };

  char buffer[cMaxNumberLen + 1] = { '\0' };
  char *cur_digit = buffer + cMaxNumberLen;

  if (
    pnumber == arg_end
    || R05_DATATAG_NUMBER != pnumber->tag
    || pnumber->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  number = pnumber->info.number;

  r05_reset_allocator();

  if (number > 0) {
    while (number != 0) {
      -- cur_digit;
      *cur_digit = (char) ((number % 10) + '0');
      number /= 10;
    }

    r05_alloc_string(cur_digit);
  } else {
    r05_alloc_string("0");
  }

  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 32 Time
$EENUM Time;


/**
  33. <Type e.Expr> == s.Type s.SubType e.Expr
      Type of first term of e.Expr

      s.Type s.SubType ::=
          'Lu' — uppercase latin letter
        | 'Ll' — lowercase latin letter
        | 'D0' — decimal digit
        | 'Wi' — identifier (function)
        | 'N0' — number
        | 'Pu' — isprint() && isupper()
        | 'Pl' — isprint() && ! isupper()
        | 'Ou' — other && isupper()
        | 'Ol' — other && ! isupper()
        | 'B0' — brackets
        | '*0' — empty expression
*/
$ENTRY Type {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *first_term = callee->next;
  char type, subtype;

  if (first_term == arg_end) {
    type = '*';
    subtype = '0';
  } else if (R05_DATATAG_CHAR == first_term->tag) {
    char ch = first_term->info.char_;

    if (isupper(ch)) {
      subtype = 'u';
    } else {
      subtype = 'l';
    }
    if (isalpha(ch)) {
      type = 'L';
    } else if (isdigit(ch)) {
      type = 'D';
      subtype = '0';
    } else if (isprint(ch)) {
      type = 'P';
    } else {
      type = 'O';
    }
  } else if (R05_DATATAG_FUNCTION == first_term->tag) {
    type = 'W';
    subtype = 'i';
  } else if (R05_DATATAG_NUMBER == first_term->tag) {
    type = 'N';
    subtype = '0';
  } else if (R05_DATATAG_OPEN_BRACKET == first_term->tag) {
    type = 'B';
    subtype = '0';
  } else {
    r05_switch_default_violation(first_term->tag);
#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  arg_begin->tag = R05_DATATAG_CHAR;
  arg_begin->info.char_ = type;
  callee->tag = R05_DATATAG_CHAR;
  callee->info.char_ = subtype;

  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


/**
  34. <Upper e.Expr> == e.Expr’

  В e.Expr’ все буквы приведены к верхнему регистру
*/
$ENTRY Upper {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_CHAR) {
      p->info.char_ = (char) toupper(p->info.char_);
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


* 35 Sysfun
$EENUM Sysfun;

* 45 Freeze
$EENUM Freeze;

* 46 Freezer
$EENUM Freezer;

* 47 Dn
$EENUM Dn;

* 48 Up
$EENUM Up;

* 49 Ev-met
$EENUM Ev-met;

* 50 Residue
$EENUM Residue;


/**
  51. <GetEnv e.EnvName> == e.EnvValue
      e.EnvName, e.EnvValue ::= s.CHAR*
*/
$ENTRY GetEnv {
%%
  struct r05_node *eEnvName_b, *eEnvName_e;
  char env_name[2001];
  size_t env_name_len;
  const char *env_value;

  r05_prepare_argument(&eEnvName_b, &eEnvName_e, arg_begin, arg_end);
  env_name_len =
    r05_read_chars(env_name, sizeof(env_name) - 1, &eEnvName_b, &eEnvName_e);

  if (! r05_empty_seq(eEnvName_b, eEnvName_e)) {
    if (R05_DATATAG_CHAR == eEnvName_b->tag) {
      r05_builtin_error("very long environment variable name");
    } else {
      r05_recognition_impossible();
    }

#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  env_name[env_name_len] = '\0';
  env_value = getenv(env_name);
  if (! env_value) {
    env_value = "";
  }

  r05_reset_allocator();
  r05_alloc_string(env_value);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


/**
  52. <System e.Command> == s.RetCode
      s.RetCode ::= s.NUMBER
*/
$ENTRY System {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *eCommand_b, *eCommand_e;
  char command[2001];
  size_t command_len;
  int retcode;

  r05_prepare_argument(&eCommand_b, &eCommand_e, arg_begin, arg_end);
  command_len =
    r05_read_chars(command, sizeof(command) - 1, &eCommand_b, &eCommand_e);

  if (! r05_empty_seq(eCommand_b, eCommand_e)) {
    if (R05_DATATAG_CHAR == eCommand_b->tag) {
      r05_builtin_error("very long command line");
    } else {
      r05_recognition_impossible();
    }

#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  command[command_len] = '\0';
  fflush(NULL);
  retcode = system(command);

#if defined(WIFEXITED) && defined(WEXITSTATUS)
  if (WIFEXITED(retcode)) {
    retcode = WEXITSTATUS(retcode);
  } else {
    retcode = -1;
  }
#endif  /* defined(WIFEXITED) && defined(WEXITSTATUS) */

  arg_begin->tag = R05_DATATAG_NUMBER;
  arg_begin->info.number = (r05_number) retcode;
  r05_splice_to_freelist(callee, arg_end);

  return R05_SUCCESS;
%%
}


/**
  53. <Exit s.RetCode>
*/
$ENTRY Exit {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pretcode = callable->next;
  int retcode;

  if (
    pretcode == arg_end
    || R05_DATATAG_NUMBER != pretcode->tag
    || pretcode->next != arg_end
  ) {
    r05_recognition_impossible();
#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  retcode = (int) pretcode->info.number;
  r05_exit(retcode);

#ifndef R05_NORETURN_DEFINED
  return R05_SUCCESS;
#endif
%%
}


/**
  54. <Close s.FileNo> == []
*/
$ENTRY Close {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pfile_no = callable->next;
  unsigned int file_no;

  if (
    pfile_no == arg_end
    || R05_DATATAG_NUMBER != pfile_no->tag
    || pfile_no->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  file_no = (unsigned int) pfile_no->info.number % FILE_LIMIT;
  ensure_close_stream(file_no);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


/**
  55. <ExistFile e.FileName>
        == True
        == False
      e.FileName ::= s.CHAR+
*/
$EENUM True, False;

$ENTRY ExistFile {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *eFileName_b, *eFileName_e;
  char filename[FILENAME_MAX + 1];
  size_t filename_len;
  FILE *file;

  r05_prepare_argument(&eFileName_b, &eFileName_e, arg_begin, arg_end);
  filename_len =
    r05_read_chars(filename, sizeof(filename) - 1, &eFileName_b, &eFileName_e);

  if (! r05_empty_seq(eFileName_b, eFileName_e)) {
    if (R05_DATATAG_CHAR == eFileName_b->tag) {
      r05_builtin_error("very long filename");
    } else {
      r05_recognition_impossible();
    }

#ifndef R05_NORETURN_DEFINED
    return R05_RECOGNITION_IMPOSSIBLE;
#endif
  }

  filename[filename_len] = '\0';
  file = fopen(filename, "r");

  arg_begin->tag = R05_DATATAG_FUNCTION;
  if (file != NULL) {
    arg_begin->info.function = &r05f_True;
    if (fclose(file) == EOF) {
      perror("fclose error");
      r05_builtin_error("fclose error");
    }
  } else {
    arg_begin->info.function = &r05f_False;
  }

  r05_splice_to_freelist(callee, arg_end);

  return R05_SUCCESS;
%%
}


* 56 GetCurrentDirectory
$EENUM GetCurrentDirectory;

* 57 RemoveFile
$EENUM RemoveFile;

* 58 Implode_Ext
$EENUM Implode_Ext;

* 59 Explode_Ext
$EENUM Explode_Ext;

* 60 TimeElapsed
$EENUM TimeElapsed;


/**
  61. <Compare s.X s.Y>
        == '-' | '0' | '+'
      s.X, s.Y ::= s.NUMBER

  Функция возвращает знак разности между s.X и s.Y
*/
$ENTRY Compare {
%%
  struct r05_node *func_name, *sX, *sY;

  func_name = arg_begin->next;
  sX = func_name->next;
  if (sX->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  sY = sX->next;
  if (sY->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  if (sY->next != arg_end) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  if (sX->info.number < sY->info.number) {
    sX->info.char_ = '-';
  } else if (sX->info.number > sY->info.number) {
    sX->info.char_ = '+';
  } else {
    sX->info.char_ = '0';
  }
  sX->tag = R05_DATATAG_CHAR;

  r05_splice_to_freelist(arg_begin, func_name);
  r05_splice_to_freelist(sY, arg_end);

  return R05_SUCCESS;
%%
}


* 62 DeSysfun
$EENUM DeSysfun;

* 63 XMLParse
$EENUM XMLParse;

* 64 Random
$EENUM Random;

* 65 RandomDigit
$EENUM RandomDigit;

* 66 Write
$EENUM Write;


/**
  67. <ListOfBuiltin> == (s.No s.Name s.Type)*

      s.No ::= s.NUMBER
      s.Name ::= s.FUNCTION
      s.Type ::= special | regular
*/
$EENUM special, regular;

$ENTRY ListOfBuiltin {
  = (1 Mu special)
    (2 Add regular)
    (3 Arg regular)
    (4 Br regular)
    (5 Card regular)
    (6 Chr regular)
    (7 Cp regular)
    (8 Dg regular)
    (9 Dgall regular)
    (10 Div regular)
    (11 Divmod regular)
    (12 Explode regular)
    (13 First regular)
    (14 Get regular)
    (15 Implode regular)
    (16 Last regular)
    (17 Lenw regular)
    (18 Lower regular)
    (19 Mod regular)
    (20 Mul regular)
    (21 Numb regular)
    (22 Open regular)
    (23 Ord regular)
    (24 Print regular)
    (25 Prout regular)
    (26 Put regular)
    (27 Putout regular)
    (28 Rp regular)
    (29 Step regular)
    (30 Sub regular)
    (31 Symb regular)
    (32 Time regular)
    (33 Type regular)
    (34 Upper regular)
    (35 Sysfun regular)
    /* (42 "Imp$$" regular) */
    /* (43 "Stop$$" regular) */
    /* (44 "" regular) */
    (45 Freeze regular)
    (46 Freezer regular)
    (47 Dn regular)
    (48 Up special)
    (49 Ev-met special)
    (50 Residue special)
    (51 GetEnv regular)
    (52 System regular)
    (53 Exit regular)
    (54 Close regular)
    (55 ExistFile regular)
    (56 GetCurrentDirectory regular)
    (57 RemoveFile regular)
    (58 Implode_Ext regular)
    (59 Explode_Ext regular)
    (60 TimeElapsed regular)
    (61 Compare regular)
    (62 DeSysfun regular)
    (63 XMLParse regular)
    (64 Random regular)
    (65 RandomDigit regular)
    (66 Write regular)
    (67 ListOfBuiltin regular)
    (68 SizeOf regular)
    (69 GetPID regular)
    (70 int4fab_1 regular)
    (71 GetPPID regular);
}


* 68 SizeOf
$EENUM SizeOf;

* 69 GetPID
$EENUM GetPID;

* 70 int4fab_1
$EENUM int4fab_1;

* 71 GetPPID
$EENUM GetPPID;
