%%
#include <stdio.h>
#include <string.h>
#include <vector>
#include <ctype.h>
#include <stdlib.h>
%%


/**
   1. <Mu s.Func e.Arg> == <s.Func e.Arg>
*/
$ENTRY Mu {
  s.Func e.Arg = <s.Func e.Arg>;
}


/**
   2. <Add s.NUMBER s.NUMBER> == s.NUMBER
*/
%%
#define ARITHM_OP(op, check) \
  struct r05_node *func_name, *sX, *sY; \
  func_name = arg_begin->next; \
  \
  sX = func_name->next; \
  if (sX->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  sY = sX->next; \
  if (sY->tag != R05_DATATAG_NUMBER) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  if (sY->next != arg_end) { \
    return R05_RECOGNITION_IMPOSSIBLE; \
  } \
  \
  check \
  \
  sX->info.number = sX->info.number op sY->info.number; \
  \
  r05_splice_to_freelist(arg_begin, func_name); \
  r05_splice_to_freelist(sY, arg_end); \
  \
  return R05_SUCCESS;

#define NO_CHECK
#define CHECK_ZERODIV \
  if (sY->info.number == 0) { \
    r05_builtin_error("divide by zero"); \
  }
%%


$ENTRY Add {
%%
  ARITHM_OP(+, NO_CHECK)
%%
}


/**
   3. <Ars s.ArgNo> == e.Argument

      s.ArgNo ::= s.NUMBER
      e.Argument ::= s.CHAR*
*/
$ENTRY Arg {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *parg_no = callable->next;
  int arg_no;

  if (
    parg_no == arg_end
    || R05_DATATAG_NUMBER != parg_no->tag
    || parg_no->next != arg_end
  ) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  arg_no = (int) parg_no->info.number;

  r05_reset_allocator();
  r05_alloc_string(r05_arg(arg_no));
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 4 Br
$EENUM Br;


/**
   5. <Card> == s.CHAR* 0?
*/
%%
static void read_from_stream(FILE *input);
%%

$ENTRY Card {
%%
  struct r05_node *callee = arg_begin->next;

  if (callee->next != arg_end) {
    r05_recognition_impossible();
  }

  r05_reset_allocator();
  read_from_stream(stdin);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


%%
static void read_from_stream(FILE *input) {
  int cur_char;

  while (cur_char = fgetc(input), cur_char != EOF && cur_char != '\n') {
    r05_alloc_char(cur_char);
  }

  if (cur_char == EOF) {
    r05_alloc_number(0);
  }
}
%%


/**
   6. <Chr e.Expr> == e.Expr’

   В e.Expr’ все числа заменены на литеры с соответствующими кодами
*/
$ENTRY Chr {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_NUMBER) {
      p->tag = R05_DATATAG_CHAR;
      p->info.char_ = (unsigned char) p->info.number;
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


* 7 Cp
$EENUM Cp;

* 8 Dg
$EENUM Dg;

* 9 Dgall
$EENUM Dgall;


/**
  10. <Div s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Div {
%%
  ARITHM_OP(/, CHECK_ZERODIV);
%%
}


/**
  11. <Divmod s.NUMBER s.NUMBER> == s.Div s.Mod
      s.Div, s.Mod ::= s.NUMBER
*/
$ENTRY Divmod {
  s.X s.Y = <Div s.X s.Y> <Mod s.X s.Y>;
}


/**
  12. <Explode s.FUNCTION> == s.CHAR+
*/
$ENTRY Explode {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *ident = callable->next;

  if (
     ident == arg_end
     || R05_DATATAG_FUNCTION != ident->tag
     || ident->next != arg_end
  ) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  r05_reset_allocator();
  r05_alloc_string(ident->info.function.name);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


* 13 First
$EENUM First;


/**
  14. <Get s.FileNo> == s.Char* 0?
      s.FileNo ::= s.NUMBER
*/
%%
FILE *open_numbered(unsigned int no, const char *mode);
%%

$ENTRY Get {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pfile_no = callable->next;
  FILE *stream;

  if (
    pfile_no == arg_end
    || R05_DATATAG_NUMBER != pfile_no->tag
    || pfile_no->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  stream = open_numbered((unsigned int) pfile_no->info.number, "r");

  r05_reset_allocator();
  read_from_stream(stream);
  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


%%
enum { FILE_LIMIT = 40 };

static FILE *s_streams[FILE_LIMIT] = { NULL };

enum { UINT_DIGITS = (sizeof(unsigned int) * 8 + 2) / 3 };

FILE *open_numbered(unsigned int file_no, const char *mode) {
  file_no %= FILE_LIMIT;
  if (s_streams[file_no] == NULL) {
    static const char filename_format[] = "REFAL%u.DAT";
    char filename[sizeof(filename_format) + UINT_DIGITS];

    sprintf(filename, filename_format, file_no);
    s_streams[file_no] = fopen(filename, mode);

    if (s_streams[file_no] == NULL) {
      static const char error_format[] = "Can't open REFAL%u.DAT";
      char error[sizeof(error_format) + UINT_DIGITS];

      sprintf(error, error_format, file_no);
      perror(error_format);
      r05_builtin_error("Can't open file");
    }
  }

  return s_streams[file_no];
}
%%


* 15 Implode
$EENUM Implode;

* 16 Last
$EENUM Last;

* 17 Lenw
$EENUM Lenw;

* 18 Lower
$EENUM Lower;


/**
  19. <Mod s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Mod {
%%
  ARITHM_OP(%, CHECK_ZERODIV);
%%
}


/**
  18. <Mul s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Mul {
%%
  ARITHM_OP(*, NO_CHECK)
%%
}


/**
  21. <Numb s.NUMBER> == s.CHAR+
*/
$ENTRY Numb {
%%
  struct r05_node *callable = arg_begin->next;
  struct r05_node *pnumber = callable->next;
  r05_number number;

  /*
    Длина десятичного числа = 0,3 * длина двоичного числа,
    т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
  */
  enum { cMaxNumberLen = 8 * sizeof(r05_number) * 3 / 10 + 2 };

  char buffer[cMaxNumberLen + 1] = { '\0' };
  char *cur_digit = buffer + cMaxNumberLen;

  if (
    pnumber == arg_end
    || R05_DATATAG_NUMBER != pnumber->tag
    || pnumber->next != arg_end
  ) {
    r05_recognition_impossible();
  }

  number = pnumber->info.number;

  r05_reset_allocator();

  if (number > 0) {
    while (number != 0) {
      -- cur_digit;
      *cur_digit = (number % 10) + '0';
      number /= 10;
    }

    r05_alloc_string(cur_digit);
  } else {
    r05_alloc_string("0");
  }

  r05_splice_from_freelist(arg_begin);
  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


/**
  22. <Open s.Mode s.FileNo e.FileName> == []
      s.Mode ::=
          'r' | 'w' | 'a'
        |  r  |  w  |  a
        |  rb |  wb |  ab
*/
$EENUM r, w, a, rb, wb, ab;

$ENTRY Open {
%%
  struct r05_node *eFileName_b, *eFileName_e, *sMode, *sFileNo;
  unsigned int file_no;
  char mode_str[2] = { '.', '\0' };
  const char *mode = mode_str;
  char filename[FILENAME_MAX + 1] = { '\0' };
  size_t filename_len;

  r05_prepare_argument(&eFileName_b, &eFileName_e, arg_begin, arg_end);

  if (
    ! r05_svar_left(&sMode, &eFileName_b, &eFileName_e)
    || (R05_DATATAG_CHAR != sMode->tag && R05_DATATAG_FUNCTION != sMode->tag)
    || ! r05_svar_left(&sFileNo, &eFileName_b, &eFileName_e)
    || R05_DATATAG_NUMBER != sFileNo->tag
  ) {
    r05_recognition_impossible();
    return R05_RECOGNITION_IMPOSSIBLE;  /* suppress warning */
  }

  filename_len =
    r05_read_chars(filename, FILENAME_MAX, &eFileName_b, &eFileName_e);

  if (filename_len == 0) {
    r05_recognition_impossible();
    return R05_RECOGNITION_IMPOSSIBLE;  /* suppress warning */
  }

  filename[filename_len] = '\0';

  if (R05_DATATAG_CHAR == sMode->tag) {
    char mode = sMode->info.char_;
    if (mode != 'r' && mode != 'w' && mode != 'a') {
      r05_builtin_error("Bad file mode, expected 'r', 'w' or 'a'");
      return R05_RECOGNITION_IMPOSSIBLE;        /* suppress warning */
    }
    mode_str[0] = mode;
  } else {
    mode = sMode->info.function.name;
  }

  if (! r05_empty_seq(eFileName_b, eFileName_e)) {
    static const char error_format[] =
      "Very long file name, maximum available is %u";
    char error[sizeof(error_format) + UINT_DIGITS];

    sprintf(error, error_format, (unsigned int) FILENAME_MAX);
    r05_builtin_error(error);
  }

  file_no = sFileNo->info.number % FILE_LIMIT;

  if (s_streams[file_no] != NULL && fclose(s_streams[file_no]) == EOF) {
    perror("fclose()");
    r05_builtin_error("Can't close stream");
    return R05_RECOGNITION_IMPOSSIBLE;  /* suppress warning */
  }

  s_streams[file_no] = fopen(filename, mode);
  if (s_streams[file_no] == NULL) {
    char mode_buffer[100] = { '\0' };
    static const char error_format[] = "Can't open %s for \"%s\"";
    char error[sizeof(error_format) + FILENAME_MAX + sizeof(mode_buffer)];

    strncpy(mode_buffer, mode, sizeof(mode_buffer) - 1);
    sprintf(error, error_format, filename, mode_buffer);
    perror(error);
    r05_builtin_error(error);
    return R05_RECOGNITION_IMPOSSIBLE;  /* suppress warning */
  }

  r05_splice_to_freelist(arg_begin, arg_end);

  return R05_SUCCESS;
%%
}


/**
  23. <Ord e.Expr> == e.Expr’

  В e.Expr’ все литеры заменены на их коды ASCII
*/
$ENTRY Ord {
%%
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p = callee->next;

  while (p != arg_end) {
    if (p->tag == R05_DATATAG_CHAR) {
      p->tag = R05_DATATAG_NUMBER;
      p->info.number = (unsigned char) p->info.char_;
    }
    p = p->next;
  }

  r05_splice_to_freelist(arg_begin, callee);
  r05_splice_to_freelist(arg_end, arg_end);

  return R05_SUCCESS;
%%
}


/**
  24. <Print e.Expr> == e.Expr
*/
%%
enum output_func_type {
  PRINT, PROUT,
};

static enum r05_fnresult output_func(
  struct r05_node *arg_begin, struct r05_node *arg_end,
  FILE *output, enum output_func_type type
);
%%

$ENTRY Print {
%%
  return output_func(arg_begin, arg_end, stdout, PRINT);
%%
}

%%
static enum r05_fnresult output_func(
  struct r05_node *arg_begin, struct r05_node *arg_end,
  FILE *output, enum output_func_type type
) {
  struct r05_node *callee = arg_begin->next;
  struct r05_node *p;

#define CHECK_PRINTF(printf_call) \
  ((printf_call) >= 0 ? (void) 0 \
  : r05_builtin_error("Error in call " #printf_call))

  for (p = callee->next; p != arg_end; p = p->next) {
    switch (p->tag) {
      case R05_DATATAG_CHAR:
        CHECK_PRINTF(fprintf(output, "%c", p->info.char_));
        break;

      case R05_DATATAG_FILE:
        CHECK_PRINTF(fprintf(output, "*%p", p->info.file));
        break;

      case R05_DATATAG_FUNCTION:
        CHECK_PRINTF(fprintf(output, "%s ", p->info.function.name));
        break;

      case R05_DATATAG_NUMBER:
        CHECK_PRINTF(fprintf(output, "%lu ", (long unsigned int) p->info.number));
        break;

      case R05_DATATAG_OPEN_BRACKET:
        CHECK_PRINTF(fprintf(output, "("));
        break;

      case R05_DATATAG_CLOSE_BRACKET:
        CHECK_PRINTF(fprintf(output, ")"));
        break;

      default:
        r05_switch_default_violation(p->tag);
    }
  }

  CHECK_PRINTF(fprintf(output, "\n"));

  if (type == PRINT) {
    r05_splice_to_freelist(arg_begin, callee);
    r05_splice_to_freelist(arg_end, arg_end);
  } else if (type == PROUT) {
    r05_splice_to_freelist(arg_begin, arg_end);
  } else {
    r05_switch_default_violation(type);
  }

  return R05_SUCCESS;
}
%%


/**
  25. <Prout e.Expr> == []
*/
$ENTRY Prout {
%%
  return output_func(arg_begin, arg_end, stdout, PROUT);
%%
}


* 26 Put
$EENUM Put;

* 27 Putout
$EENUM Putout;

* 28 Rp
$EENUM Rp;

* 29 Step
$EENUM Step;


/**
  30. <Sub s.NUMBER s.NUMBER> == s.NUMBER
*/
$ENTRY Sub {
%%
  ARITHM_OP(-, NO_CHECK)
%%
}


* 31 Symb
$EENUM Symb;

* 32 Time
$EENUM Time;

* 33 Type
** $EENUM Type;

* 34 Upper
$EENUM Upper;

* 35 Sysfun
$EENUM Sysfun;

* 45 Freeze
$EENUM Freeze;

* 46 Freezer
$EENUM Freezer;

* 47 Dn
$EENUM Dn;

* 48 Up
$EENUM Up;

* 49 Ev-met
$EENUM Ev-met;

* 50 Residue
$EENUM Residue;

* 51 GetEnv
** $EENUM GetEnv;

* 52 System
** $EENUM System;

* 53 Exit
** $EENUM Exit;

* 54 Close
$EENUM Close;

* 55 ExistFile
** $EENUM ExistFile;

* 56 GetCurrentDirectory
$EENUM GetCurrentDirectory;

* 57 RemoveFile
$EENUM RemoveFile;

* 58 Implode_Ext
$EENUM Implode_Ext;

* 59 Explode_Ext
$EENUM Explode_Ext;

* 60 TimeElapsed
$EENUM TimeElapsed;

/**
  61. <Compare s.X s.Y>
        == '-' | '0' | '+'
      s.X, s.Y ::= s.NUMBER

  Функция возвращает знак разности между s.X и s.Y
*/
$ENTRY Compare {
%%
  struct r05_node *func_name, *sX, *sY;

  func_name = arg_begin->next;
  sX = func_name->next;
  if (sX->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  sY = sX->next;
  if (sY->tag != R05_DATATAG_NUMBER) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  if (sY->next != arg_end) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  sX->info.char_ =
    sX->info.number < sY->info.number ? '-' :
    sX->info.number > sY->info.number ? '+' :
    '0';
  sX->tag = R05_DATATAG_CHAR;

  r05_splice_to_freelist(arg_begin, func_name);
  r05_splice_to_freelist(sY, arg_end);

  return R05_SUCCESS;
%%
}

* 62 DeSysfun
$EENUM DeSysfun;

* 63 XMLParse
$EENUM XMLParse;

* 64 Random
$EENUM Random;

* 65 RandomDigit
$EENUM RandomDigit;

* 66 Write
$EENUM Write;


/**
  67. <ListOfBuiltin> == (s.No s.Name s.Type)*

      s.No ::= s.NUMBER
      s.Name ::= s.FUNCTION
      s.Type ::= special | regular
*/
$EENUM special, regular;

$ENTRY ListOfBuiltin {
  = (1 Mu special)
    (2 Add regular)
    (3 Arg regular)
    (4 Br regular)
    (5 Card regular)
    (6 Chr regular)
    (7 Cp regular)
    (8 Dg regular)
    (9 Dgall regular)
    (10 Div regular)
    (11 Divmod regular)
    (12 Explode regular)
    (13 First regular)
    (14 Get regular)
    (15 Implode regular)
    (16 Last regular)
    (17 Lenw regular)
    (18 Lower regular)
    (19 Mod regular)
    (20 Mul regular)
    (21 Numb regular)
    (22 Open regular)
    (23 Ord regular)
    (24 Print regular)
    (25 Prout regular)
    (26 Put regular)
    (27 Putout regular)
    (28 Rp regular)
    (29 Step regular)
    (30 Sub regular)
    (31 Symb regular)
    (32 Time regular)
*    (33 Type regular)  /* in LibraryEx */
    (34 Upper regular)
    (35 Sysfun regular)
    /* (42 "Imp$$" regular) */
    /* (43 "Stop$$" regular) */
    /* (44 "" regular) */
    (45 Freeze regular)
    (46 Freezer regular)
    (47 Dn regular)
    (48 Up special)
    (49 Ev-met special)
    (50 Residue special)
    (51 GetEnv regular)
    (52 System regular)
    (53 Exit regular)
    (54 Close regular)
    (55 ExistFile regular)
    (56 GetCurrentDirectory regular)
    (57 RemoveFile regular)
    (58 Implode_Ext regular)
    (59 Explode_Ext regular)
    (60 TimeElapsed regular)
    (61 Compare regular)
    (62 DeSysfun regular)
    (63 XMLParse regular)
    (64 Random regular)
    (65 RandomDigit regular)
    (66 Write regular)
    (67 ListOfBuiltin regular)
    (68 SizeOf regular)
    (69 GetPID regular)
    (70 int4fab_1 regular)
    (71 GetPPID regular);
}


* 68 SizeOf
$EENUM SizeOf;

* 69 GetPID
$EENUM GetPID;

* 70 int4fab_1
$EENUM int4fab_1;

* 71 GetPPID
$EENUM GetPPID;



*===============================================================================
* Библиотека "встроенных" функций
*===============================================================================

* Основные перечисления

$EENUM Success, Fails, True, False;

* Ввод-вывод


%%
enum r05_fnresult write_to_stream(
  FILE *out, struct r05_node *str_begin, struct r05_node *str_end
) {
  if (ferror(out)) {
    return R05_RECOGNITION_IMPOSSIBLE;
  }

  int printf_res;

  for (
    struct r05_node *p = str_begin;
    ! r05_empty_seq(p, str_end);
    r05_move_left(&p, &str_end)
  ) {
    switch(p->tag) {
      case R05_DATATAG_CHAR: {
        printf_res = fprintf(out, "%c", p->info.char_);
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_NUMBER: {
        printf_res = fprintf(out, "%lu ", p->info.number);
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_FUNCTION: {
        if (p->info.function.name[0] != '\0') {
          printf_res = fprintf(out, "%s ", p->info.function.name);
        } else {
          printf_res = fprintf(out, "&%p ", p->info.function.ptr);
        }

        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_OPEN_BRACKET: {
        printf_res = fprintf(out, "(");
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_CLOSE_BRACKET: {
        printf_res = fprintf(out, ")");
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      case R05_DATATAG_FILE: {
        printf_res = fprintf(out, "*%p", p->info.file);
        if (printf_res < 0) {
          return R05_RECOGNITION_IMPOSSIBLE;
        } else {
          break;
        }
      }

      default:
        r05_switch_default_violation(p->tag);
    }
  }

  printf_res = fprintf(out, "\n");
  if (printf_res < 0) {
    return R05_RECOGNITION_IMPOSSIBLE;
  } else {
    return R05_SUCCESS;
  }
}
%%


$ENTRY FWriteLine {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sFileHandle_1;
    struct r05_node *eLine_b_1;
    struct r05_node *eLine_e_1;
    // s.FileHandle e.Line
    if (! r05_svar_left(&sFileHandle_1, &bb_0, &be_0))
      break;
    if (sFileHandle_1->tag != R05_DATATAG_FILE)
      break;
    eLine_b_1 = bb_0;
    eLine_e_1 = be_0;

    enum r05_fnresult write_result =
      write_to_stream(
        static_cast<FILE*>(sFileHandle_1->info.file), eLine_b_1, eLine_e_1
      );

    if (write_result != R05_SUCCESS)
      return write_result;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;
    refalrts::splice_stvar(res, sFileHandle_1);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}


%%
namespace {

enum r05_fnresult string_from_seq(
  std::vector<char>& string, struct r05_node *begin, struct r05_node *end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  for ( ; ; ) {
    unsigned read = r05_read_chars(buffer, cBufLen, &begin, &end);

    if (read == 0) {
      break;
    }

    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);

    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь r05_empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (r05_empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return R05_SUCCESS;
  } else {
    // здесь begin->tag != cDataChar
    return R05_RECOGNITION_IMPOSSIBLE;
  }
}

} // unnamed namespace
%%


$ENTRY FOpen {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eFileName_b_1;
    struct r05_node *eFileName_e_1;

    const char *mode;

    if (r05_char_left('r', &bb_0, &be_0)) {
      mode = "r";
    } else if (r05_char_left('w', &bb_0, &be_0)) {
      mode = "w";
    } else {
      break;
    }

    eFileName_b_1 = bb_0;
    eFileName_e_1 = be_0;

    std::vector<char> filename;

    enum r05_fnresult fname_read =
      string_from_seq(filename, eFileName_b_1, eFileName_e_1);

    if (R05_SUCCESS != fname_read)
      return fname_read;

    if (filename.empty())
      return R05_RECOGNITION_IMPOSSIBLE;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *file_ptr = r05_alloc_node(R05_DATATAG_FILE);

    file_ptr->tag = R05_DATATAG_FILE;

    if (FILE *f = fopen(&filename[0], mode)) {
      file_ptr->info.file = f;
    } else {
      return R05_RECOGNITION_IMPOSSIBLE;
    }

    refalrts::splice_elem(res, file_ptr);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY FClose {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sFileHandle_1;
    // s.FileHandle
    if (! r05_svar_left(&sFileHandle_1, &bb_0, &be_0))
      break;
    if (sFileHandle_1->tag != R05_DATATAG_FILE)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    int fclose_res = fclose(static_cast<FILE*>(sFileHandle_1->info.file));

    if (EOF == fclose_res) {
      return R05_RECOGNITION_IMPOSSIBLE;
    } else {
      /* Ничего не делаем */;
    }

    r05_reset_allocator();
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}


$ENTRY ExistFile {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eFileName_b_1;
    struct r05_node *eFileName_e_1;
    // e.FileName
    eFileName_b_1 = bb_0;
    eFileName_e_1 = be_0;

    std::vector<char> fname;

    enum r05_fnresult fname_res =
      string_from_seq(fname, eFileName_b_1, eFileName_e_1);

    if (fname_res != R05_SUCCESS)
      return fname_res;

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    struct r05_node *ans = 0;
    if (FILE *f = fopen(&fname[0], "r")) {
      // Файл существует
      fclose(f);

      refalrts::alloc_name(ans, r05c_True, "True");
    } else {
      // Файл по-видимому не существует
      refalrts::alloc_name(ans, r05c_False, "False");
    }

    refalrts::splice_elem(res, ans);
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY GetEnv {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);
    struct r05_node *eEnvName_b_1;
    struct r05_node *eEnvName_e_1;
    // e.EnvName
    eEnvName_b_1 = bb_0;
    eEnvName_e_1 = be_0;

    std::vector<char> envname;

    enum r05_fnresult envname_res =
      string_from_seq(envname, eEnvName_b_1, eEnvName_e_1);

    if (envname_res != R05_SUCCESS)
      return envname_res;

    r05_reset_allocator();

    const char *envres = getenv(& envname[0]);

    if (envres != 0) {
      struct r05_node *env_begin;
      struct r05_node *env_end;

      refalrts::alloc_string(env_begin, env_end, envres);

      refalrts::splice_evar(arg_begin, env_begin, env_end);

      //struct r05_node *char_pos;
      //
      //for (const char *env = envres; *env != '\0'; ++ env) {
      //  refalrts::alloc_char(char_pos, *env);
      //  refalrts::splice_elem(res, char_pos);
      //}
    }

    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY Exit {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *sCode_1;
    // s.Code
    if (! r05_svar_left(&sCode_1, &bb_0, &be_0))
      break;
    if (sCode_1->tag != R05_DATATAG_NUMBER)
      break;
    if (! r05_empty_seq(bb_0, be_0))
      break;

    r05_exit((int) sCode_1->info.number);
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY System {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eCommand_b_1;
    struct r05_node *eCommand_e_1;
    // e.Command
    eCommand_b_1 = bb_0;
    eCommand_e_1 = be_0;

    std::vector<char> command;

    enum r05_fnresult read_res =
      string_from_seq(command, eCommand_b_1, eCommand_e_1);

    if (read_res != R05_SUCCESS)
      return read_res;

    fflush(stdout);
    fflush(stderr);

    system(&command[0]);

    r05_reset_allocator();
    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

* Работа с типами символов

$ENTRY IntFromStr {
%%
  do {
    struct r05_node *bb_0 = 0;
    struct r05_node *be_0 = 0;
    r05_prepare_argument(&bb_0, &be_0, arg_begin, arg_end);

    struct r05_node *eNumber_b_1;
    struct r05_node *eNumber_e_1;
    // e.NoNumber
    eNumber_b_1 = bb_0;
    eNumber_e_1 = be_0;

    bool start_is_digit =
      ! r05_empty_seq(eNumber_b_1, eNumber_e_1)
      && (R05_DATATAG_CHAR == eNumber_b_1->tag)
      && isdigit(eNumber_b_1->info.char_);

    r05_reset_allocator();
    struct r05_node *res = arg_begin;

    if (! start_is_digit) {
      struct r05_node *fail_pos = 0;
      refalrts::alloc_name(fail_pos, r05c_Fails, "Fails");

      res = refalrts::splice_evar(res, eNumber_b_1, eNumber_e_1);
      refalrts::splice_elem(res, fail_pos);
    } else {
      r05_number acc = 0;

      for ( ; ; ) {
        if (r05_empty_seq(eNumber_b_1, eNumber_e_1)) {
          break;
        } else if (eNumber_b_1->tag != R05_DATATAG_CHAR) {
          break;
        } else if (! isdigit(eNumber_b_1->info.char_)) {
          break;
        } else {
          (acc *= 10) += eNumber_b_1->info.char_ - '0';
        }

        r05_move_left(&eNumber_b_1, &eNumber_e_1);
      }

      struct r05_node *success_pos = 0;
      struct r05_node *number_pos = 0;

      refalrts::alloc_name(success_pos, r05c_Success, "Success");
      refalrts::alloc_number(number_pos, acc);

      res = refalrts::splice_evar(res, eNumber_b_1, eNumber_e_1);
      res = refalrts::splice_elem(res, number_pos);
      refalrts::splice_elem(res, success_pos);
    }

    r05_splice_to_freelist(arg_begin, arg_end);
    return R05_SUCCESS;
  } while (0);

  return R05_RECOGNITION_IMPOSSIBLE;
%%
}

$ENTRY StrFromInt {
  s.Number = <Numb s.Number>;
}
