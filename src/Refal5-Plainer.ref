*$FROM Refal5-AST
*$EXTERN Extern, Function, SpecialComment, Entry, Local, RETURN, Condition
*$EXTERN CALL-BLOCK, Brackets, Call, Symbol, Word, Number, Char, Variable
*$FROM Library
*$EXTERN False, True
$ENTRY Plain {
  e.Units = <UndoubleEmtpyLines <TrimLines <DoPlain e.Units>>>;
}

TrimLines {
  (e.Line) e.Lines = (<Trim-R e.Line>) <TrimLines e.Lines>;

   = ;
}

UndoubleEmtpyLines {
  e.Lines-B () () e.Lines-E = e.Lines-B <UndoubleEmtpyLines () e.Lines-E>;

  e.Lines = e.Lines;
}

Trim-R {
  e.Line ' ' = <Trim-R e.Line>;

  e.Line = e.Line;
}

DoPlain {
  (Extern e.Names) e.Units = <PlainExtern e.Names> <Plain e.Units>;

  (Function t.SrcPos (e.Name) s.Scope e.Sentences) e.Units
    = <PlainFunction (e.Name) s.Scope e.Sentences> <Plain e.Units>;

  (SpecialComment t.SrcPos e.Text) e.Units = (e.Text) <Plain e.Units>;

   = ;
}

MAX-LINE {
   = 79;
}

LongLine {
  e.Line = <DoLongLine <MAX-LINE> e.Line>;
}

DoLongLine {
  s.Len = False;

  0 e.Line = True;

  s.Len t.Next e.Line = <DoLongLine <- s.Len 1> e.Line>;
}

PlainExtern {
  e.Names = <DoExtern ('$EXTERN ') e.Names>;
}

DoExtern {
  (e.OutLine) (t.Pos e.NextName) e.Names
    = <DoExtern_check
        (e.OutLine) t.Pos (e.NextName) (e.Names) <CommaOrSemicolon e.Names>
      >;

  e.Other = <DoExtern_cont e.Other>;
}

DoExtern_check {
  (e.OutLine) t.Pos (e.NextName) (e.Names) e.SEP
    = <DoExtern_check0
        (e.OutLine) t.Pos (e.NextName) (e.Names) (e.SEP) e.OutLine e.NextName
        e.SEP
      >;

  e.Other = <DoExtern_cont0 e.Other>;
}

DoExtern_cont {
  (e.OutLine) = (e.OutLine) ();
}

DoExtern_check0 {
  (e.OutLine) t.Pos (e.NextName) (e.Names) (e.SEP) e.NewOutLine
    = <DoExtern0
        t.Pos (e.Names) (e.OutLine) (e.NextName) (e.SEP) (e.NewOutLine)
        <LongLine e.NewOutLine>
      >;

  (e.OutLine) t.Pos (e.NextName) (e.Names) (e.SEP) e.Other
    = <DoExtern_cont0 (e.OutLine) t.Pos (e.NextName) (e.Names) e.SEP>;
}

DoExtern_cont0 {
  (e.OutLine) t.Pos (e.NextName) (e.Names) e.Other
    = <DoExtern_cont (e.OutLine) (t.Pos e.NextName) e.Names>;
}

DoExtern0 {
  t.Pos (e.Names) (e.OutLine) (e.NextName) (e.SEP) (e.NewOutLine) True
    = (<Trim-R e.OutLine>) <DoExtern ('  ' e.NextName e.SEP) e.Names>;

  t.Pos (e.Names) (e.OutLine) (e.NextName) (e.SEP) (e.NewOutLine) False
    = <DoExtern (e.NewOutLine) e.Names>;
}

CommaOrSemicolon {
  (t.Pos e.NextName) e.Names = ', ';

   = ';';
}

PlainFunction {
  (e.Name) s.Scope e.Sentences
    = (<PlainScope s.Scope> e.Name ' {') <Sentences ('  ') e.Sentences> ('}')
      ();
}

PlainScope {
  Entry = '$ENTRY ';

  Local = ;
}

Sentences {
  (e.Indent) (e.Sentence) = <Sentence (e.Indent) e.Sentence>;

  (e.Indent) (e.Sentence) e.Sentences
    = <Sentence (e.Indent) e.Sentence> () <Sentences (e.Indent) e.Sentences>;

  (e.Indent) = ;
}

*$ENUM Comment
Sentence {
  (s.Space e.Indent) Comment e.Text = <PutComment (e.Indent) e.Text>;

  (e.Indent) (e.Pattern) RETURN (e.Result)
    = <Sentence_check
        (e.Indent) (e.Pattern) (e.Result) e.Indent <InlineExpr e.Pattern> ' = '
        <InlineExpr e.Result> ';'
      >;

  e.Other = <Sentence_cont e.Other>;
}

Sentence_check {
  (e.Indent) (e.Pattern) (e.Result) e.OneLineSentence
    = <Sentence_check0
        (e.Indent) (e.Pattern) (e.Result) (e.OneLineSentence)
        <LongLine e.OneLineSentence>
      >;

  e.Other = <Sentence_cont0 e.Other>;
}

Sentence_cont {
  (e.Indent) (e.Pattern) e.Tail
    = <Expression (e.Indent) (e.Indent) e.Pattern>
      <Tail (e.Indent '  ') e.Tail>;
}

Sentence_check0 {
  (e.Indent) (e.Pattern) (e.Result) (e.OneLineSentence) False
    = (e.OneLineSentence);

  (e.Indent) (e.Pattern) (e.Result) (e.OneLineSentence) e.Other
    = <Sentence_cont0 (e.Indent) (e.Pattern) (e.Result) e.OneLineSentence>;
}

Sentence_cont0 {
  (e.Indent) (e.Pattern) (e.Result) e.Other
    = <Sentence_cont (e.Indent) (e.Pattern) RETURN (e.Result)>;
}

PutComment {
  (e.Indent) e.Comment '\n' e.Tail
    = ('*' e.Indent e.Comment) <PutComment (e.Indent) e.Tail>;

  (e.Indent) e.Comment = ('*' e.Indent e.Comment);
}

Tail {
  (e.Indent) (Condition (e.Result) (e.Pattern)) e.Tail
    = <Tail_check
        (e.Indent) (e.Result) (e.Pattern) (e.Tail) e.Indent ', '
        <InlineExpr e.Result> ': ' <InlineExpr e.Pattern>
      >;

  e.Other = <Tail_cont e.Other>;
}

Tail_check {
  (e.Indent) (e.Result) (e.Pattern) (e.Tail) e.OneLineCondition
    = <Tail0
        (e.Tail) (e.Indent) (e.Result) (e.Pattern) (e.OneLineCondition)
        <LongLine e.OneLineCondition>
      >;

  (e.Indent) (e.Result) (e.Pattern) (e.Tail) e.Other
    = <Tail_cont (e.Indent) (Condition (e.Result) (e.Pattern)) e.Tail>;
}

Tail_cont {
  (e.Indent) RETURN (e.Result)
    = <Expression (e.Indent '= ') (e.Indent '  ') e.Result ';'>;

  (e.Indent) CALL-BLOCK (e.Result) e.Sentences
    = <Expression (e.Indent ', ') (e.Indent '  ') e.Result> (e.Indent ': {')
      <Sentences (e.Indent '    ') e.Sentences> (e.Indent '  };');
}

Tail0 {
  (e.Tail) (e.Indent) (e.Result) (e.Pattern) (e.OneLineCondition) True
    = <Expression (e.Indent ', ') (e.Indent '  ') e.Result>
      <Expression (e.Indent ': ') (e.Indent '  ') e.Pattern>
      <Tail (e.Indent) e.Tail>;

  (e.Tail) (e.Indent) (e.Result) (e.Pattern) (e.OneLineCondition) False
    = (e.OneLineCondition) <Tail (e.Indent) e.Tail>;
}

*$ENUM FIRST, NEXT
Expression {
  (e.Prefix) (e.Indent)
    = <Expression_check (e.Prefix) (e.Indent) <Trim-R e.Prefix>>;

  e.Other = <Expression_cont e.Other>;
}

Expression_check {
  (e.Prefix) (e.Indent) = ;

  (e.Prefix) (e.Indent) e.Other = <Expression_cont (e.Prefix) (e.Indent)>;
}

Expression_cont {
  (e.Prefix) (e.Indent) = (e.Prefix);

  (e.Prefix) (e.Indent) e.Expression
    = <DoExpression FIRST (e.Indent) (e.Prefix) e.Expression>;
}

DoExpression {
  s.Pos (e.Indent) (e.OutLine) = (e.OutLine);

  s.Pos (e.Indent) (e.OutLine) ';' = (e.OutLine ';');

  s.Pos (e.Indent) (e.OutLine) t.NextTerm e.Expr
    = <DoExpression_check
        s.Pos (e.Indent) (e.OutLine) t.NextTerm (e.Expr)
        <InlineTerm t.NextTerm>
      >;
}

DoExpression_check {
  s.Pos (e.Indent) (e.OutLine) t.NextTerm (e.Expr) e.TextualTerm
    = <DoExpression_check0
        s.Pos (e.Indent) (e.OutLine) t.NextTerm (e.Expr) (e.TextualTerm)
        <AppendTerm e.OutLine (e.TextualTerm)>
      >;
}

DoExpression_check0 {
  s.Pos (e.Indent) (e.OutLine) t.NextTerm (e.Expr) (e.TextualTerm) e.NewOutLine
    = <DoExpression0
        s.Pos (e.Indent) (e.Expr) t.NextTerm (e.OutLine) (e.TextualTerm)
        (e.NewOutLine) <LongLine e.NewOutLine>
      >;
}

DoExpression0 {
  s.Pos (e.Indent) (e.Expr) t.NextTerm (e.OutLine) (e.TextualTerm)
  (e.NewOutLine) True
    = <DoExpression0_check
        s.Pos (e.Indent) (e.Expr) t.NextTerm (e.OutLine) (e.TextualTerm)
        (e.NewOutLine) e.Indent e.TextualTerm
      >;

  e.Other = <DoExpression0_cont e.Other>;
}

DoExpression0_check {
  s.Pos (e.Indent) (e.Expr) t.NextTerm (e.OutLine) (e.TextualTerm)
  (e.NewOutLine) e.OutLineTerm
    = <DoExpression1
        s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
        (e.TextualTerm) (e.OutLineTerm) <LongLine e.OutLineTerm>
      >;

  s.Pos (e.Indent) (e.Expr) t.NextTerm (e.OutLine) (e.TextualTerm)
  (e.NewOutLine) e.Other
    = <DoExpression0_cont
        s.Pos (e.Indent) (e.Expr) t.NextTerm (e.OutLine) (e.TextualTerm)
        (e.NewOutLine) True
      >;
}

DoExpression0_cont {
  s.Pos (e.Indent) (e.Expr) t.NextTerm (e.OutLine) (e.TextualTerm)
  (e.NewOutLine) False
    = <DoExpression NEXT (e.Indent) (e.NewOutLine) e.Expr>;
}

DoExpression1 {
  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm) True
    = <DoExpression1_check
        s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
        (e.TextualTerm) (e.OutLineTerm) e.Expr
      >;

  e.Other = <DoExpression1_cont e.Other>;
}

DoExpression1_check {
  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm) ';'
    = <MultilineTerm s.Pos (e.OutLine) e.Indent t.NextTerm (';')>;

  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm) e.Other
    = <DoExpression1_cont
        s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
        (e.TextualTerm) (e.OutLineTerm) True
      >;
}

DoExpression1_cont {
  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm) True
    = <DoExpression1_check0
        s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
        (e.TextualTerm) (e.OutLineTerm) e.Expr
      >;

  e.Other = <DoExpression1_cont0 e.Other>;
}

DoExpression1_check0 {
  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm)
    = <MultilineTerm s.Pos (e.OutLine) e.Indent t.NextTerm ()>;

  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm) e.Other
    = <DoExpression1_cont0
        s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
        (e.TextualTerm) (e.OutLineTerm) True
      >;
}

DoExpression1_cont0 {
  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm) True
    = <MultilineTerm s.Pos (e.OutLine) e.Indent t.NextTerm ()>
      <DoExpression NEXT (e.Indent) (e.Indent) e.Expr>;

  s.Pos (e.Expr) t.NextTerm (e.OutLine) (e.NewOutLine) (e.Indent)
  (e.TextualTerm) (e.OutLineTerm) False
    = (e.OutLine) <DoExpression NEXT (e.Indent) (e.OutLineTerm) e.Expr>;
}

AppendTerm {
  e.String '\'' ('\'' e.Term) = e.String e.Term;

  e.String ' ' (e.Term) = e.String ' ' e.Term;

  e.String (e.Term) = e.String ' ' e.Term;
}

InlineTerm {
  (s.Type e.Value) = <PlainTerm s.Type e.Value>;

  ';' = ';';
}

MultilineTerm {
  FIRST (e.Prefix) e.Indent t.Term (e.Suffix)
    = <MultilineTerm-Prefix (e.Prefix) e.Indent t.Term (e.Suffix)>;

  NEXT (e.Prefix) e.Indent t.Term (e.Suffix)
    = (e.Prefix) <MultilineTerm-Prefix (e.Indent) e.Indent t.Term (e.Suffix)>;
}

MultilineTerm-Prefix {
  (e.Prefix) e.Indent t.Term (e.Suffix)
    = <MultilineTerm-Prefix0 (e.Prefix) (e.Indent) t.Term (e.Suffix) t.Term>;
}

MultilineTerm-Prefix0 {
  (e.Prefix) (e.Indent) t.Term (e.Suffix) (Brackets e.Expr)
    = (e.Prefix '(') <Expression (e.Indent '  ') (e.Indent '  ') e.Expr>
      (e.Indent ')' e.Suffix);

  (e.Prefix) (e.Indent) t.Term (e.Suffix) (Call t.SrcPos (e.Function) e.Expr)
    = (e.Prefix '<' e.Function)
      <Expression (e.Indent '  ') (e.Indent '  ') e.Expr>
      (e.Indent '>' e.Suffix);

  (e.Prefix) (e.Indent) t.Term (e.Suffix) (s.Type e.Value)
    = (e.Prefix <PlainTerm s.Type e.Value> e.Suffix);
}

PlainTerm {
  Symbol Word t.SrcPos e.Chars = <PlainCompound e.Chars>;

  Symbol Number s.Number = <PlainNumber s.Number>;

  Symbol Char s.Char = <PlainChar s.Char>;

  Variable t.SrcPos s.Type e.Index = <PlainVariable t.SrcPos s.Type e.Index>;

  Call t.SrcPos (e.Function) e.Arg = <PlainCall t.SrcPos (e.Function) e.Arg>;

  Brackets e.Expr = <PlainBrackets e.Expr>;
}

PlainCompound {
  e.Chars = <PlainCompound_check (e.Chars) <IsIdent e.Chars>>;

  e.Other = <PlainCompound_cont e.Other>;
}

PlainCompound_check {
  (e.Chars) True e.Textual = e.Textual;

  (e.Chars) e.Other = <PlainCompound_cont e.Chars>;
}

PlainCompound_cont {
  e.Chars = '\"' <DoCompound e.Chars> '\"';
}

DoCompound {
  s.Char e.Chars = <CharRep s.Char> <DoCompound e.Chars>;

   = ;
}

IsIdent {
  s.Initial e.Tail = <IsIdent_check s.Initial (e.Tail) <Type s.Initial>>;
}

IsIdent_check {
  s.Initial (e.Tail) 'L' s.SubType s.Initial = <DoIsIdent (s.Initial) e.Tail>;
}

DoIsIdent {
  (e.Valid) '-' e.Tail = <DoIsIdent (e.Valid '-') e.Tail>;

  (e.Valid) '_' e.Tail = <DoIsIdent (e.Valid '_') e.Tail>;

  (e.Valid) s.Next e.Tail
    = <DoIsIdent_check (e.Valid) s.Next (e.Tail) <Type s.Next>>;

  e.Other = <DoIsIdent_cont e.Other>;
}

DoIsIdent_check {
  (e.Valid) s.Next (e.Tail) 'L' s.Subtype s.Next
    = <DoIsIdent (e.Valid s.Next) e.Tail>;

  (e.Valid) s.Next (e.Tail) e.Other = <DoIsIdent_cont (e.Valid) s.Next e.Tail>;
}

DoIsIdent_cont {
  (e.Valid) s.Next e.Tail
    = <DoIsIdent_check0 (e.Valid) s.Next (e.Tail) <Type s.Next>>;

  e.Other = <DoIsIdent_cont0 e.Other>;
}

DoIsIdent_check0 {
  (e.Valid) s.Next (e.Tail) 'D0' s.Next = <DoIsIdent (e.Valid s.Next) e.Tail>;

  (e.Valid) s.Next (e.Tail) e.Other
    = <DoIsIdent_cont0 (e.Valid) s.Next e.Tail>;
}

DoIsIdent_cont0 {
  (e.Valid) = True e.Valid;

  (e.Valid) s.Other e.Tail = False;
}

PlainNumber {
  s.Number = <Symb s.Number>;
}

PlainChar {
  s.Char = '\'' <CharRep s.Char> '\'';
}

CharRep {
  '\'' = '\\\'';

  '\"' = '\\\"';

  '\\' = '\\\\';

  '\n' = '\\n';

  '\r' = '\\r';

  '\t' = '\\t';

  s.Char = <CharRep_check s.Char <Ord s.Char>>;

  e.Other = <CharRep_cont e.Other>;
}

CharRep_check {
  s.Char s.Ord = <CharRep_check0 s.Char s.Ord <Compare s.Ord 32>>;

  e.Other = <CharRep_cont0 e.Other>;
}

CharRep_cont {
  s.Char = s.Char;
}

CharRep_check0 {
  s.Char s.Ord '-' = '\\x' <HexDigit </ s.Ord 16>> <HexDigit <% s.Ord 16>>;

  s.Char s.Ord e.Other = <CharRep_cont0 s.Char s.Ord>;
}

CharRep_cont0 {
  s.Char e.Other = <CharRep_cont s.Char>;
}

HexDigit {
  s.Number = <HexDigit_check s.Number <First s.Number '0123456789abcdef'>>;
}

HexDigit_check {
  s.Number (e.1) s.Digit e.2 = s.Digit;
}

PlainVariable {
  t.SrcPos s.Type e.Index = s.Type '.' e.Index;
}

PlainBrackets {
  e.Expr = '(' <InlineExpr e.Expr> ')';
}

PlainCall {
  t.SrcPos (e.Function) = '<' e.Function '>';

  t.SrcPos (e.Function) e.Expr = '<' e.Function ' ' <InlineExpr e.Expr> '>';
}

$ENTRY InlineExpr {
  t.Term e.Expr = <DoInlineExpr (<InlineTerm t.Term>) e.Expr>;

   = ;
}

DoInlineExpr {
  (e.Text) t.NextTerm e.Expr
    = <DoInlineExpr (<AppendTerm e.Text (<InlineTerm t.NextTerm>)>) e.Expr>;

  (e.Text) = e.Text;
}

