*$FROM LibraryEx
$EXTERN LoadFile, Inc, Success, Fails;


/**
  <R05-LexScan-File e.SourceName>
    == e.Tokens
  e.Tokens ::= (s.TokType t.SrcPos e.Info)*
  t.SrcPos ::= (s.Row s.Col)

  <Mu s.TokType e.Info> == s.CHAR*

  s.TokType e.Info ::=
      TkChar s.CHAR
    | TkClose s.Bracket
    | TkCloseBlock
    | TkComma
    | TkEEnum
    | TkEOF
    | TkEntry
    | TkEnum
    | TkError e.Message
    | TkExtern
    | TkName e.Name
    | TkNumber s.NUMBER
    | TkOpen s.Bracket
    | TkOpenBlock
    | TkReplace
    | TkSemicolon
    | TkUnexpected e.BadCharacters
    | TkVariable s.Mode e.Index

  s.Bracket ::= Bracket | CallBracket
  e.Message, e.Name, e.BadCharacters, e.Index ::= s.CHAR+
  s.Mode ::= 's' | 't' | 'e'
*/
$ENTRY R05-LexScan-File {
  e.FileName = <R05-LexScan-String <LoadText e.FileName>>;
}

LoadText {
  e.FileName = <SkipBOM <FlatLines <LoadFile e.FileName>>>;
}

FlatLines {
  /* Для случая чтения исходников с CRLF на платформе с LF */
  (e.Line '\r') e.Lines = e.Line '\n' <FlatLines e.Lines>;
  (e.Line) e.Lines = e.Line '\n' <FlatLines e.Lines>;
  /* пусто */ = /* пусто */;
}

SkipBOM {
  /* Игнорируем метку порядка байт для UTF-8 */
  '\xEF\xBB\xBF' e.Content = e.Content;

  e.Content = e.Content;
}

/**
  <R05-LexScan-String e.String> == e.Tokens

  e.String ::= s.CHAR*
*/
$ENTRY R05-LexScan-String {
  e.String = <Scan 1 1 e.String>;
}

$ENTRY TkChar { s.Char = '\'' <EscapeChar s.Char> '\'' }

EscapeChar {
  '\n' = '\\n';
  '\t' = '\\t';
  '\r' = '\\r';
  '\'' = '\\\'';
  '\"' = '\\\"';
  '\\' = '\\\\';

  s.Other = <EscapeChar-Aux s.Other <Ord s.Other>>;
}

EscapeChar-Aux {
  s.Other s.Code =
    <EscapeChar-SwCompare
      s.Other <Compare 31 s.Code> <Compare s.Code 128> s.Code
    >;
}

EscapeChar-SwCompare {
  s.Other '-' '-' s.Code = s.Other;

  s.Other s.Compare1 s.Compare2 s.Code =
    '\\x' <CharFromHex <Div s.Code 16>> <CharFromHex <Mod s.Code 16>>;
}

CharFromHex {
  s.Value = <CharFromHex-Aux s.Value <HexDigits>>;
}

CharFromHex-Aux {
  s.Value e.Hex-B (s.Digit s.Value) e.Hex-E = s.Digit;
}

$ENTRY TkClose {
  Bracket = ')';
  CallBracket = '>';
}

$ENTRY TkCloseBlock { = '}' }
$ENTRY TkComma { = ',' }
$ENTRY TkEEnum { = '$EENUM' }
$ENTRY TkEOF { = '/* end of file */' }
$ENTRY TkEntry { = '$ENTRY' }
$ENTRY TkEnum { = '$ENUM' }
$ENTRY TkError { e.Message = '[LEXER ERROR: ' e.Message ']' }
$ENTRY TkExtern { = '$EXTERN' }
$ENTRY TkName { e.Name = e.Name }

$ENTRY TkNumber { s.Number = <Symb s.Number> }

$ENTRY TkOpen {
  Bracket = '(';
  CallBracket = '<';
}

$ENTRY TkOpenBlock { = '{' }
$ENTRY TkReplace { = '=' }
$ENTRY TkSemicolon { = ';' }
$ENTRY TkUnexpected { e.Unexpected = e.Unexpected }
$ENTRY TkVariable { s.Mode e.Index = s.Mode '.' e.Index }

*$EENUM Bracket, CallBracket

Inc2 { s.Num = <Add 2 s.Num>; }

Scan {
  s.Row s.Col ' ' e.Tail = <Scan s.Row <Inc s.Col> e.Tail>;
  s.Row s.Col '\t' e.Tail = <Scan s.Row <Inc s.Col> e.Tail>;
  s.Row s.Col '\n' e.Tail = <Scan <Inc s.Row> 1 e.Tail>;

  /* гарантируется, что в конце файла есть \n, см. lexer_FlatLine */
  s.Row 1 '*$' e.Pseudo '\n' e.Tail =
    <ScanPseudo s.Row 3 () <Type e.Pseudo '\n'>>
    <Scan <Inc s.Row> 1 e.Tail>;

  s.Row 1 '*' e.Comment '\n' e.Tail = <Scan <Inc s.Row> 1 e.Tail>;

  s.Row s.Col '/*' e.Tail = <ScanCComment s.Row <Inc2 s.Col> e.Tail>;

  s.Row s.Col '$' e.Tail =
    <ScanDirective s.Row <Inc s.Col> () <Type e.Tail>>;

  s.Row s.Col '\'' e.Tail = <ScanChars s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col 'e.' e.Tail = <ScanVariable s.Row <Inc2 s.Col> 'e' () <Type e.Tail>>;
  s.Row s.Col 's.' e.Tail = <ScanVariable s.Row <Inc2 s.Col> 's' () <Type e.Tail>>;
  s.Row s.Col 't.' e.Tail = <ScanVariable s.Row <Inc2 s.Col> 't' () <Type e.Tail>>;

  s.Row s.Col '<+' e.Tail =
    (TkOpen (s.Row s.Col) CallBracket) (TkName (s.Row <Inc s.Col>) 'Add')
    <Scan s.Row <Add s.Col 2> e.Tail>;

  s.Row s.Col '<-' e.Tail =
    (TkOpen (s.Row s.Col) CallBracket) (TkName (s.Row <Inc s.Col>) 'Sub')
    <Scan s.Row <Add s.Col 2> e.Tail>;

  s.Row s.Col '<*' e.Tail =
    (TkOpen (s.Row s.Col) CallBracket) (TkName (s.Row <Inc s.Col>) 'Mul')
    <Scan s.Row <Add s.Col 2> e.Tail>;

  s.Row s.Col '</' e.Tail =
    (TkOpen (s.Row s.Col) CallBracket) (TkName (s.Row <Inc s.Col>) 'Div')
    <Scan s.Row <Add s.Col 2> e.Tail>;

  s.Row s.Col '<%' e.Tail =
    (TkOpen (s.Row s.Col) CallBracket) (TkName (s.Row <Inc s.Col>) 'Mod')
    <Scan s.Row <Add s.Col 2> e.Tail>;

  s.Row s.Col s.Next e.Tail =
    <Scan-ByPunctuation s.Row s.Col (<CheckValidPunctuation s.Next>) e.Tail>;

  s.Row s.Col /* пусто */ = (TkEOF (s.Row s.Col));
}

ScanPseudo {
  s.Row s.Col (e.Scanned) 'L' s.SubType s.Letter e.Tail =
    <ScanPseudo s.Row <Inc s.Col> (e.Scanned s.Letter) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) 'D' s.SubType s.Digit e.Tail =
    <ScanPseudo s.Row <Inc s.Col> (e.Scanned s.Digit) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) s.Type s.SubType e.Tail =
    <ScanPseudo-SwDirective s.Row s.Col (<CheckValidDirective e.Scanned>) e.Tail>;
}

ScanPseudo-SwDirective {
  s.Row s.Col (Success s.Directive) e.Tail '\n' =
    (s.Directive (s.Row 2)) <ScanPseudo-SkipEOF <Scan s.Row s.Col e.Tail ';\n'>>;

  s.Row s.Col (Fails e.Directive) e.Tail =
    /* ничего не генерируем, это обычный комментарий */;
}

ScanPseudo-SkipEOF {
  e.Tokens (TkEOF (s.Row s.Col)) = e.Tokens;
}

ScanCComment {
  s.Row s.Col e.Comment '*/' e.Tail =
    <ScanCCommentContent s.Row s.Col (e.Comment '*/') e.Tail>;

  /* Обработка незакрытого комментария */
  s.Row s.Col e.Line '\n' e.Comment = <ScanCComment <Inc s.Row> 1 e.Comment>;

  /* Гарантируется, что в конце потока символов есть \n */
  s.Row s.Col /* пусто */ =
    (TkError (s.Row s.Col) 'EOF in comment')
    (TkEOF (s.Row s.Col));
}

ScanCCommentContent {
  s.Row s.Col ('\n' e.Comment) e.Tail =
    <ScanCCommentContent <Inc s.Row> 1 (e.Comment) e.Tail>;

  s.Row s.Col ('/*' e.Comment) e.Tail =
    (TkError (s.Row s.Col) '"/*" in comments is forbidden')
    <ScanCCommentContent s.Row <Inc2 s.Col> (e.Comment) e.Tail>;

  s.Row s.Col (s.Char e.Comment) e.Tail =
    <ScanCCommentContent s.Row <Inc s.Col> (e.Comment) e.Tail>;

  s.Row s.Col (/* пусто */) e.Tail = <Scan s.Row s.Col e.Tail>;
}

ScanDirective {
  s.Row s.Col (e.Scanned) 'L' s.SubType s.Letter e.Tail =
    <ScanDirective s.Row <Inc s.Col> (e.Scanned s.Letter) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) 'D' s.SubType s.Digit e.Tail =
    <ScanDirective s.Row <Inc s.Col> (e.Scanned s.Digit) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) s.Type s.SubType e.Tail =
    <MakeDirective s.Row s.Col e.Scanned>
    <Scan s.Row s.Col e.Tail>;
}

MakeDirective {
  s.Row s.Col e.Directive =
    <MakeDirective-SwValid s.Row s.Col <CheckValidDirective e.Directive>>;
}

CheckValidDirective {
  'ENUM' = Success TkEnum;
  'EENUM' = Success TkEEnum;
  'ENTRY' = Success TkEntry;
  'EXTERN' = Success TkExtern;
  e.Other = Fails e.Other;
}

MakeDirective-SwValid {
  s.Row s.Col Success s.Directive = (s.Directive (s.Row s.Col));

  s.Row s.Col Fails e.Other =
    (TkError (s.Row s.Col) 'Unknown directive $' e.Other);
}

ScanChars {
  s.Row s.Col '\'' e.Tail = <Scan s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col '\n' e.Tail =
    (TkError (s.Row s.Col) 'unclosed quote')
    <Scan s.Row s.Col '\n' e.Tail>;

  s.Row s.Col '\\' e.Tail =
    <ScanChars-Escape s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col s.Other e.Tail =
    (TkChar (s.Row s.Col) s.Other)
    <ScanChars s.Row <Inc s.Col> e.Tail>;
}

ScanChars-Escape {
  s.Row s.Col 'x' e.Tail =
    <ScanChars-Escape-Hex s.Row <Inc s.Col> () e.Tail>;

  s.Row s.Col s.Next e.Tail =
    <ScanChars-Escape-SwValid s.Row s.Col <CheckValidEscape s.Next> e.Tail>;

  /* Пустой суффикс быть не может, поскольку в конец добавляется \n */
}

ScanChars-Escape-Hex {
  s.Row s.Col (s.H1 s.H2) e.Tail =
    (TkChar (s.Row s.Col) <Chr <Add <Mul s.H1 16> s.H2>>)
    <ScanChars s.Row s.Col e.Tail>;

  s.Row s.Col (e.Digits) s.Next e.Tail =
    <ScanChars-Escape-Hex-SwHex
      s.Row s.Col (e.Digits) <DigitFromChar s.Next> e.Tail
    >;

  /* Пустой суффикс быть не может, поскольку в конец добавляется \n */
}

ScanChars-Escape-Hex-SwHex {
  s.Row s.Col (e.Digits) Fails s.NoDigit e.Tail =
    (TkError (s.Row s.Col) 'bad hex escape sequence "\\x..."')
    <ScanChars s.Row s.Col s.NoDigit e.Tail>;

  s.Row s.Col (e.Digits) s.Digit e.Tail =
    <ScanChars-Escape-Hex s.Row <Inc s.Col> (e.Digits s.Digit) e.Tail>;
}

CheckValidEscape {
  'n' = Success '\n';
  't' = Success '\t';
  'r' = Success '\r';
  '\\' = Success '\\';
  '\'' = Success '\'';
  '"' = Success '"';
  '<' = Success '<';
  '>' = Success '>';
  '(' = Success '(';
  ')' = Success ')';

  s.Other = Fails s.Other;
}

ScanChars-Escape-SwValid {
  s.Row s.Col Success s.Value e.Tail =
    (TkChar (s.Row s.Col) s.Value) <ScanChars s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col Fails s.Other e.Tail =
    (TkError (s.Row s.Col) 'bad escape sequence "\\' s.Other '"')
    <ScanChars s.Row s.Col s.Other e.Tail>;
}

ScanVariable {
  s.Row s.Col s.Mode (e.Index) 'L' s.SubType s.Letter e.Tail =
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index s.Letter) <Type e.Tail>>;

  s.Row s.Col s.Mode (e.Index) 'D' s.SubType s.Digit e.Tail =
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index s.Digit) <Type e.Tail>>;

  s.Row s.Col s.Mode (e.Index) s.Type s.SubType '-' e.Tail =
    /* нормализация */
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index '_') <Type e.Tail>>;

  s.Row s.Col s.Mode (e.Index) s.Type s.SubType '_' e.Tail =
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index '_') <Type e.Tail>>;

  s.Row s.Col s.Mode (/* пусто */) s.Type s.SubType e.Tail =
    (TkError (s.Row s.Col) 'empty index in variable "' s.Mode '."')
    <Scan s.Row s.Col e.Tail>;

  s.Row s.Col s.Mode (e.Index) s.Type s.SubType e.Tail =
    (TkVariable (s.Row s.Col) s.Mode e.Index)
    <Scan s.Row s.Col e.Tail>;
}

CheckValidPunctuation {
  /* упорядочены по ASCII-кодам */
  '(' = Success TkOpen Bracket;
  ')' = Success TkClose Bracket;
  ',' = Success TkComma;
  ';' = Success TkSemicolon;
  '<' = Success TkOpen CallBracket;
  '=' = Success TkReplace;
  '>' = Success TkClose CallBracket;
  '{' = Success TkOpenBlock;
  '}' = Success TkCloseBlock;

  s.Other = Fails s.Other;
}

Scan-ByPunctuation {
  s.Row s.Col (Success s.Token e.Info) e.Tail =
    (s.Token (s.Row s.Col) e.Info) <Scan s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col (Fails s.Other) e.Tail =
    <Scan-ByType s.Row s.Col <Type s.Other e.Tail>>;
}

Scan-ByType {
  s.Row s.Col 'L' s.SubType s.Letter e.Tail =
    <ScanName s.Row s.Col <Inc s.Col> (s.Letter) <Type e.Tail>>;

  s.Row s.Col 'D' s.SubType s.Digit e.Tail =
    <ScanNumber s.Row s.Col <Inc s.Col> (s.Digit) <Type e.Tail>>;

  s.Row s.Col s.Type s.SubType s.Unexpected e.Text =
    <GlueUnexpecteds
      (TkUnexpected (s.Row s.Col) s.Unexpected)
      <Scan s.Row <Inc s.Col> e.Text>
    >;
}

GlueUnexpecteds {
  (TkUnexpected t.SrcPos1 s.Unexpected1) (TkUnexpected t.SrcPos2 e.Unexpected2)
  e.Tokens =
    (TkUnexpected t.SrcPos1 s.Unexpected1 e.Unexpected2) e.Tokens;

  t.Unexpected e.Tokens = t.Unexpected e.Tokens;
}

ScanName {
  s.Row s.StartCol s.Col (e.Name) 'L' s.SubType s.Letter e.Tail =
    <ScanName s.Row s.StartCol <Inc s.Col> (e.Name s.Letter) <Type e.Tail>>;

  s.Row s.StartCol s.Col (e.Name) 'D' s.SubType s.Digit e.Tail =
    <ScanName s.Row s.StartCol <Inc s.Col> (e.Name s.Digit) <Type e.Tail>>;

  s.Row s.StartCol s.Col (e.Name) s.Type s.SubType '-' e.Tail =
    /* нормализация */
    <ScanName s.Row s.StartCol <Inc s.Col> (e.Name '_') <Type e.Tail>>;

  s.Row s.StartCol s.Col (e.Name) s.Type s.SubType '_' e.Tail =
    <ScanName s.Row s.StartCol <Inc s.Col> (e.Name '_') <Type e.Tail>>;

  s.Row s.StartCol s.Col (e.Name) s.Type s.SubType e.Tail =
    (TkName (s.Row s.StartCol) e.Name) <Scan s.Row s.Col e.Tail>;
}

ScanNumber {
  s.Row s.StartCol s.Col (e.Number) 'D' s.SubType s.Digit e.Tail =
    <ScanNumber s.Row s.StartCol <Inc s.Col> (e.Number s.Digit) <Type e.Tail>>;

  s.Row s.StartCol s.Col (e.Number) s.Type s.SubType e.Tail =
    (TkNumber (s.Row s.StartCol) <Numb e.Number>)
    <Scan s.Row s.Col e.Tail>;
}


/**
  <StrFromToken s.TokType e.Info> ::= e.HumanReadableRep
  e.HumanReadableRep ::= s.CHAR*
*/
$ENTRY StrFromToken {
  TkUnexpected e.Unexpected = 'Unexpected characters <' e.Unexpected '>';

  s.Other e.Info = '"' <Mu s.Other e.Info> '"';
}

DigitFromChar {
  s.Digit = <DigitFromChar-Aux s.Digit <HexDigits>>
}

DigitFromChar-Aux {
  s.Digit e.Hex-B (s.Digit s.Value) e.Hex-E = s.Value;
  s.Other e.Hex = Fails s.Other;
}

HexDigits {
  = ('0' 0) ('1' 1) ('2' 2) ('3' 3) ('4' 4)
    ('5' 5) ('6' 6) ('7' 7) ('8' 8) ('9' 9)
    ('A' 10) ('B' 11) ('C' 12) ('D' 13) ('E' 14) ('F' 15)
    ('a' 10) ('b' 11) ('c' 12) ('d' 13) ('e' 14) ('f' 15)
}

/**
  <R05-LexDump e.Tokens> == s.CHAR*
*/
$ENTRY R05-LexDump {
  (s.Tok (s.Row s.Col) e.Info) e.Tokens =
    <DoLexDump s.Row (<Mu s.Tok e.Info>) e.Tokens>;

  /* пусто */ = /* пусто */
}

DoLexDump {
  s.Row (e.Buffer) (s.Tok (s.Row s.Col) e.Info) e.Tokens =
    <DoLexDump
      s.Row (<BufAppend (e.Buffer) <Mu s.Tok e.Info>>) e.Tokens
    >;

  s.Row1 (e.Buffer) (s.Tok (s.Row2 s.Col) e.Info) e.Tokens =
    e.Buffer '\n'
    <DoLexDump s.Row2 (<Mu s.Tok e.Info>) e.Tokens>;

  s.Row (e.Buffer) /* пусто */ = e.Buffer;
}

BufAppend {
  (e.Buffer '\'') '\'' e.CharRep = e.Buffer e.CharRep;

  (e.Buffer '<') e.TokenRep = e.Buffer '<' e.TokenRep;
  (e.Buffer '(') e.TokenRep = e.Buffer '(' e.TokenRep;

  (e.Buffer) ')' = e.Buffer ')';
  (e.Buffer) ',' = e.Buffer ',';
  (e.Buffer) ';' = e.Buffer ';';
  (e.Buffer) '>' = e.Buffer '>';

  (e.Buffer) e.TokenRep = e.Buffer ' ' e.TokenRep;
}
