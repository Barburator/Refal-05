*$FROM LibraryEx
$EXTERN Fetch, Seq, Map, SaveFile, Inc, Dec;

*$FROM Lexer
$EXTERN LexFolding, TkOpenBracket, TkCloseBracket,
  TkOpenCall, TkCloseCall, TkEOF, TkDirective, TkName, TkSemicolon,
  EEnum, Enum, Extern, Entry, TkComma, TkOpenBlock, TkCloseBlock,
  TkVariable, TkReplace, TkChar, TkNumber, TkOpen, TkClose, TkNative;

*$FROM Error
$EXTERN EL-Create, EL-Destroy, EL-NoErrors, EL-HasErrors, EL-AddUnexpected,
  EL-AddErrorAt;

*$FROM SymTable
$EXTERN ST-Create, ST-CheckUnresolved, ST-Destroy, ST-AllFunctions,
  ST-AddDefined, ST-AddDeclared, ST-AddFunctionCall, ST-GetAnyName;

*$FROM Library
$EXTERN Success, Fails, StrFromInt;

*$FROM Generator
$EXTERN GN-Entry, GenExtern, GN-Local, GenForward, GenEnum, GenFnStart,
  GenSentence, GenFnEnd-Success, GenFnEnd, GenNative, GenPostprocess,
  GenThisIsGeneratedFunction;

*$FROM Algorithm
$EXTERN MakeAlgorithm, Brackets, CallBrackets, Symbol, Char, Number, Name;


/**
  <CompileFile (e.SrcName) e.OutputName>
    == Success e.OutputName
    == Fails
*/
$ENTRY CompileFile {
  (e.SrcName) e.OutputName =
    <Fetch
      <LexFolding e.SrcName>
      <Seq
        (Map PrepareBracket)
        (Pass-Lexer (e.SrcName))
        Pass-CheckUnresolved
        (Pass-Final (e.SrcName) (e.OutputName))
      >
    >;
}

PrepareBracket {
  (TkOpenBracket t.SrcPos) = (TkOpen t.SrcPos TkOpenBracket);
  (TkCloseBracket t.SrcPos) = (TkClose t.SrcPos TkCloseBracket);

  (TkOpenCall t.SrcPos) = (TkOpen t.SrcPos TkOpenCall);
  (TkCloseCall t.SrcPos) = (TkClose t.SrcPos TkCloseCall);

  t.OtherToken = t.OtherToken;
}

Pass-Lexer {
  (e.SrcName) e.LexFolding =
    <ParseElements
      <EL-Create e.SrcName> <ST-Create> (/* generated */)
      e.LexFolding
    >;
}

Pass-CheckUnresolved {
  t.ErrorList t.SymTable e.Lines =
    <ST-CheckUnresolved t.ErrorList t.SymTable> e.Lines;
}

Pass-Final {
  (e.SrcName) (e.OutputName) t.ErrorList t.SymTable e.Lines =
    <ST-Destroy t.SymTable>
    <Pass-Final-SwNoErrors
      (e.SrcName) (e.OutputName) e.Lines
      <EL-Destroy t.ErrorList>
    >;
}

Pass-Final-SwNoErrors {
  (e.SrcName) (e.OutputName) e.Lines EL-NoErrors =
    <SaveFile
      (e.OutputName)
      <GenPostprocess (e.SrcName) (e.OutputName) e.Lines>
    >
    Success e.OutputName;

  (e.SrcName) (e.OutputName) e.Lines EL-HasErrors =
    Fails;
}

/*
  Трансляция осуществляется обычным методом рекурсивного спуска.

  TranslationUnit = Element* .

  Element =
    '$ENUM' NameList-Enum |
    '$EENUM' NameList-Enum |
    '$EXTERN' NameList-Extern |
    '$ENTRY' Function |
    Function .

  NameList-Enum = Name ',' NameList-Enum | Name ';' .
  NameList-Extern = Name ',' NameList-Extern | Name ';' .

  Function = Name Block .

  Block = '{' Sentence* '}' .

  Sentence = Pattern '=' Result ';' .

  Pattern = PatternTerm* .

  PatternTerm = CommonTerm |
    '(' Patter ')' | '[' Pattern ']' | RedefinitionVariable .

  RedefinitionVariable = Variable '^' .

  CommonTerm = Char | Number | Name | Variable .

  Result = ResultTerm* .

  ResultTerm = CommonTerm |
    '(' Result ')' | '[' Result ']' | '<' Result '>' | Block .

  Стратегия обработки ошибок. Выделяем только одну функцию, проглатывающую
  неожиданные лексемы. Остальные функции при обнаружении неожиданной лексемы
  должны её оставить в лексической свёртке перейдя в одно из состояний уровнем
  выше. Данная стратегия обработки ошибок может нарушаться, но при этом должно
  выполняться условие, что TkEOF передаётся в ParseElements.
*/

/*
  TranslationUnit = Element* .
*/

/*
  Element =
    '$ENUM' NameList-Enum |
    '$EENUM' NameList-Enum |
    '$EXTERN' NameList-Extern |
    '$ENTRY' Function |
    Function .
*/

ParseElements {
  t.ErrorList t.SymTable (e.Generated) (TkEOF t.SrcPos) =
    t.ErrorList t.SymTable
    <Map GenDeclaration <ST-AllFunctions t.SymTable>>
    ()
    e.Generated;

  t.ErrorList t.SymTable (e.Generated)
  (TkDirective t.SrcPos s.Directive) e.Tail =
    <ParseElements-DirectiveParsed
      (e.Generated)
      <ParseElement-SwDirective
        t.ErrorList t.SymTable s.Directive e.Tail
      >
    >;

  t.ErrorList t.SymTable (e.Generated) (TkName t.SrcPos e.Name) e.Tail =
    <ParseElements-FunctionParsed
      (e.Generated)
      <ParseFunction
        GN-Local (e.Name)
        <ST-AddDefined t.ErrorList t.SymTable GN-Local t.SrcPos e.Name>
        e.Tail
      >
    >;

  t.ErrorList t.SymTable (e.Generated) (TkSemicolon t.SrcPos) e.Tail =
    <ParseElements t.ErrorList t.SymTable (e.Generated) e.Tail>;

  t.ErrorList t.SymTable (e.Generated) (TkNative (s.Row s.Col) e.Code) e.Tail =
    <ParseElements
      t.ErrorList t.SymTable (e.Generated <GenNative s.Row e.Code>) e.Tail
    >;

  t.ErrorList t.SymTable (e.Generated) t.Unexpected e.Tail =
    <ParseElements
      <EL-AddUnexpected t.ErrorList t.Unexpected 'directive or name'>
      t.SymTable (e.Generated) e.Tail
    >;
}

GenDeclaration {
  (GN-Entry e.Name) = <GenExtern e.Name>;
  (GN-Local e.Name) = <GenForward e.Name>;
}

ParseElements-DirectiveParsed {
  (e.Generated) (e.NewGenerated) t.ErrorList t.SymTable e.Tail =
    <ParseElements
      t.ErrorList t.SymTable (e.Generated e.NewGenerated) e.Tail
    >;
}

ParseElements-FunctionParsed {
  (e.Generated) (e.NewGenerated) t.ErrorList t.SymTable e.Tail =
    <ParseElements
      t.ErrorList t.SymTable (e.Generated e.NewGenerated) e.Tail
    >;
}

ScopeClassFromEnumDirective {
  EEnum = GN-Entry;
  Enum  = GN-Local;
}

ParseElement-SwDirective {
  t.ErrorList t.SymTable Entry (TkName t.SrcPos e.Name) e.Tail =
    <ParseFunction
      GN-Entry (e.Name)
      <ST-AddDefined t.ErrorList t.SymTable GN-Entry t.SrcPos e.Name>
      e.Tail
    >;

  t.ErrorList t.SymTable Entry t.Unexpected e.Tail =
    (/* ничего не генерируем */)
    <EL-AddUnexpected t.ErrorList t.Unexpected 'function name'>
    t.SymTable t.Unexpected e.Tail;

  t.ErrorList t.SymTable Extern e.Tail =
    (/* ничего не генерируем */)
    <ParseNameList-Extern t.ErrorList t.SymTable e.Tail>;

  t.ErrorList t.SymTable s.Directive e.Tail =
    <ParseNameList-Enum
      (/* generated */)
      t.ErrorList t.SymTable
      <ScopeClassFromEnumDirective s.Directive>
      e.Tail
    >;
}

/*
  NameList-Enum = Name ',' NameList-Enum | Name ';' .
*/

ParseNameList-Enum {
  (e.Generated)
  t.ErrorList t.SymTable s.ScopeClass
  (TkName t.SrcPos e.Name) e.Tail =
    <ParseNameList-Tail-Enum
      (e.Generated <GenEnum s.ScopeClass e.Name>)
      <ST-AddDefined t.ErrorList t.SymTable s.ScopeClass t.SrcPos e.Name>
      s.ScopeClass
      e.Tail
    >;

  (e.Generated)
  t.ErrorList t.SymTable s.ScopeClass
  t.Unexpected e.Tail =
    (e.Generated)
    <EL-AddUnexpected t.ErrorList t.Unexpected 'function name'>
    t.SymTable t.Unexpected e.Tail;
}

ParseNameList-Tail-Enum {
  (e.Generated)
  t.ErrorList t.SymTable s.ScopeClass
  (TkComma t.SrcPos) e.Tail =
    <ParseNameList-Enum
      (e.Generated)
      t.ErrorList t.SymTable s.ScopeClass e.Tail
    >;

  (e.Generated)
  t.ErrorList t.SymTable s.ScopeClass
  (TkSemicolon t.SrcPos) e.Tail =
    (e.Generated) t.ErrorList t.SymTable e.Tail;

  (e.Generated)
  t.ErrorList t.SymTable s.ScopeClass
  t.Unexpected e.Tail =
    (e.Generated)
    <EL-AddUnexpected t.ErrorList t.Unexpected 'comma or semicolon'>
    t.SymTable t.Unexpected e.Tail;
}

/*
  NameList-Extern = Name ',' NameList-Extern | Name ';' .
*/

ParseNameList-Extern {
  t.ErrorList t.SymTable (TkName t.SrcPos e.Name) e.Tail =
    <ParseNameList-Tail-Extern
      t.ErrorList <ST-AddDeclared t.SymTable e.Name> e.Tail
    >;

  t.ErrorList t.SymTable t.Unexpected e.Tail =
    <EL-AddUnexpected t.ErrorList t.Unexpected 'function name'>
    t.SymTable t.Unexpected e.Tail;
}

ParseNameList-Tail-Extern {
  t.ErrorList t.SymTable (TkComma t.SrcPos) e.Tail =
    <ParseNameList-Extern t.ErrorList t.SymTable e.Tail>;

  t.ErrorList t.SymTable (TkSemicolon t.SrcPos) e.Tail =
    t.ErrorList t.SymTable e.Tail;

  t.ErrorList t.SymTable t.Unexpected e.Tail =
    <EL-AddUnexpected t.ErrorList t.Unexpected 'comma or semicolon'>
    t.SymTable t.Unexpected e.Tail;
}

/*
  Function = Name '{' Sentence* '}'
*/

ParseFunction {
  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  (TkOpenBlock t.SrcPos) e.Tail =
    <ParseFunction-BlockParsed
      s.ScopeClass (e.Name)
      <ParseBlock t.ErrorList t.SymTable e.Tail>
    >;

  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  t.Unexpected e.Tail =
    (/* ничего не сгенерировали */)
    <EL-AddUnexpected t.ErrorList t.Unexpected 'open brace'>
    t.SymTable t.Unexpected e.Tail;
}

$ENUM Sentences, Native;

ParseFunction-BlockParsed {
  s.ScopeClass (e.Name)
  (Sentences e.Sentences) t.ErrorList t.SymTable e.Tail =
    (<GenFunctionBody s.ScopeClass (e.Name) e.Sentences>)
    t.ErrorList t.SymTable e.Tail;

  s.ScopeClass (e.Name)
  (Native s.LineNo e.Code) t.ErrorList t.SymTable e.Tail =
    (
      <GenFnStart s.ScopeClass e.Name>
      <GenNative s.LineNo e.Code>
      <GenFnEnd-Success>
    )
    t.ErrorList t.SymTable e.Tail;
}

GenFunctionBody {
*   Закомментированный код содержит вариант кодогенерации,
*   при котором если последнее предложение имеет вид
*   e.X = ...;, в конце не генерится возврат
*   return RecognitionImpossible;
*
*  s.ScopeClass (e.MainName) (e.Name)
*  e.Sentences (((TkVariable 'e' e.Index)) (e.Result)) =
*    <GenFnStart s.ScopeClass e.Name>
*    <Map
*      <PrepareAndGenSentence e.MainName>
*      e.Sentences
*      (((TkVariable 'e' e.Index)) (e.Result))
*    >
*    <GenFnEnd-Success>;

  s.ScopeClass (e.Name) e.Sentences =
    <GenFnStart s.ScopeClass e.Name>
    <GenThisIsGeneratedFunction>
    <Map MakeAlgorithm-and-GenSentence e.Sentences>
    <GenFnEnd>;
}

MakeAlgorithm-and-GenSentence {
  ((e.Pattern) (e.Result)) =
    <GenSentence
      <MakeAlgorithm (e.Pattern) (e.Result)>
    >;
}

/*
  <ParseBlock t.ErrorList t.SymTable e.Tokens>
    == t.ErrorList t.SymTable e.Tokens

  t.FunctionBody ::= (((e.Pattern) (e.Result))*)

  Открывающая скобка должна отсутствовать во входном потоке.
*/
ParseBlock {
  t.ErrorList t.SymTable (TkNative (s.Row s.Col) e.Code) e.Tail =
    (Native s.Row e.Code)
    <ParseBlock-CloseBlock t.ErrorList t.SymTable e.Tail>;

  t.ErrorList t.SymTable e.Tokens =
    <DoParseBlock
      t.ErrorList t.SymTable (/* sentences */) e.Tokens
    >;
}

ParseBlock-CloseBlock {
  t.ErrorList t.SymTable (TkCloseBlock t.SrcPos) e.Tail =
    t.ErrorList t.SymTable e.Tail;

  t.ErrorList t.SymTable t.Unexpected e.Tail =
    <EL-AddUnexpected t.ErrorList t.Unexpected '"}"'>
    t.SymTable t.Unexpected e.Tail;
}

DoParseBlock {
  t.ErrorList t.SymTable (e.Sentences) (TkCloseBlock t.SrcPos) e.Tail =
    (Sentences e.Sentences) t.ErrorList t.SymTable e.Tail;

  t.ErrorList t.SymTable (e.Sentences) (TkEOF t.SrcPos) e.Tail =
    (Sentences e.Sentences)
    <EL-AddErrorAt
      t.ErrorList t.SrcPos 'Unexpected EOF, expected "}"'
    >
    t.SymTable
    (TkEOF t.SrcPos) e.Tail;

  t.ErrorList t.SymTable (e.Sentences) e.Tokens =
    <DoParseBlock
      <ParseSentence
        t.ErrorList t.SymTable (e.Sentences) e.Tokens
      >
    >;
}

ParseSentence {
  t.ErrorList t.SymTable (e.Sentences) e.Tokens =
    <Fetch
      <ParsePattern
        t.ErrorList t.SymTable (/* пусто */) ( /* мультискобки */ )
        ( /* просканировано */ ) e.Tokens
      >
      <Seq
        ParseSentence-AfterParsePattern
        ParseSentence-ParseResult
        (ParseSentence-AfterParseResult (e.Sentences))
      >
    >;
}

ParseSentence-AfterParsePattern {
  t.ErrorList t.SymTable t.VarTable
  (e.Pattern) (TkReplace t.SrcPos) e.Tokens =
    t.ErrorList t.SymTable t.VarTable
    (e.Pattern) e.Tokens;

  t.ErrorList t.SymTable t.VarTable
  (e.Pattern) (s.NextResultTerm t.SrcPos e.Info) e.Tokens =
    <EL-AddErrorAt
      t.ErrorList t.SrcPos 'Incorrect pattern termination'
    >
    t.SymTable t.VarTable
    (e.Pattern) e.Tokens;
}

ParseSentence-ParseResult {
  t.ErrorList t.SymTable t.VarTable
  (e.Pattern) e.Tokens =
    (e.Pattern)
    <ParseResult
      t.ErrorList t.SymTable t.VarTable
      ( /* мультискобки */ ) ( /* просканировано */ ) e.Tokens
    >;
}

ParseSentence-AfterParseResult {
  (e.Sentences) (e.Pattern)
  t.ErrorList t.SymTable t.VarTable
  (e.Result) (TkSemicolon t.SrcPos) e.Tokens =
    t.ErrorList t.SymTable
    (e.Sentences ((e.Pattern) (e.Result))) e.Tokens;

  (e.Sentences) (e.Pattern)
  t.ErrorList t.SymTable t.VarTable
  (e.Result) (TkCloseBlock t.SrcPos) e.Tokens =
    <EL-AddErrorAt t.ErrorList t.SrcPos 'Missed semicolon'>
    t.SymTable
    (e.Sentences ((e.Pattern) (e.Result)))
    (TkCloseBlock t.SrcPos) e.Tokens;

  (e.Sentences) (e.Pattern)
  t.ErrorList t.SymTable t.VarTable
  (e.Result) t.Unexpected e.Tokens =
    <EL-AddUnexpected t.ErrorList t.Unexpected 'semicolon'>
    t.SymTable
    (e.Sentences ((e.Pattern) (e.Result)))
    t.Unexpected e.Tokens;
}

ParsePattern {
  /* Обработка литералов атомов */

  t.ErrorList t.SymTable t.VarTable (e.MultiBrackets)
  (e.Scanned) (TkChar t.SrcPos s.Char) e.Tail =
    <ParsePattern
      t.ErrorList t.SymTable t.VarTable (e.MultiBrackets)
      (e.Scanned (Symbol Char s.Char)) e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable (e.MultiBrackets)
  (e.Scanned) (TkNumber t.SrcPos s.Number) e.Tail =
    <ParsePattern
      t.ErrorList t.SymTable t.VarTable (e.MultiBrackets)
      (e.Scanned (Symbol Number s.Number)) e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable (e.MultiBrackets)
  (e.Scanned) (TkName t.SrcPos e.Name) e.Tail =
    <ParsePattern
      t.ErrorList <ST-AddFunctionCall t.SymTable t.SrcPos e.Name>
      t.VarTable (e.MultiBrackets)
      (e.Scanned (Symbol Name e.Name)) e.Tail
    >;

  /* Переменные */

  t.ErrorList t.SymTable
  (e.Variables-B (s.Mode e.Index) e.Variables-E)
  (e.MultiBracket)
  (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <ParsePattern
      t.ErrorList t.SymTable
      (e.Variables-B (s.Mode e.Index) e.Variables-E)
      (e.MultiBracket)
      (e.Scanned (TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables) (e.MultiBracket)
  (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <ParsePattern
      t.ErrorList t.SymTable ((s.Mode e.Index) e.Variables) (e.MultiBracket)
      (e.Scanned (TkVariable s.Mode e.Index)) e.Tail
    >;

  /*
    Скобки.

    Стратегия обработки ошибок: если мы встретили "не ту" закрывающую
    скобку, считаем, что "та" была пропущена.
    Если имеем непарную открывающую скобку, считаем,
    что соответствующая скобка была пропущена в конце выражения;
    если имеем непарную закрывающую скобку, считаем её лишней.
  */

  t.ErrorList t.SymTable t.VarTable (e.MultiBracket)
  (e.Scanned) (TkOpen t.SrcPos TkOpenBracket) e.Tail =
    <ParsePattern
      t.ErrorList t.SymTable t.VarTable
      (
        e.MultiBracket
        (Brackets t.SrcPos TkCloseBracket e.Scanned)
      )
      () e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable (e.MultiBracket)
  (e.Scanned)
  (TkOpen t.SrcPos TkOpenCall) e.Tail =
    <ParsePattern
      <EL-AddErrorAt
        t.ErrorList t.SrcPos 'Unexpected call bracket in pattern expression'
      >
      t.SymTable t.VarTable
      (
        e.MultiBracket
        (Brackets t.SrcPos TkCloseCall e.Scanned)
      )
      () e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable
  (
    e.MultiBracket
    (s.BracketsSign t.InnerSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) (TkClose t.CloseSrcPos s.CloseBracket) e.Tail =
    <ParsePattern
      t.ErrorList t.SymTable t.VarTable (e.MultiBracket)
      (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable
  (
    e.MultiBracket
    (s.BracketsSign t.InnerSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) (TkClose t.SrcPos s.OtherCloseBracket) e.Tail =
    <ParsePattern
      <EL-AddErrorAt
        t.ErrorList t.InnerSrcPos
        'Unbalanced bracket "' <StrFromBracket s.BracketsSign> '"'
      >
      t.SymTable t.VarTable (e.MultiBracket)
      (e.Scanned (s.BracketsSign e.InnerScanned))
      (TkClose t.SrcPos s.OtherCloseBracket) e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable ()
  (e.Scanned) (TkClose t.SrcPos s.CloseBracket) e.Tail =
    <ParsePattern
      <EL-AddErrorAt
        t.ErrorList t.SrcPos
        'Unbalanced bracket "' <StrFromBracket s.CloseBracket> '"'
      >
      t.SymTable t.VarTable ()
      (e.Scanned) e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable
  (
    e.MultiBracket
    (s.BracketsSign t.InnerSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) e.Tail =
    <ParsePattern
      <EL-AddErrorAt
        t.ErrorList t.InnerSrcPos
        'Unbalanced bracket "' <StrFromBracket s.BracketsSign> '"'
      >
      t.SymTable t.VarTable (e.MultiBracket)
      (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable ()
  (e.Pattern) e.Tail =
    t.ErrorList t.SymTable t.VarTable
    (e.Pattern)  e.Tail;
}

StrFromBracket {
  TkOpenBracket = '('; TkCloseBracket = ')';
  TkOpenCall = '<'; TkCloseCall = '>';
  Brackets = '(';
  CallBrackets = '<';
}

/*
  <ParseResult
    t.ErrorList t.SymTable t.VarTable
    (e.MultiBracket) (e.Scanned) e.Tail
  >
*/
ParseResult {
  /* Обработка литералов атомов */

  t.ErrorList t.SymTable t.VarTable
  (e.MultiBracket) (e.Scanned) (TkChar t.SrcPos s.Char) e.Tail =
    <ParseResult
      t.ErrorList t.SymTable t.VarTable
      (e.MultiBracket) (e.Scanned (Symbol Char s.Char)) e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable
  (e.MultiBracket) (e.Scanned) (TkNumber t.SrcPos s.Number) e.Tail =
    <ParseResult
      t.ErrorList t.SymTable t.VarTable
      (e.MultiBracket) (e.Scanned (Symbol Number s.Number)) e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable
  (e.MultiBracket) (e.Scanned) (TkName t.SrcPos e.Name) e.Tail =
    <ParseResult
      t.ErrorList <ST-AddFunctionCall t.SymTable t.SrcPos e.Name>
      t.VarTable
      (e.MultiBracket) (e.Scanned (Symbol Name e.Name)) e.Tail
    >;

  /* Переменные */

  t.ErrorList t.SymTable (e.Variables-B (s.Mode e.Index) e.Variables-E)
  (e.MultiBracket) (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <ParseResult
      t.ErrorList t.SymTable (e.Variables-B (s.Mode e.Index) e.Variables-E)
      (e.MultiBracket) (e.Scanned (TkVariable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  (e.MultiBracket) (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <ParseResult
      <EL-AddErrorAt
        t.ErrorList t.SrcPos 'Variable ' s.Mode '.' e.Index ' not found'
      >
      t.SymTable (e.Variables) (e.MultiBracket) (e.Scanned) e.Tail
    >;

  /*
    Скобки.

    Стратегия обработки ошибок: если мы встретили "не ту"
    закрывающую скобку, считаем, что "та" была пропущена.
    Если имеем непарную открывающую скобку, считаем,
    что соответствующая скобка была пропущена в конце выражения;
    если имеем непарную закрывающую скобку, считаем её лишней.
  */

  /* Структурные и угловые скобки обрабатываются одинаково */
  t.ErrorList t.SymTable t.VarTable
  (e.MultiBracket) (e.Scanned) (TkOpen t.SrcPos s.OpenBracket) e.Tail =
    <ParseResult
      t.ErrorList t.SymTable t.VarTable
      (
        e.MultiBracket
        (
          <BracketPairName s.OpenBracket>
          t.SrcPos
          <CloseBracketName s.OpenBracket>
          e.Scanned
        )
      )
      () e.Tail
    >;

  /* Правильная закрывающая скобка */
  t.ErrorList t.SymTable t.VarTable
  (
    e.MultiBracket
    (s.BracketsSign t.OpenSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) (TkClose t.SrcPos s.CloseBracket) e.Tail =
    <ParseResult
      t.ErrorList t.SymTable t.VarTable
      (e.MultiBracket) (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  /* Неправильная закрывающая скобка или закрывающая скобка отсутствует */
  t.ErrorList t.SymTable t.VarTable
  (
    e.MultiBracket
    (s.BracketsSign t.OpenSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) e.Tail =
    <ParseResult
      <EL-AddErrorAt
        t.ErrorList t.OpenSrcPos
        'Unbalanced bracket "' <StrFromBracket s.BracketsSign> '"'
      >
      t.SymTable t.VarTable
      (e.MultiBracket) (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable
  () (e.Scanned) (TkClose t.SrcPos s.CloseBracket) e.Tail =
    <ParseResult
      <EL-AddErrorAt
        t.ErrorList t.SrcPos
        'Unbalanced bracket "' <StrFromBracket s.CloseBracket> '"'
      >
      t.SymTable t.VarTable
      () (e.Scanned) e.Tail
    >;

  t.ErrorList t.SymTable t.VarTable
  () (e.Result) e.Tail =
    t.ErrorList t.SymTable t.VarTable
    (e.Result) e.Tail;
}

BracketPairName {
  TkOpenBracket = Brackets;
  TkOpenCall = CallBrackets;
}

CloseBracketName {
  TkOpenBracket = TkCloseBracket;
  TkOpenCall = TkCloseCall;
}
