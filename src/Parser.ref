*$FROM Error
$EXTERN EL-Create, EL-Destroy, EL-AddUnexpected, EL-AddErrorAt;

*$FROM SymTable
$EXTERN ST-Create, ST-AddUnresolveds, ST-AllExterns, ST-AddDefined,
  ST-AddDeclared, ST-AddFunctionCall;

*$FROM Lexer
$EXTERN LexFolding, TkEOF, TkExtern, TkEnum, TkEEnum, TkEntry, TkName,
  TkSemicolon, TkNative, TkComma, TkOpenBlock, TkCloseBlock, TkChar, TkNumber,
  TkVariable, TkOpen, Bracket, CallBracket, TkClose, TkReplace;

*$FROM LibraryEx
$EXTERN Success, Fails, Map;

*$FROM R05-AST
$EXTERN Extern, Local, Entry, Native, Function, Sentences, Symbol, Char, Number,
  Name, Variable, Brackets, CallBrackets;


/**
  <R05-Parse e.SourceFile>
    == Success e.Tree
    == Fails e.Errors
*/
$ENTRY R05-Parse {
  e.SourceFile =
    <R05-Parse-Aux
      <SemanticCheck
        <ParseElements
          <EL-Create> <ST-Create>
          (/* строчки сгенерированного кода */)
          <LexFolding e.SourceFile>
        >
      >
    >
}

R05-Parse-Aux {
  t.ErrorList e.Tree =
    <R05-Parse-SwErrors (<EL-Destroy t.ErrorList>) e.Tree>;
}

R05-Parse-SwErrors {
  (/* no errors */) e.Tree = Success e.Tree;

  (e.Errors) e.Tree = Fails <SortErrors e.Errors>;
}

SortErrors {
  e.Errors = <DoSortErrors (/* sorted */) e.Errors>;
}

DoSortErrors {
  (e.Sorted) /* unsorted */ = e.Sorted;

  (e.Sorted) t.Next e.Unsorted =
    <DoSortErrors
      (<SortErrors-Insert e.Sorted t.Next>)
      e.Unsorted
    >;
}

SortErrors-Insert {
  /* пусто */ t.Next = t.Next;

  e.Sorted t.Great t.Next =
    <SortErrors-Insert-Compare
      e.Sorted t.Great t.Next <CompareError t.Great t.Next>
    >;
}

SortErrors-Insert-Compare {
  e.Sorted t.Great t.Next '+' = <SortErrors-Insert e.Sorted t.Next> t.Great;
  e.Sorted t.Great t.Next s.Other = e.Sorted t.Great t.Next;
}

CompareError {
  ((s.Row s.Col1) e.Message1) ((s.Row s.Col2) e.Message2) =
    <Compare s.Col1 s.Col2>;

  ((s.Row1 s.Col1) e.Message1) ((s.Row2 s.Col2) e.Message2) =
    <Compare s.Row1 s.Row2>;
}


/*
  Трансляция осуществляется обычным методом рекурсивного спуска.

  TranslationUnit = Element* .

  Element =
    '$ENUM' NameList |
    '$EENUM' NameList |
    '$EXTERN' NameList |
    '$ENTRY' Function |
    Function .

  NameList = Name ',' NameList | Name ';' .

  Function = Name Block .

  Block = '{' Sentence* '}' .

  Sentence = Pattern '=' Result ';' .

  Pattern = PatternTerm* .

  PatternTerm = CommonTerm | '(' Pattern ')' | .

  CommonTerm = Char | Number | Name | Variable .

  Result = ResultTerm* .

  ResultTerm = CommonTerm | '(' Result ')' | '<' Result '>' .

  Стратегия обработки ошибок. Выделяем только одну функцию, проглатывающую
  неожиданные лексемы. Остальные функции при обнаружении неожиданной лексемы
  должны её оставить в лексической свёртке перейдя в одно из состояний уровнем
  выше. Данная стратегия обработки ошибок может нарушаться, но при этом должно
  выполняться условие, что TkEOF передаётся в ParseElements.
*/

/*
  TranslationUnit = Element* .
*/

/*
  Element =
    '$ENUM' NameList |
    '$EENUM' NameList |
    '$EXTERN' NameList |
    '$ENTRY' Function |
    Function .
*/

$ENTRY parser_MakeExtern {
  (e.Name) = (Extern e.Name);
}

ParseElements {
  t.ErrorList t.SymTable (e.Generated) (TkEOF t.SrcPos) =
    t.ErrorList t.SymTable
    <Map parser_MakeExtern <ST-AllExterns t.SymTable>>
    e.Generated;

  t.ErrorList t.SymTable (e.Generated)
  (TkExtern t.SrcPos) e.Tail =
    <ParseElements-ElementParsed
      (e.Generated)
      <ParseNameList
        (/* generated */) t.ErrorList t.SymTable
        AddDeclaredWrapper MakeExtern Entry e.Tail
      >
    >;

  t.ErrorList t.SymTable (e.Generated)
  (TkEnum t.SrcPos) e.Tail =
    <ParseElements-ElementParsed
      (e.Generated)
      <ParseNameList
        (/* generated */) t.ErrorList t.SymTable
        ST-AddDefined MakeEnum Local e.Tail
      >
    >;

  t.ErrorList t.SymTable (e.Generated)
  (TkEEnum t.SrcPos) e.Tail =
    <ParseElements-ElementParsed
      (e.Generated)
      <ParseNameList
        (/* generated */) t.ErrorList t.SymTable
        ST-AddDefined MakeEnum Entry e.Tail
      >
    >;

  t.ErrorList t.SymTable (e.Generated)
  (TkEntry t.EntrySrcPos) (TkName t.NameSrcPos e.Name) e.Tail =
    <ParseElements-ElementParsed
      (e.Generated)
      <ParseFunction
        Entry (e.Name)
        <ST-AddDefined t.ErrorList t.SymTable Entry t.NameSrcPos e.Name>
        e.Tail
      >
    >;

  t.ErrorList t.SymTable (e.Generated)
  (TkEntry t.EntrySrcPos) t.Unexpected e.Tail =
    <ParseElements
      <EL-AddUnexpected t.ErrorList t.Unexpected 'function name'>
      t.SymTable (e.Generated) t.Unexpected e.Tail
    >;

  t.ErrorList t.SymTable (e.Generated) (TkName t.SrcPos e.Name) e.Tail =
    <ParseElements-ElementParsed
      (e.Generated)
      <ParseFunction
        Local (e.Name)
        <ST-AddDefined t.ErrorList t.SymTable Local t.SrcPos e.Name>
        e.Tail
      >
    >;

  t.ErrorList t.SymTable (e.Generated) (TkSemicolon t.SrcPos) e.Tail =
    <ParseElements t.ErrorList t.SymTable (e.Generated) e.Tail>;

  t.ErrorList t.SymTable (e.Generated) (TkNative t.SrcPos e.Native) e.Tail =
    <ParseElements
      t.ErrorList t.SymTable (e.Generated (Native e.Native)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Generated) t.Unexpected e.Tail =
    <ParseElements
      <EL-AddUnexpected t.ErrorList t.Unexpected 'directive or name'>
      t.SymTable (e.Generated) e.Tail
    >;
}

MakeExtern {
  s.ScopeClass e.Name = /* (Extern e.Name) */;
}

AddDeclaredWrapper {
  t.ErrorList t.SymTable s.ScopeClass t.SrcPos e.Name =
    t.ErrorList <ST-AddDeclared t.SymTable e.Name>;
}

MakeEnum {
  s.ScopeClass e.Name = (Function s.ScopeClass (e.Name) Sentences /* пусто */);
}

ParseElements-ElementParsed {
  (e.Generated) (e.NewGenerated) t.ErrorList t.SymTable e.Tail =
    <ParseElements
      t.ErrorList t.SymTable (e.Generated e.NewGenerated) e.Tail
    >;
}

/*
  NameList = Name ',' NameList | Name ';' .
*/

ParseNameList {
  (e.Generated) t.ErrorList t.SymTable
  s.FnRegister s.FnMake s.ScopeClass (TkName t.SrcPos e.Name) e.Tail =
    <ParseNameList-Tail
      (e.Generated <Mu s.FnMake s.ScopeClass e.Name>)
      <Mu s.FnRegister t.ErrorList t.SymTable s.ScopeClass t.SrcPos e.Name>
      s.FnRegister s.FnMake s.ScopeClass e.Tail
    >;

  (e.Generated) t.ErrorList t.SymTable
  s.FnRegister s.FnMake s.ScopeClass t.Unexpected e.Tail =
    (e.Generated)
    <EL-AddUnexpected t.ErrorList t.Unexpected 'function name'>
    t.SymTable t.Unexpected e.Tail;
}

ParseNameList-Tail {
  (e.Generated) t.ErrorList t.SymTable
  s.FnRegister s.FnMake s.ScopeClass (TkComma t.SrcPos) e.Tail =
    <ParseNameList
      (e.Generated) t.ErrorList t.SymTable
      s.FnRegister s.FnMake s.ScopeClass e.Tail
    >;

  (e.Generated) t.ErrorList t.SymTable
  s.FnRegister s.FnMake s.ScopeClass (TkSemicolon t.SrcPos) e.Tail =
    (e.Generated) t.ErrorList t.SymTable e.Tail;

  (e.Generated) t.ErrorList t.SymTable
  s.FnRegister s.FnMake s.ScopeClass t.Unexpected e.Tail =
    (e.Generated)
    <EL-AddUnexpected t.ErrorList t.Unexpected 'comma or semicolon'>
    t.SymTable t.Unexpected e.Tail;
}

/*
  Function = Name '{' Sentence* '}'
*/

ParseFunction {
  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  (TkOpenBlock t.SrcPos) e.Tail =
    <ParseFunction-BlockParsed
      s.ScopeClass (e.Name)
      <ParseBlock t.ErrorList t.SymTable e.Tail>
    >;

  s.ScopeClass (e.Name) t.ErrorList t.SymTable
  t.Unexpected e.Tail =
    (/* ничего не сгенерировали */)
    <EL-AddUnexpected t.ErrorList t.Unexpected 'open brace'>
    t.SymTable t.Unexpected e.Tail;
}

ParseFunction-BlockParsed {
  s.ScopeClass (e.Name) (e.Body) t.ErrorList t.SymTable e.Tail =
    ((Function s.ScopeClass (e.Name) e.Body))
    t.ErrorList t.SymTable e.Tail;
}

/*
  <ParseBlock t.ErrorList t.SymTable e.Tokens>
    == t.ErrorList t.SymTable e.Tokens

  t.FunctionBody ::= (((e.Pattern) (e.Result))*)

  Открывающая скобка должна отсутствовать во входном потоке.
*/
ParseBlock {
  t.ErrorList t.SymTable (TkNative t.SrcPos e.Native) e.Tail =
    (Native e.Native)
    <ParseBlock-CloseBlock t.ErrorList t.SymTable e.Tail>;

  t.ErrorList t.SymTable e.Tokens =
    <DoParseBlock
      t.ErrorList t.SymTable (/* sentences */) e.Tokens
    >;
}

ParseBlock-CloseBlock {
  t.ErrorList t.SymTable (TkCloseBlock t.SrcPos) e.Tail =
    t.ErrorList t.SymTable e.Tail;

  t.ErrorList t.SymTable t.Unexpected e.Tail =
    <EL-AddUnexpected t.ErrorList t.Unexpected '"}"'>
    t.SymTable t.Unexpected e.Tail;
}

DoParseBlock {
  t.ErrorList t.SymTable (e.Sentences) (TkCloseBlock t.SrcPos) e.Tail =
    (Sentences e.Sentences) t.ErrorList t.SymTable e.Tail;

  t.ErrorList t.SymTable (e.Sentences) (TkEOF t.SrcPos) e.Tail =
    (Sentences e.Sentences)
    <EL-AddErrorAt
      t.ErrorList t.SrcPos 'Unexpected EOF, expected "}"'
    >
    t.SymTable
    (TkEOF t.SrcPos) e.Tail;

  t.ErrorList t.SymTable (e.Sentences) e.Tokens =
    <ParseSentence t.ErrorList t.SymTable (e.Sentences) e.Tokens>;
}

ParseSentence {
  t.ErrorList t.SymTable (e.Sentences) e.Tokens =
    <ParseSentence-Aux
      (e.Sentences)
      <ParsePattern t.ErrorList t.SymTable e.Tokens>
    >;
}

ParseSentence-Aux {
  (e.Sentences) (e.Pattern) (e.Result)
  t.ErrorList t.SymTable (TkSemicolon t.SrcPos) e.Tokens =
    <DoParseBlock
      t.ErrorList t.SymTable (e.Sentences ((e.Pattern) (e.Result))) e.Tokens
    >;

  (e.Sentences) (e.Pattern) (e.Result)
  t.ErrorList t.SymTable (TkCloseBlock t.SrcPos) e.Tokens =
    (Sentences e.Sentences ((e.Pattern) (e.Result)))
    t.ErrorList t.SymTable e.Tokens;

  (e.Sentences) (e.Pattern) (e.Result)
  t.ErrorList t.SymTable t.Unexpected e.Tokens =
    (Sentences e.Sentences ((e.Pattern) (e.Result)))
    <EL-AddUnexpected t.ErrorList t.Unexpected '"=" or ";"'>
    t.SymTable t.Unexpected e.Tokens;
}

ParsePattern {
  t.ErrorList t.SymTable e.Tokens =
    <DoParsePattern
      t.ErrorList t.SymTable (/* таблица переменных */) (/* мультискобки */)
      (/* просканировано */) e.Tokens
    >;
}

DoParsePattern {
  /* Обработка литералов атомов */

  t.ErrorList t.SymTable (e.Variables) (e.MultiBrackets)
  (e.Scanned) (TkChar t.SrcPos s.Char) e.Tail =
    <DoParsePattern
      t.ErrorList t.SymTable (e.Variables) (e.MultiBrackets)
      (e.Scanned (Symbol Char s.Char)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables) (e.MultiBrackets)
  (e.Scanned) (TkNumber t.SrcPos s.Number) e.Tail =
    <DoParsePattern
      t.ErrorList t.SymTable (e.Variables) (e.MultiBrackets)
      (e.Scanned (Symbol Number s.Number)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables) (e.MultiBrackets)
  (e.Scanned) (TkName t.SrcPos e.Name) e.Tail =
    <DoParsePattern
      t.ErrorList <ST-AddFunctionCall t.SymTable t.SrcPos e.Name>
      (e.Variables) (e.MultiBrackets)
      (e.Scanned (Symbol Name e.Name)) e.Tail
    >;

  /* Переменные */

  t.ErrorList t.SymTable
  (e.Variables-B (s.Mode e.Index) e.Variables-E)
  (e.MultiBracket)
  (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <DoParsePattern
      t.ErrorList t.SymTable
      (e.Variables-B (s.Mode e.Index) e.Variables-E)
      (e.MultiBracket)
      (e.Scanned (Variable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables) (e.MultiBracket)
  (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <DoParsePattern
      t.ErrorList t.SymTable ((s.Mode e.Index) e.Variables) (e.MultiBracket)
      (e.Scanned (Variable s.Mode e.Index)) e.Tail
    >;

  /*
    Скобки.

    Стратегия обработки ошибок: если мы встретили "не ту" закрывающую
    скобку, считаем, что "та" была пропущена.
    Если имеем непарную открывающую скобку, считаем,
    что соответствующая скобка была пропущена в конце выражения;
    если имеем непарную закрывающую скобку, считаем её лишней.
  */

  t.ErrorList t.SymTable (e.Variables) (e.MultiBracket)
  (e.Scanned) (TkOpen t.SrcPos Bracket) e.Tail =
    <DoParsePattern
      t.ErrorList t.SymTable (e.Variables)
      (
        e.MultiBracket
        (Brackets t.SrcPos Bracket e.Scanned)
      )
      () e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables) (e.MultiBracket)
  (e.Scanned) (TkOpen t.SrcPos CallBracket) e.Tail =
    <DoParsePattern
      <EL-AddErrorAt
        t.ErrorList t.SrcPos 'Unexpected call bracket in pattern expression'
      >
      t.SymTable (e.Variables)
      (
        e.MultiBracket
        (Brackets t.SrcPos CallBracket e.Scanned)
      )
      () e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  (
    e.MultiBracket
    (s.BracketsSign t.InnerSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) (TkClose t.CloseSrcPos s.CloseBracket) e.Tail =
    <DoParsePattern
      t.ErrorList t.SymTable (e.Variables) (e.MultiBracket)
      (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  (
    e.MultiBracket
    (s.BracketsSign t.InnerSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) (TkClose t.SrcPos s.OtherCloseBracket) e.Tail =
    <DoParsePattern
      <EL-AddErrorAt
        t.ErrorList t.InnerSrcPos
        'Unbalanced bracket "' <StrFromBracket s.BracketsSign> '"'
      >
      t.SymTable (e.Variables) (e.MultiBracket)
      (e.Scanned (s.BracketsSign e.InnerScanned))
      (TkClose t.SrcPos s.OtherCloseBracket) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables) ()
  (e.Scanned) (TkClose t.SrcPos s.CloseBracket) e.Tail =
    <DoParsePattern
      <EL-AddErrorAt
        t.ErrorList t.SrcPos
        'Unbalanced bracket "' <StrFromBracket s.CloseBracket> '"'
      >
      t.SymTable (e.Variables) ()
      (e.Scanned) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  (
    e.MultiBracket
    (s.BracketsSign t.InnerSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) e.Tail =
    <DoParsePattern
      <EL-AddErrorAt
        t.ErrorList t.InnerSrcPos
        'Unbalanced bracket "' <StrFromBracket s.BracketsSign> '"'
      >
      t.SymTable (e.Variables) (e.MultiBracket)
      (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables) ()
  (e.Pattern) e.Tail =
    /* Выбрасываем образец из рекурсивого вызова */
    (e.Pattern)
    <ParsePattern-ExpectReplace
      t.ErrorList t.SymTable (e.Variables) e.Tail
    >;
}

StrFromBracket {
  Bracket = ')';
  CallBracket = '>';
  Brackets = '(';
  CallBrackets = '<';
}

ParsePattern-ExpectReplace {
  t.ErrorList t.SymTable (e.Variables) (TkReplace t.SrcPos) e.Tokens =
    <ParseResult
      t.ErrorList t.SymTable (e.Variables) e.Tokens
    >;

  t.ErrorList t.SymTable (e.Variables) t.Unexpected e.Tokens =
    <ParseResult
      <EL-AddUnexpected t.ErrorList t.Unexpected '"="'>
      t.SymTable (e.Variables) t.Unexpected e.Tokens
    >;
}

ParseResult {
  t.ErrorList t.SymTable (e.Variables) e.Tokens =
    <DoParseResult
      t.ErrorList t.SymTable (e.Variables)
      (/* мультискобки */) (/* просканировано */) e.Tokens
    >;
}

/*
  <DoParseResult
    t.ErrorList t.SymTable (e.Variables)
    (e.MultiBracket) (e.Scanned) e.Tail
  >
*/
DoParseResult {
  /* Обработка литералов атомов */

  t.ErrorList t.SymTable (e.Variables)
  (e.MultiBracket) (e.Scanned) (TkChar t.SrcPos s.Char) e.Tail =
    <DoParseResult
      t.ErrorList t.SymTable (e.Variables)
      (e.MultiBracket) (e.Scanned (Symbol Char s.Char)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  (e.MultiBracket) (e.Scanned) (TkNumber t.SrcPos s.Number) e.Tail =
    <DoParseResult
      t.ErrorList t.SymTable (e.Variables)
      (e.MultiBracket) (e.Scanned (Symbol Number s.Number)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  (e.MultiBracket) (e.Scanned) (TkName t.SrcPos e.Name) e.Tail =
    <DoParseResult
      t.ErrorList <ST-AddFunctionCall t.SymTable t.SrcPos e.Name>
      (e.Variables)
      (e.MultiBracket) (e.Scanned (Symbol Name e.Name)) e.Tail
    >;

  /* Переменные */

  t.ErrorList t.SymTable (e.Variables-B (s.Mode e.Index) e.Variables-E)
  (e.MultiBracket) (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <DoParseResult
      t.ErrorList t.SymTable (e.Variables-B (s.Mode e.Index) e.Variables-E)
      (e.MultiBracket) (e.Scanned (Variable s.Mode e.Index)) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  (e.MultiBracket) (e.Scanned) (TkVariable t.SrcPos s.Mode e.Index) e.Tail =
    <DoParseResult
      <EL-AddErrorAt
        t.ErrorList t.SrcPos 'Variable ' s.Mode '.' e.Index ' not found'
      >
      t.SymTable (e.Variables) (e.MultiBracket) (e.Scanned) e.Tail
    >;

  /*
    Скобки.

    Стратегия обработки ошибок: если мы встретили "не ту"
    закрывающую скобку, считаем, что "та" была пропущена.
    Если имеем непарную открывающую скобку, считаем,
    что соответствующая скобка была пропущена в конце выражения;
    если имеем непарную закрывающую скобку, считаем её лишней.
  */

  /* Структурные и угловые скобки обрабатываются одинаково */
  t.ErrorList t.SymTable (e.Variables)
  (e.MultiBracket) (e.Scanned) (TkOpen t.SrcPos s.OpenBracket) e.Tail =
    <DoParseResult
      t.ErrorList t.SymTable (e.Variables)
      (
        e.MultiBracket
        (
          <BracketPairName s.OpenBracket>
          t.SrcPos
          s.OpenBracket
          e.Scanned
        )
      )
      () e.Tail
    >;

  /* Правильная закрывающая скобка */
  t.ErrorList t.SymTable (e.Variables)
  (
    e.MultiBracket
    (s.BracketsSign t.OpenSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) (TkClose t.SrcPos s.CloseBracket) e.Tail =
    <DoParseResult
      t.ErrorList t.SymTable (e.Variables)
      (e.MultiBracket) (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  /* Неправильная закрывающая скобка или закрывающая скобка отсутствует */
  t.ErrorList t.SymTable (e.Variables)
  (
    e.MultiBracket
    (s.BracketsSign t.OpenSrcPos s.CloseBracket e.Scanned)
  )
  (e.InnerScanned) e.Tail =
    <DoParseResult
      <EL-AddErrorAt
        t.ErrorList t.OpenSrcPos
        'Unbalanced bracket "' <StrFromBracket s.BracketsSign> '"'
      >
      t.SymTable (e.Variables)
      (e.MultiBracket) (e.Scanned (s.BracketsSign e.InnerScanned))
      e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  () (e.Scanned) (TkClose t.SrcPos s.CloseBracket) e.Tail =
    <DoParseResult
      <EL-AddErrorAt
        t.ErrorList t.SrcPos
        'Unbalanced bracket "' <StrFromBracket s.CloseBracket> '"'
      >
      t.SymTable (e.Variables)
      () (e.Scanned) e.Tail
    >;

  t.ErrorList t.SymTable (e.Variables)
  () (e.Result) e.Tail =
    (e.Result) t.ErrorList t.SymTable e.Tail;
}

BracketPairName {
  Bracket = Brackets;
  CallBracket = CallBrackets;
}


SemanticCheck {
  t.ErrorList t.SymTable e.Tree =
    <ST-AddUnresolveds t.ErrorList t.SymTable> e.Tree;
}
