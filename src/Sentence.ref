*$FROM LibraryEx
$EXTERN Inc, Dec, Map;

*$FROM Escape
$EXTERN EscapeChar;

*$FROM R05-AST
$EXTERN TextFromExpr, Symbol, Brackets, Variable, Char, CallBrackets;


$ENTRY CompileSentence {
  (e.Pattern) (e.Result) =
    <CompileSentence-Aux <GenPattern e.Pattern> e.Result>;
}

CompileSentence-Aux {
  s.NumRanges (e.PatternVars) (e.PatternCommands) e.Result =
    <ComposeSentenceCommands
      s.NumRanges (e.PatternVars) (e.PatternCommands)
      <GenResult (e.PatternVars) e.Result>
    >;
}

/*
  e.Vars ::= (s.Count s.Mode e.Index)*
*/

*===============================================================================
* Генерация образца
*===============================================================================

* Направление распознавания
*$EENUM AlgLeft, AlgRight

/*
Команды распознавания
  Символы, скобки, повторные переменные и s-, t-переменные:
    (CmdMatch s.Direction s.BracketNum s.MatchType e.MatchValue)

    s.Direction ::= AlgLeft | AlgRight

    s.MatchType e.MatchValue ::=
        Symbol Char s.Char
      | Symbol Number s.Number
      | Symbol Name e.Name
      | Brackets s.InnerNum
      | Repeated s.Usings s.Mode e.Index
      | Variable s.Mode e.Index

  Пустые скобки:
    (CmdEmpty s.BracketNum),

  Открытые e-переменные до обработки:
    (CmdOpenedE s.BracketNum 'e' e.Index)

  Открытые e-переменные после обработки:
    (CmdOpenedE-Start s.BracketNum 'e' e.Index)
    (CmdOpenedE-End s.BracketNum 'e' e.Index)

  Закрытые e-переменные:
    (CmdClosedE s.BracketNum 'e' e.Index)

  Команды сохранения скобок:
    (CmdSave s.OldNumber e.NewNumber)

  Комментарий, вносимый в исходный код:
    (CmdComment e.Text)
*/
*$EENUM CmdMatch, Repeated, CmdEmpty, CmdClosedE
*$EENUM CmdOpenedE-Start, CmdOpenedE-End
*$EENUM CmdComment, CmdSave

*$ENUM CmdOpenedE

GenPattern {
  e.Pattern =
    <DoGenPattern
      1 (0 e.Pattern) (/* vars */)
      (
        (CmdComment <TextFromExpr e.Pattern>)
        /* commands */
      )
    >;
}

DoGenPattern {
  /* Распознавание литералов (символьных, целочисленных, имён) */
  s.NumRanges e.Ranges-B (s.Num (Symbol s.Type e.Value) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgLeft s.Num Symbol s.Type e.Value))
    >;

  s.NumRanges e.Ranges-B (s.Num e.Range (Symbol s.Type e.Value)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgRight s.Num Symbol s.Type e.Value))
    >;

  /* Распознавание скобок */
  s.NumRanges e.Ranges-B
  (s.Num (Brackets e.SubRange) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.NumRanges>
      e.Ranges-B (s.NumRanges e.SubRange) (s.Num e.Range) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgLeft s.Num Brackets s.NumRanges))
    >;

  s.NumRanges e.Ranges-B
  (s.Num e.Range (Brackets e.SubRange))
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.NumRanges>
      e.Ranges-B (s.Num e.Range) (s.NumRanges e.SubRange) e.Ranges-E
      (e.Vars) (e.Commands (CmdMatch AlgRight s.Num Brackets s.NumRanges))
    >;

  /* Пустой диапазон */
  s.NumRanges e.Ranges-B (s.Num /* пусто */) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B e.Ranges-E
      (e.Vars) (e.Commands (CmdEmpty s.Num))
    >;

  /* Распознавание переменных */
  s.NumRanges e.Ranges-B (s.Num (Variable s.Mode e.Index) e.Range) e.Ranges-E
  (e.Vars-B (s.Count s.Mode e.Index) e.Vars-E) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars-B (<Inc s.Count> s.Mode e.Index) e.Vars-E)
      (e.Commands (CmdMatch AlgLeft s.Num Repeated <Inc s.Count> s.Mode e.Index))
    >;

  s.NumRanges e.Ranges-B (s.Num e.Range (Variable s.Mode e.Index)) e.Ranges-E
  (e.Vars-B (s.Count s.Mode e.Index) e.Vars-E) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars-B (<Inc s.Count> s.Mode e.Index) e.Vars-E)
      (e.Commands (CmdMatch AlgRight s.Num Repeated <Inc s.Count> s.Mode e.Index))
    >;

  /* Диапазон с закрытой переменной */
  s.NumRanges e.Ranges-B (s.Num (Variable 'e' e.Index)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B e.Ranges-E
      (e.Vars (1 'e' e.Index))
      (e.Commands (CmdClosedE s.Num 'e' e.Index))
    >;

  s.NumRanges e.Ranges-B (s.Num (Variable 's' e.Index) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 's' e.Index))
      (e.Commands (CmdMatch AlgLeft s.Num Variable 's' e.Index))
    >;

  s.NumRanges e.Ranges-B (s.Num (Variable 't' e.Index) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 't' e.Index))
      (e.Commands (CmdMatch AlgLeft s.Num Variable 't' e.Index))
    >;

  s.NumRanges e.Ranges-B (s.Num e.Range (Variable 's' e.Index)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 's' e.Index))
      (e.Commands (CmdMatch AlgRight s.Num Variable 's' e.Index))
    >;

  s.NumRanges e.Ranges-B (s.Num e.Range (Variable 't' e.Index)) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.NumRanges e.Ranges-B (s.Num e.Range) e.Ranges-E
      (e.Vars (1 't' e.Index))
      (e.Commands (CmdMatch AlgRight s.Num Variable 't' e.Index))
    >;

  s.NumRanges e.Ranges-B (s.Num (Variable 'e' e.Index) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <SaveRanges
        s.NumRanges (/* scanned */) e.Ranges-B (s.Num e.Range) e.Ranges-E
        (e.Vars (1 'e' e.Index))
        (e.Commands (CmdOpenedE s.Num 'e' e.Index))
      >
    >;

  /* Завершение разбора. */
  s.NumRanges /* пусто */ (e.Vars) (e.Commands) =
    s.NumRanges (e.Vars) (e.Commands);
}

SaveRanges {
  s.NumRanges (e.ScannedRanges) (s.Num e.Range) e.Ranges
  (e.Vars) (e.Commands) =
    <SaveRanges
      <Inc s.NumRanges> (e.ScannedRanges (s.NumRanges e.Range)) e.Ranges
      (e.Vars) (e.Commands (CmdSave s.Num s.NumRanges))
    >;

  s.NumRanges (e.ScannedRanges) /* пусто */ (e.Vars) (e.Commands) =
    s.NumRanges e.ScannedRanges (e.Vars) (e.Commands);
}

*===============================================================================
* Генерация результата
*===============================================================================

GenResult {
  (e.PatternVars) e.Result =
    <DoGenResult
      (e.PatternVars)
      (/* alloc commands */) (/* other commands */)
      0 /* счётчик новых элементов */
      e.Result
    >;
}

* Основные команды работы с образцом
*  (CmdAllocateElem s.Number s.ElType e.Info)
*  (CmdLinkBrackets s.Left s.Right)
*  (CmdPushStack s.Number)
*  (CmdInsertVar s.Pos s.Usings s.Mode e.Index)
*$EENUM CmdAllocateElem
*$EENUM CmdLinkBrackets
*$EENUM CmdPushStack
*$EENUM CmdInsertVar


* Спецификаторы команд (элементы)
*$EENUM ElSymbol, ElString
*$EENUM ElOpenBracket, ElCloseBracket
*$EENUM ElOpenCall, ElCloseCall
*$EENUM ElSavePos, ElVariable

/*
  Порядок выполнения команд.
  1. Все выделения памяти (в порядке перечисления)
  2. Связывание крулых и угловых скобок и
  построение результата (в обратном порядке)
*/

*$ENUM TkString, TkCloseBracket, TkCloseCall

DoGenResult {
  /* Оптимизация для распределения последовательности char’ов */
  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter
  (Symbol Char s.Char1) (Symbol Char s.Char2) e.Result =
    <DoGenResult
      (e.Vars) (e.AllocCommands) (e.Commands) s.Counter
      (TkString 2 s.Char1 s.Char2) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (Symbol Char s.Value) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElSymbol Char s.Value))
      (e.Commands)
      s.Counter e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter
  (TkString s.Len e.String) (Symbol Char s.Char) e.Result =
    <DoGenResult
      (e.Vars) (e.AllocCommands) (e.Commands) s.Counter
      (TkString <Inc s.Len> e.String s.Char) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter
  (TkString s.Len e.String) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElString s.Len e.String))
      (e.Commands)
      s.Counter e.Result
    >;

  /* Создаём литералы */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (Symbol s.Type e.Value) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElSymbol s.Type e.Value))
      (e.Commands)
      s.Counter e.Result
    >;

  /*
    Обработка открывающих скобок всех типов осуществляется похоже.
  */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (Brackets e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElOpenBracket s.Counter))
      (e.Commands)
      <Inc s.Counter> e.InBrackets (TkCloseBracket s.Counter) e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (CallBrackets e.InBrackets) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElOpenCall s.Counter))
      (e.Commands)
      <Inc s.Counter> e.InBrackets (TkCloseCall s.Counter) e.Result
    >;

  /*
    Закрывающие скобки надо обрабатывать особым образом.
    Круглые скобки и АТД — слинковать, угловые — добавить в стек.
  */
  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter
  (TkCloseBracket s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElCloseBracket s.Counter))
      (
        (CmdLinkBrackets s.OpenCounter s.Counter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  (e.Vars) (e.AllocCommands) (e.Commands) s.Counter
  (TkCloseCall s.OpenCounter) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElCloseCall s.Counter))
      (
        (CmdPushStack s.Counter)
        (CmdPushStack s.OpenCounter)
        e.Commands
      )
      <Inc s.Counter> e.Result
    >;

  /* Оптимизация: частный случай для s-переменных, их проще всегда копировать */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (Variable 's' e.Index) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElVariable 's' e.Index))
      (e.Commands)
      s.Counter e.Result
    >;

  /* Переменная есть в образце — переносим, позиция подготовлена */
  (e.Vars-B (s.Usings s.Mode e.Index) e.Vars-E)
  (e.AllocCommands (CmdAllocateElem ElSavePos s.InsertPos)) (e.Commands)
  s.Counter (Variable s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars-B <DecUsings s.Usings s.Mode e.Index> e.Vars-E)
      (e.AllocCommands (CmdAllocateElem ElSavePos s.InsertPos))
      /* вставляем в конец списка команд */
      (
        e.Commands
        (CmdInsertVar s.InsertPos s.Usings s.Mode e.Index)
      )
      s.Counter e.Result
    >;

  /* Переменная есть в образце — переносим, позиция не подготовлена */
  (e.Vars-B (s.Usings s.Mode e.Index) e.Vars-E) (e.AllocCommands) (e.Commands)
  s.Counter (Variable s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars-B <DecUsings s.Usings s.Mode e.Index> e.Vars-E)
      (e.AllocCommands (CmdAllocateElem ElSavePos s.Counter))
      /* вставляем в конец списка команд */
      (
        e.Commands
        (CmdInsertVar s.Counter s.Usings s.Mode e.Index)
      )
      <Inc s.Counter> e.Result
    >;

  /* Переменной нет в образце — копируем */
  (e.Vars) (e.AllocCommands) (e.Commands)
  s.Counter (Variable s.Mode e.Index) e.Result =
    <DoGenResult
      (e.Vars)
      (e.AllocCommands (CmdAllocateElem ElVariable s.Mode e.Index))
      (e.Commands)
      s.Counter e.Result
    >;

  /* Завершение просмотра */
  (e.UnusedVars) (e.AllocCommands) (e.Commands) s.Counter =
    s.Counter (e.UnusedVars) (e.AllocCommands e.Commands);
}

DecUsings {
  1 s.Mode e.Index = /* пусто */;
  s.Usings s.Mode e.Index = (<Dec s.Usings> s.Mode e.Index);
}


*$EENUM CmdEmptyResult, CmdReturnResult

ComposeSentenceCommands {
  s.NumRanges (e.PatternVars) (e.PatternCommands)
  s.ResultCounter (e.UnusedVars) (e.ResultCommands) =
    <ComposeSentenceCommands-Aux
      s.NumRanges s.ResultCounter (e.ResultCommands)
      <FilterCommonVarsAndPatternCommands
        (e.PatternVars) (e.PatternCommands) e.UnusedVars
      >
    >;
}

FilterCommonVarsAndPatternCommands {
  /*
    Если в образце e-переменная имеет счётчик 1, значит, повторных
    e-переменных с этим индексом не было. Если эта переменная есть
    ещё и в списке unused, значит, она не используется.
  */
  (e.PatternVars-B (1 'e' e.Index) e.PatternVars-E)
  (
    e.PatternCommands-B
    (CmdClosedE s.Num 'e' e.Index)
    e.PatternCommands-E
  )
  (1 'e' e.Index) e.Unuseds =
    <FilterCommonVarsAndPatternCommands
      (e.PatternVars-B e.PatternVars-E)
      (
        e.PatternCommands-B
        (CmdComment 'Unused closed variable e.' e.Index)
        e.PatternCommands-E
      )
      e.Unuseds
    >;

  (e.PatternVars) (e.PatternCommands) t.OtherUnused e.Unuseds =
    <FilterCommonVarsAndPatternCommands
      (e.PatternVars) (e.PatternCommands) e.Unuseds
    >;

  (e.PatternVars) (e.PatternCommands) /* пусто */ =
    (e.PatternVars) e.PatternCommands;
}

*$EENUM CmdRangeArray, CmdInitB0, CmdResultArray

ComposeSentenceCommands-Aux {
  s.NumRanges s.ResultCounter (e.ResultCommands)
  (e.PatternVars) e.PatternCommands =
    <GenerateResult-OpenELoops
      <Map algorithm_MakeDeclaration e.PatternVars>
      (CmdRangeArray s.NumRanges)
      <MakeCmdResultCommand s.ResultCounter>
      (CmdInitB0)
      e.PatternCommands
      (CmdEmptyResult)
      e.ResultCommands
      (CmdReturnResult)
    >;
}

*$EENUM CmdDeclareVar

$ENTRY algorithm_MakeDeclaration {
  (s.Usings s.Mode e.Index) =
    (CmdDeclareVar s.Usings s.Mode e.Index)
    <MakeDeclaration-Aux s.Usings s.Mode e.Index>;
}

MakeDeclaration-Aux {
  1 s.Mode e.Index = /* это была последняя */;

  s.Usings s.Mode e.Index =
    <algorithm_MakeDeclaration (<Dec s.Usings> s.Mode e.Index)>;
}

MakeCmdResultCommand {
  0 = /* пусто */;
  s.Counter = (CmdResultArray s.Counter);
}

GenerateResult-OpenELoops {
  e.Commands-B (CmdOpenedE s.BracketNum 'e' e.Index) e.Commands-E =
    e.Commands-B
    (CmdOpenedE-Start s.BracketNum 'e' e.Index)
    <GenerateResult-OpenELoops e.Commands-E>
    (CmdOpenedE-End s.BracketNum 'e' e.Index);

  e.Commands = e.Commands;
}
