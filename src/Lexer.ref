*$FROM LibraryEx
$EXTERN Map, LoadFile, Inc, Type, FastIntFromStr;

*$FROM Library
$EXTERN StrFromInt, WriteLine, Add, Chr, Mul, Fails, Success;

*$FROM Escape
$EXTERN EscapeChar;


FlatLine {
  (e.Line) = e.Line '\n';
}

$ENTRY LexFolding {
  e.FileName =
    <ShowWarning
      (e.FileName)
      <Scan
        1 1 <SkipBOM <Map FlatLine <LoadFile e.FileName>>>
      >
    >;
}

SkipBOM {
  /* Игнорируем метку порядка байт для UTF-8 */
  '\xEF\xBB\xBF' e.Content = e.Content;

  e.Content = e.Content;
}

$ENUM Warning;

ShowWarning {
  (e.FileName)
  e.Tokens-B (Warning (s.Row s.Col) e.Message) e.Tokens-E =
    e.Tokens-B
    <WriteLine
      e.FileName ':' <StrFromInt s.Row> ':' <StrFromInt s.Col> ':'
      'Warning:' e.Message
    >
    <ShowWarning (e.FileName) e.Tokens-E>;

  (e.FileName) e.Tokens = e.Tokens;
}

$EENUM
  TkChar,
  TkCloseCall, TkCloseBlock, TkCloseBracket,
  TkComma,
  TkDirective,
  TkEOF,
  TkError,
  TkName,
  TkNative,
  TkNumber,
  TkOpenCall, TkOpenBlock, TkOpenBracket,
  TkReplace,
  TkSemicolon,
  TkUnexpected,
  TkVariable;

$EENUM EEnum, Entry, Enum, Extern;

Inc2 { s.Num = <Add 2 s.Num>; }

Scan {
  s.Row s.Col ' ' e.Tail = <Scan s.Row <Inc s.Col> e.Tail>;
  s.Row s.Col '\t' e.Tail = <Scan s.Row <Inc s.Col> e.Tail>;
  s.Row s.Col '\n' e.Tail = <Scan <Inc s.Row> 1 e.Tail>;

  /* гарантируется, что в конце файла есть \n, см. FlatLine */
  s.Row 1 '*$' e.Pseudo '\n' e.Tail =
    <ScanPseudo s.Row 3 () <Type e.Pseudo '\n'>>
    <Scan <Inc s.Row> 1 e.Tail>;

  s.Row 1 '*' e.Comment '\n' e.Tail = <Scan <Inc s.Row> 1 e.Tail>;

  /* гарантируется, что в конце файла есть \n, см. FlatLine */
  s.Row s.Col '//' e.Comment '\n' e.Tail =
    (Warning (s.Row s.Col) 'C++ comment')
    <Scan <Inc s.Row> 1 e.Tail>;

  s.Row s.Col '/*' e.Tail = <ScanCComment s.Row <Inc2 s.Col> e.Tail>;

  s.Row 1 '%%\n' e.Tail = <ScanNative s.Row <Inc s.Row> () e.Tail>;

  s.Row s.Col '$' e.Tail =
    <ScanDirective s.Row <Inc s.Col> () <Type e.Tail>>;

  s.Row s.Col '\'\'' e.Tail =
    (TkChar (s.Row s.Col) '\'')
    (Warning (s.Row s.Col) 'pair of quotes \'\' is deprecated')
    <Scan s.Row <Inc2 s.Col> e.Tail>;

  s.Row s.Col '\'' e.Tail = <ScanChars s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col 'e.' e.Tail = <ScanVariable s.Row <Inc2 s.Col> 'e' () <Type e.Tail>>;
  s.Row s.Col 's.' e.Tail = <ScanVariable s.Row <Inc2 s.Col> 's' () <Type e.Tail>>;
  s.Row s.Col 't.' e.Tail = <ScanVariable s.Row <Inc2 s.Col> 't' () <Type e.Tail>>;

  s.Row s.Col s.Next e.Tail =
    <Scan-ByPunctuation s.Row s.Col <Punctuation s.Next> e.Tail>;

  s.Row s.Col /* пусто */ = (TkEOF (s.Row s.Col));
}

ScanPseudo {
  s.Row s.Col (e.Scanned) 'L' s.SubType s.Letter e.Tail =
    <ScanPseudo s.Row <Inc s.Col> (e.Scanned s.Letter) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) 'D' s.SubType s.Digit e.Tail =
    <ScanPseudo s.Row <Inc s.Col> (e.Scanned s.Digit) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) s.Type s.SubType e.Tail =
    <ScanPseudo-SwDirective s.Row s.Col (<Directive e.Scanned>) e.Tail>;
}

ScanPseudo-SwDirective {
  s.Row s.Col (Success s.Directive) e.Tail =
    (TkDirective (s.Row 2) s.Directive)
    <ScanPseudo-AddSemicolon <Scan s.Row s.Col e.Tail>>;

  s.Row s.Col (Fails e.Directive) e.Tail =
    /* ничего не генерируем, это обычный комментарий */;
}

ScanPseudo-AddSemicolon {
  e.Tokens (TkEOF t.SrcPos) = e.Tokens (TkSemicolon t.SrcPos);
}

ScanCComment {
  s.Row s.Col e.Comment '*/' e.Tail =
    <ScanCCommentContent s.Row s.Col (e.Comment '*/') e.Tail>;

  /* Обработка незакрытого комментария */
  /* TODO: подумать потом о предупреждениях вложенных комментариев */
  s.Row s.Col e.Line '\n' e.Comment = <ScanCComment <Inc s.Row> 1 e.Comment>;

  /* Гарантируется, что в конце потока символов есть \n */
  s.Row s.Col /* пусто */ =
    (TkError (s.Row s.Col) 'EOF in comment')
    (TkEOF (s.Row s.Col));
}

ScanCCommentContent {
  s.Row s.Col (e.Line '\n' e.Comment) e.Tail =
    /* TODO: подумать потом о предупреждениях вложенных комментариев */
    <ScanCCommentContent <Inc s.Row> 1 (e.Comment) e.Tail>;

  s.Row s.Col (s.Char e.Comment) e.Tail =
    <ScanCCommentContent s.Row <Inc s.Col> (e.Comment) e.Tail>;

  s.Row s.Col (/* пусто */) e.Tail = <Scan s.Row s.Col e.Tail>;
}

ScanNative {
  s.StartRow s.Row (e.Native) '%%\n' e.Tail =
    (TkNative (s.StartRow 1) e.Native)
    <Scan <Inc s.Row> 1 e.Tail>;

  s.StartRow s.Row (e.Native) e.Line '\n' e.Tail =
    <ScanNative s.StartRow <Inc s.Row> (e.Native (e.Line)) e.Tail>;

  s.StartRow s.Row (e.Native) /* пусто */ =
    (TkNative (s.StartRow 1) e.Native)
    (TkError (s.Row 1) 'unclosed native code')
    (TkEOF (s.Row 1));
}

ScanDirective {
  s.Row s.Col (e.Scanned) 'L' s.SubType s.Letter e.Tail =
    <ScanDirective s.Row <Inc s.Col> (e.Scanned s.Letter) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) 'D' s.SubType s.Digit e.Tail =
    <ScanDirective s.Row <Inc s.Col> (e.Scanned s.Digit) <Type e.Tail>>;

  s.Row s.Col (e.Scanned) s.Type s.SubType e.Tail =
    <MakeDirective s.Row s.Col e.Scanned>
    <Scan s.Row s.Col e.Tail>;
}

MakeDirective {
  s.Row s.Col e.Directive =
    <MakeDirective-SwValid s.Row s.Col <Directive e.Directive>>;
}

Directive {
  'ENUM' = Success Enum;
  'EENUM' = Success EEnum;
  'ENTRY' = Success Entry;
  'EXTERN' = Success Extern;
  e.Other = Fails e.Other;
}

MakeDirective-SwValid {
  s.Row s.Col Success s.Directive = (TkDirective (s.Row s.Col) s.Directive);

  s.Row s.Col Fails e.Other =
    (TkError (s.Row s.Col) 'Unknown directive $' e.Other);
}

ScanChars {
  s.Row s.Col '\'\'' e.Tail =
    (TkChar (s.Row s.Col) '\'')
    (Warning (s.Row s.Col) 'pair of quotes \'\' is deprecated')
    <ScanChars s.Row <Inc2 s.Col> e.Tail>;

  s.Row s.Col '\'' e.Tail = <Scan s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col '\n' e.Tail =
    (TkError (s.Row s.Col) 'unclosed quote')
    <Scan s.Row s.Col '\n' e.Tail>;

  s.Row s.Col '\\' e.Tail =
    <ScanChars-Escape s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col s.Other e.Tail =
    (TkChar (s.Row s.Col) s.Other)
    <ScanChars s.Row <Inc s.Col> e.Tail>;
}

ScanChars-Escape {
  s.Row s.Col 'x' e.Tail =
    <ScanChars-Escape-Hex s.Row <Inc s.Col> () e.Tail>;

  s.Row s.Col s.Next e.Tail =
    <ScanChars-Escape-SwValid s.Row s.Col <Escape s.Next> e.Tail>;

  /* Пустой суффикс быть не может, поскольку в конец добавляется \n */
}

ScanChars-Escape-Hex {
  s.Row s.Col (s.H1 s.H2) e.Tail =
    (TkChar (s.Row s.Col) <Chr <Add <Mul s.H1 16> s.H2>>)
    <ScanChars s.Row s.Col e.Tail>;

  s.Row s.Col (e.Digits) s.Next e.Tail =
    <ScanChars-Escape-Hex-SwHex
      s.Row s.Col (e.Digits) <DigitFromChar s.Next> e.Tail
    >;

  /* Пустой суффикс быть не может, поскольку в конец добавляется \n */
}

ScanChars-Escape-Hex-SwHex {
  s.Row s.Col (e.Digits) Fails s.NoDigit e.Tail =
    (TkError (s.Row s.Col) 'bad hex escape sequence "\\x..."')
    <ScanChars s.Row s.Col s.NoDigit e.Tail>;

  s.Row s.Col (e.Digits) s.Digit e.Tail =
    <ScanChars-Escape-Hex s.Row <Inc s.Col> (e.Digits s.Digit) e.Tail>;
}

Escape {
  'n' = Success '\n';
  't' = Success '\t';
  'r' = Success '\r';
  '\\' = Success '\\';
  '\'' = Success '\'';
  '"' = Success '"';
  '<' = Success '<';
  '>' = Success '>';
  '(' = Success '(';
  ')' = Success ')';

  s.Other = Fails s.Other;
}

ScanChars-Escape-SwValid {
  s.Row s.Col Success s.Value e.Tail =
    (TkChar (s.Row s.Col) s.Value) <ScanChars s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col Fails s.Other e.Tail =
    (TkError (s.Row s.Col) 'bad escape sequence "\\' s.Other '"')
    <ScanChars s.Row s.Col s.Other e.Tail>;
}

ScanVariable {
  s.Row s.Col s.Mode (e.Index) 'L' s.SubType s.Letter e.Tail =
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index s.Letter) <Type e.Tail>>;

  s.Row s.Col s.Mode (e.Index) 'D' s.SubType s.Digit e.Tail =
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index s.Digit) <Type e.Tail>>;

  s.Row s.Col s.Mode (e.Index) s.Type s.SubType '-' e.Tail =
    /* нормализация */
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index '_') <Type e.Tail>>;

  s.Row s.Col s.Mode (e.Index) s.Type s.SubType '_' e.Tail =
    <ScanVariable s.Row <Inc s.Col> s.Mode (e.Index '_') <Type e.Tail>>;

  s.Row s.Col s.Mode (/* пусто */) s.Type s.SubType e.Tail =
    (TkError (s.Row s.Col) 'empty index in variable "' s.Mode '."')
    <Scan s.Row s.Col e.Tail>;

  s.Row s.Col s.Mode (e.Index) s.Type s.SubType e.Tail =
    (TkVariable (s.Row s.Col) s.Mode e.Index)
    <Scan s.Row s.Col e.Tail>;
}

Punctuation {
  /* упорядочены по ASCII-кодам */
  '(' = Success TkOpenBracket;
  ')' = Success TkCloseBracket;
  ',' = Success TkComma;
  ';' = Success TkSemicolon;
  '<' = Success TkOpenCall;
  '=' = Success TkReplace;
  '>' = Success TkCloseCall;
  '{' = Success TkOpenBlock;
  '}' = Success TkCloseBlock;

  s.Other = Fails s.Other;
}

Scan-ByPunctuation {
  s.Row s.Col Success s.Token e.Tail =
    (s.Token (s.Row s.Col)) <Scan s.Row <Inc s.Col> e.Tail>;

  s.Row s.Col Fails e.Tail = <Scan-ByType s.Row s.Col <Type e.Tail>>;
}

Scan-ByType {
  s.Row s.Col 'L' s.SubType s.Letter e.Tail =
    <ScanName s.Row <Inc s.Col> (s.Letter) <Type e.Tail>>;

  s.Row s.Col 'D' s.SubType s.Digit e.Tail =
    <ScanNumber s.Row <Inc s.Col> (s.Digit) <Type e.Tail>>;

  s.Row s.Col s.Type s.SubType s.Unexpected e.Text =
    <GlueUnexpecteds
      (TkUnexpected (s.Row s.Col) s.Unexpected)
      <Scan s.Row <Inc s.Col> e.Text>
    >;
}

GlueUnexpecteds {
  (TkUnexpected t.SrcPos1 s.Unexpected1) (TkUnexpected t.SrcPos2 e.Unexpected2)
  e.Tokens =
    (TkUnexpected t.SrcPos1 s.Unexpected1 e.Unexpected2) e.Tokens;

  t.Unexpected e.Tokens = t.Unexpected e.Tokens;
}

ScanName {
  s.Row s.Col (e.Name) 'L' s.SubType s.Letter e.Tail =
    <ScanName s.Row <Inc s.Col> (e.Name s.Letter) <Type e.Tail>>;

  s.Row s.Col (e.Name) 'D' s.SubType s.Digit e.Tail =
    <ScanName s.Row <Inc s.Col> (e.Name s.Digit) <Type e.Tail>>;

  s.Row s.Col (e.Name) s.Type s.SubType '-' e.Tail =
    /* нормализация */
    <ScanName s.Row <Inc s.Col> (e.Name '_') <Type e.Tail>>;

  s.Row s.Col (e.Name) s.Type s.SubType '_' e.Tail =
    <ScanName s.Row <Inc s.Col> (e.Name '_') <Type e.Tail>>;

  s.Row s.Col (e.Name) s.Type s.SubType e.Tail =
    (TkName (s.Row s.Col) e.Name) <Scan s.Row s.Col e.Tail>;
}

ScanNumber {
  s.Row s.Col (e.Number) 'D' s.SubType s.Digit e.Tail =
    <ScanNumber s.Row <Inc s.Col> (e.Number s.Digit) <Type e.Tail>>;

  s.Row s.Col (e.Number) s.Type s.SubType e.Tail =
    (TkNumber (s.Row s.Col) <FastIntFromStr e.Number>)
    <Scan s.Row s.Col e.Tail>;
}


StrDirective {
  EEnum = 'EENUM';
  Entry = 'ENTRY';
  Enum = 'ENUM';
  Extern = 'EXTERN';
}

$EENUM TkOpen, TkClose;

$ENTRY StrFromToken {
  TkChar s.Char = '\'' <EscapeChar s.Char> '\'';
  TkCloseCall = '">"';
  TkCloseBlock = '"}"';
  TkCloseBracket = '")"';
  TkComma = '","';
  TkDirective s.Directive = '"$' <StrDirective s.Directive> '"';
  TkEOF = 'end of file';
  TkError e.Message = 'LEXER ERROR: ' e.Message;
  TkName e.Name = 'Name ' e.Name;
  TkNative e.Code = '"%%...%%"';
  TkNumber s.Number = 'Number ' <StrFromInt s.Number>;
  TkOpenCall = '"<"';
  TkOpenBlock = '"{"';
  TkOpenBracket = '"("';
  TkReplace = '"="';
  TkSemicolon = '";"';
  TkUnexpected e.Unexpected = 'Unexpected characters <' e.Unexpected '>';
  TkVariable s.Mode e.Index = s.Mode '.' e.Index;

  TkOpen s.OpenBracket = <StrFromToken s.OpenBracket>;
  TkClose s.CloseBracket = <StrFromToken s.CloseBracket>;
}

DigitFromChar {
  '0' = 0; '1' = 1; '2' = 2; '3' = 3; '4' = 4;
  '5' = 5; '6' = 6; '7' = 7; '8' = 8; '9' = 9;

  'A' = 10; 'B' = 11; 'C' = 12; 'D' = 13; 'E' = 14; 'F' = 15;
  'a' = 10; 'b' = 11; 'c' = 12; 'd' = 13; 'e' = 14; 'f' = 15;

  s.Other = Fails s.Other;
}
