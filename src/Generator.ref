*$FROM LibraryEx
$EXTERN MapAccum, Map, Dec, DelAccumulator, Inc;

*$FROM Algorithm
$EXTERN
  CmdComment, CmdDeclareVar, CmdRangeArray, CmdInitB0, CmdSymbol, CmdBrackets,
  CmdEmpty, CmdVar, CmdRepeated, CmdClosedE, AlgLeft, CmdOpenedE-Start,
  CmdOpenedE-End, CmdSave, CmdEmptyResult, CmdResultArray, CmdAllocateElem,
  CmdLinkBrackets, CmdPushStack, CmdInsertVar, CmdReturnResult, Char, Number,
  Name, AlgRight, ElSymbol, ElString, ElOpenBracket, ElCloseBracket, ElOpenCall,
  ElCloseCall, ElSavePos, ElVariable;

*$FROM Escape
$EXTERN EscapeChar;


*$EENUM GN-Local, GN-Entry

TextFromMemoryClass {
  GN-Local = 'static '; GN-Entry = ;
}

$ENTRY GenFnStart {
  s.MemoryClass e.Name =
    (
      'static void r05c_' e.Name
      '(struct r05_node *arg_begin, struct r05_node *arg_end) {'
    );
}

$ENTRY GenThisIsGeneratedFunction {
  = ('  r05_this_is_generated_function();');
}

$ENTRY GenFail {
  = ('  r05_recognition_impossible();')
}

$ENTRY GenFnEnd {
  s.MemoryClass e.Name =
    ('}')
    (
      <TextFromMemoryClass s.MemoryClass>
      'struct r05_function r05f_' e.Name ' = { r05c_' e.Name ', "' e.Name '" };'
    )
    ();
}

$ENTRY GenEnum {
  s.ScopeClass e.Name =
    (
      <TextFromMemoryClass s.ScopeClass>
      'struct r05_function r05f_' e.Name ' = '
      '{ r05_enum_function_code, "' e.Name '" };'
    )
    ();
}

$ENTRY GenDeclaration {
  (GN-Entry e.Name) = ('extern struct r05_function r05f_' e.Name ';');
  (GN-Local e.Name) = ('static struct r05_function r05f_' e.Name ';');
}

GenCommonHeaders {
  = ('/* Automatically generated file. Don\'t edit! */')
  ('#include "refalrts.h"')
  () ();
}

GenCommonTailer {
  = () ('/* End of file */');
}

$ENTRY GenSentence {
  e.Algorithm =
    ('  do {')
    <SkipIndentAccum
      <MapAccum generator_GenCommand ('    ' /* отступ */) e.Algorithm>
    >
    ('  } while (0);')
    ();
}

SkipIndentAccum {
  /* отступ должен остаться тем же */
  ('    ') e.Generated = e.Generated;
}

BracketsVar-B {
  s.BracketNumber = 'bb[' <Symb s.BracketNumber> ']';
}

BracketsVar-E {
  s.BracketNumber = 'be[' <Symb s.BracketNumber> ']';
}

BracketsVars {
  s.BracketNumber =
    <BracketsVar-B s.BracketNumber> ', ' <BracketsVar-E s.BracketNumber>;
}

BracketsVarsPtr {
  s.BracketNumber =
    '&' <BracketsVar-B s.BracketNumber> ', &' <BracketsVar-E s.BracketNumber>;
}

/*
  Величина отступа также определяет режим работы. Отступ в 4 пробела --
  вне цикла по открытой e-переменной, отступ больше -- внутри оного цикла.
*/

SafeComment {
  e.Comment-B '/*' e.Comment-E =
    <SafeComment e.Comment-B '/\' \'*' e.Comment-E>;

  e.Comment-B '*/' e.Comment-E =
    <SafeComment e.Comment-B '*\' \'/' e.Comment-E>;

  e.Comment = e.Comment;
}

$ENTRY generator_GenCommand {
  (e.Indent) (CmdComment e.Text) =
    (e.Indent) (e.Indent '/*' <SafeComment e.Text> '*/');

  (e.Indent) (CmdDeclareVar s.Usings 'e' e.Index) =
    (e.Indent)
    (e.Indent 'struct r05_node *' <PrintEVar-B s.Usings 'e' e.Index> ';')
    (e.Indent 'struct r05_node *' <PrintEVar-E s.Usings 'e' e.Index> ';');

  (e.Indent) (CmdDeclareVar s.Usings s.Mode e.Index) =
    (e.Indent)
    (e.Indent 'struct r05_node *' <PrintVar s.Usings s.Mode e.Index> ';');

  (e.Indent) (CmdRangeArray s.Size) =
    (e.Indent)
    (e.Indent 'struct r05_node *bb[' <Symb s.Size> '] = { 0 };')
    (e.Indent 'struct r05_node *be[' <Symb s.Size> '] = { 0 };');

  (e.Indent) (CmdInitB0) =
    (e.Indent)
    (e.Indent 'r05_start_sentence();')
    (e.Indent 'r05_prepare_argument(' <BracketsVarsPtr 0> ', arg_begin, arg_end);');

  (e.Indent) (CmdSymbol s.Direction s.BracketNumber s.Type e.Value) =
    (e.Indent)
    <PrintMatchSymbol (e.Indent) s.Direction s.BracketNumber s.Type e.Value>;

  (e.Indent) (CmdBrackets s.Direction s.BracketNumber s.InnerBrackets) =
    (e.Indent)
    <PrintMatchBrackets (e.Indent) s.Direction s.BracketNumber s.InnerBrackets>;

  (e.Indent) (CmdEmpty s.Direction s.BracketNumber) =
    (e.Indent)
    <PrintMatchEmpty (e.Indent) s.BracketNumber>;

  (e.Indent) (CmdVar s.Direction s.BracketNumber s.Mode e.Info) =
    (e.Indent)
    <PrintMatchSTVar (e.Indent) s.Direction s.BracketNumber s.Mode e.Info>;

  (e.Indent) (CmdRepeated s.Direction s.BracketNumber e.VarInfo) =
    (e.Indent)
    <PrintMatchRepeated (e.Indent) s.Direction s.BracketNumber e.VarInfo>;

  (e.Indent) (CmdClosedE AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Indent)
    (e.Indent
      <PrintEVar-B 1 'e' e.Index> ' = ' <BracketsVar-B s.BracketNumber> ';'
    )
    (e.Indent
      <PrintEVar-E 1 'e' e.Index> ' = ' <BracketsVar-E s.BracketNumber> ';'
    );

  (e.Indent)
  (CmdOpenedE-Start AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Indent '  ')
    (e.Indent <PrintEVar-B 1 'e' e.Index> ' = 0;')
    (e.Indent <PrintEVar-E 1 'e' e.Index> ' = 0;')
    (e.Indent 'r05_start_e_loop();')
    (e.Indent 'do {');

  (e.Indent '  ')
  (CmdOpenedE-End AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Indent)
    (e.Indent
      '} while (r05_open_evar_advance('
      <PrintEVarsPtr 1 'e' e.Index> ', ' <BracketsVarsPtr s.BracketNumber>
      '));'
    );

  (e.Indent) (CmdSave s.Old s.New) =
    (e.Indent)
    (e.Indent <BracketsVar-B s.New> ' = ' <BracketsVar-B s.Old> ';')
    (e.Indent <BracketsVar-E s.New> ' = ' <BracketsVar-E s.Old> ';');

  (e.Indent) (CmdEmptyResult) =
    (e.Indent)
    ()
    (e.Indent 'r05_reset_allocator();');

  (e.Indent) (CmdResultArray s.Size) =
    (e.Indent)
    (e.Indent 'struct r05_node *n[' <Symb s.Size> '] = { 0 };');

  (e.Indent) (CmdAllocateElem e.ElemInfo) =
    (e.Indent)
    <PrintAllocateElem (e.Indent) e.ElemInfo>;

  (e.Indent) (CmdLinkBrackets s.Left s.Right) =
    (e.Indent)
    (e.Indent
      'r05_link_brackets'
      '(' <PrintElemVar s.Left> ', ' <PrintElemVar s.Right> ');'
    );

  (e.Indent) (CmdPushStack s.ElemNumber) =
    (e.Indent)
    (e.Indent 'r05_push_stack(' <PrintElemVar s.ElemNumber> ');');

  (e.Indent) (CmdInsertVar s.Pos s.Usings 'e' e.Index) =
    (e.Indent)
    (e.Indent
      'r05_splice_evar(' <PrintElemVar s.Pos> ', '
      <PrintEVars s.Usings 'e' e.Index> ');'
    );

  (e.Indent) (CmdInsertVar s.Pos s.Usings 't' e.Index) =
    (e.Indent)
    (e.Indent
      'r05_splice_tvar(' <PrintElemVar s.Pos> ', '
      <PrintVar s.Usings 't' e.Index> ');'
    );

  (e.Indent) (CmdReturnResult) =
    (e.Indent)
    (e.Indent 'r05_splice_from_freelist(arg_begin);')
    (e.Indent 'r05_splice_to_freelist(arg_begin, arg_end);')
    (e.Indent 'return;');
}

EscapeString {
  e.String = <Map EscapeChar e.String>;
}

PrintVar {
  s.Usings s.Mode e.Index = s.Mode e.Index '_' <Symb s.Usings>;
}

PrintVarPtr {
  s.Usings s.Mode e.Index = '&' s.Mode e.Index '_' <Symb s.Usings>;
}

PrintEVar-B {
  s.Usings s.Mode e.Index = s.Mode e.Index '_b_' <Symb s.Usings>;
}

PrintEVar-E {
  s.Usings s.Mode e.Index = s.Mode e.Index '_e_' <Symb s.Usings>;
}

PrintEVars {
  s.Usings s.Mode e.Index =
    <PrintEVar-B s.Usings s.Mode e.Index> ', '
    <PrintEVar-E s.Usings s.Mode e.Index>;
}

PrintEVarsPtr {
  s.Usings s.Mode e.Index =
    '&' <PrintEVar-B s.Usings s.Mode e.Index> ', '
    '&' <PrintEVar-E s.Usings s.Mode e.Index>;
}

PrintMatchSymbol {
  (e.Indent) s.Direction s.BracketNumber s.Type e.Value =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      (<SymbolFunc s.Type>) <SymbolTextRep s.Type e.Value>
    >;
}

SymbolFunc {
  Char = 'char';
  Number = 'number';
  Name = 'function';
}

SymbolTextRep {
  Char s.Char = '\'' <EscapeChar s.Char> '\'';
  Number s.Number = <Symb s.Number> 'UL';
  Name e.Name = '&r05f_' e.Name;
}

PrintMatchBrackets {
  (e.Indent) s.Direction s.BracketNumber s.InnerNum =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      ('brackets')
      <BracketsVarsPtr s.InnerNum>
    >;
}

BreakerFromIndent {
  '    ' = 'break;';

  e.OtherIndent = 'continue;';
}

PrintMatchEmpty {
  (e.Indent) s.BracketNumber =
    (e.Indent
      'if (! r05_empty_seq(' <BracketsVars s.BracketNumber> '))'
    )
    (e.Indent '  ' <BreakerFromIndent e.Indent>);
}

StrFromDirection {
  AlgLeft = 'left'; AlgRight = 'right';
}

VarMatchFunction { 's' = 'svar'; 't' = 'tvar'; }

PrintMatchSTVar {
  (e.Indent) s.Direction s.BracketNumber s.Mode e.Index =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      (<VarMatchFunction s.Mode>) <PrintVarPtr 1 s.Mode e.Index>
    >;
}

PrintMatchRepeated {
  (e.Indent) s.Direction s.BracketNumber s.Usings 'e' e.Index =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      ('repeated_evar')
      <PrintEVarsPtr s.Usings 'e' e.Index> ', '
      <PrintEVars <Dec s.Usings> 'e' e.Index>
    >;

  (e.Indent) s.Direction s.BracketNumber s.Usings s.Mode e.Index =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      ('repeated_stvar') <PrintVarPtr s.Usings s.Mode e.Index>
      ', ' <PrintVar <Dec s.Usings> s.Mode e.Index>
    >;
}

PrintMatch {
  (e.Indent) s.Direction s.BracketNumber (e.Function) e.TextRep =
    (e.Indent
      'if (! r05_' e.Function '_' <StrFromDirection s.Direction>
      '(' e.TextRep ', ' <BracketsVarsPtr s.BracketNumber> '))'
    )
    (e.Indent '  ' <BreakerFromIndent e.Indent>);
}

PrintElemVar {
  s.Number = 'n[' <Symb s.Number> ']';
}

PrintAllocateElem {
  (e.Indent) s.ElementType e.Info =
    (e.Indent
      'r05_alloc_' <SwAllocator s.ElementType e.Info>
      '(' <SwInfo s.ElementType e.Info> ');'
    );
}

SwAllocator {
  ElSymbol s.Type e.Value = <SymbolFunc s.Type>;
  ElString s.Len e.String = 'chars';

  ElOpenBracket s.Pos = 'open_bracket';
  ElCloseBracket s.Pos = 'close_bracket';

  ElOpenCall s.Pos = 'open_call';
  ElCloseCall s.Pos = 'close_call';

  ElSavePos s.Pos = 'insert_pos';

  ElVariable s.Mode e.Index = s.Mode 'var';
}

SwInfo {
  ElSymbol s.Type e.Value = <SymbolTextRep s.Type e.Value>;
  ElString s.Len e.String = '"' <EscapeString e.String> '", ' <Symb s.Len>;

  ElOpenBracket s.Pos = <PrintElemVar s.Pos>;
  ElCloseBracket s.Pos = <PrintElemVar s.Pos>;

  ElOpenCall s.Pos = <PrintElemVar s.Pos>;
  ElCloseCall s.Pos = <PrintElemVar s.Pos>;

  ElSavePos s.Pos = <PrintElemVar s.Pos>;

  ElVariable 'e' e.Index = <PrintEVars 1 'e' e.Index>;
  ElVariable s.Mode e.Index = <PrintVar 1 s.Mode e.Index>;
}

*$ENUM BeginNative, EndNative

$ENTRY GenNative {
  s.NativeLineNo e.Code = (BeginNative s.NativeLineNo) e.Code (EndNative);
}

$ENTRY GenPostprocess {
  (e.SrcName) (e.OutputName) e.Lines-B (EndNative) e.Lines-E =
    <DelAccumulator
      <MapAccum
        (generator_EnumerateLines (e.SrcName) (e.OutputName))
        1
        <GenCommonHeaders>
        e.Lines-B (EndNative) e.Lines-E
        <GenCommonTailer>
      >
    >;

  (e.SrcName) (e.OutputName) e.Lines =
    <GenCommonHeaders>
    e.Lines
    <GenCommonTailer>;
}

$ENTRY generator_EnumerateLines {
  (e.SrcName) (e.OutputName) s.LineNo (BeginNative s.NativeLineNo) =
    <Inc s.LineNo>
    <LineDirective s.NativeLineNo e.SrcName>;

  (e.SrcName) (e.OutputName) s.LineNo (EndNative) =
    <Inc s.LineNo>
    <LineDirective s.LineNo e.OutputName>;

  (e.SrcName) (e.OutputName) s.LineNo (e.Line) = <Inc s.LineNo> (e.Line);
}

LineDirective {
  s.LineNo e.FileName =
    ('#line ' <Symb <Inc s.LineNo>> ' "' <EscapeString e.FileName> '"');
}
