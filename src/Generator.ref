*$FROM LibraryEx
$EXTERN MapReduce, Dec, Inc, Map, DelAccumulator;

*$FROM Library
$EXTERN StrFromInt;

*$FROM Algorithm
$EXTERN
  CmdComment, CmdDeclareEVar, CmdDeclareVar, CmdSymbol, Char, Number, Name,
  CmdBrackets, CmdEmpty, CmdVar, CmdRepeated, CmdClosedE, AlgLeft,
  CmdOpenedE-Start, CmdOpenedE-End, CmdSave, CmdEmptyResult, CmdCopyEVar,
  CmdCopyVar, CmdAllocateElem, ElString, CmdLinkBrackets, CmdPushStack,
  CmdInsertElem, CmdInsertVar, CmdInsertString, CmdReturnResult, AlgRight,
  ElSymbol, ElOpenBracket, ElCloseBracket, ElOpenCall, ElCloseCall;

*$FROM Escape
$EXTERN EscapeChar;


$EENUM GN-Local, GN-Entry;

FuncArguments {
  = 'struct r05_Node *arg_begin, struct r05_Node *arg_end';
}

NakedArguments {
  = 'struct r05_Node *, struct r05_Node *';
}

TextFromMemoryClass {
  GN-Local = 'static '; GN-Entry = ;
}

SwGenFnStart {
  s.MemoryClass s.FnArguments e.Name =
    (
      <TextFromMemoryClass s.MemoryClass>
      'enum r05_FnResult ' e.Name '(' <s.FnArguments> ') {'
    );
}

$ENTRY GenFnStart {
  s.MemoryClass e.Name =
    <SwGenFnStart s.MemoryClass FuncArguments e.Name>;
}

$ENTRY GenThisIsGeneratedFunction {
  = ('  refalrts::this_is_generated_function();');
}

$ENTRY GenFnEnd {
  =
    ('  return (enum r05_FnResult)(')
    ('    refalrts::cRecognitionImpossible | (__LINE__ << 8)')
    ('  );')
    ('}') ();
}

$ENTRY GenFnEnd-Success {
  = ('  //return refalrts::cRecognitionImpossible;') ('}') ();
}

$ENTRY GenEnum {
  s.ScopeClass e.Name =
    <SwGenFnStart s.ScopeClass NakedArguments e.Name> <GenFnEnd>;
}

$ENTRY GenExtern {
  e.Name =
    ('extern enum r05_FnResult ' e.Name '(' <FuncArguments> ');');
}

$ENTRY GenForward {
  e.Name =
    ('static enum r05_FnResult ' e.Name '(' <FuncArguments> ');');
}

GenCommonHeaders {
  = ('// Automatically generated file. Don\'t edit!')
  ('#include "refalrts.h"')
  () ();
}

GenCommonTailer {
  = () ('//End of file');
}

$ENTRY GenSentence {
  e.Algorithm =
    ('  do {')
    ('    struct r05_Node *' <BracketsVar-B 0> ' = arg_begin;')
    ('    struct r05_Node *' <BracketsVar-E 0> ' = arg_end;')
    ('    refalrts::move_left( ' <BracketsVars 0> ' );')
    ('    refalrts::move_left( ' <BracketsVars 0> ' );')
    ('    refalrts::move_right( ' <BracketsVars 0> ' );')
    ('    refalrts::start_sentence();')
    <SkipIndentAccum
      <MapReduce GenCommand ('    ' /* отступ */) e.Algorithm>
    >
    ('  } while ( 0 );')
    ();
}

SkipIndentAccum {
  /* отступ должен остаться тем же */
  ('    ') e.Generated = e.Generated;
}

BracketsVar-B {
  s.BracketNumber = 'bb_' <StrFromInt s.BracketNumber>;
}

BracketsVar-E {
  s.BracketNumber = 'be_' <StrFromInt s.BracketNumber>;
}

BracketsVars {
  s.BracketNumber =
    <BracketsVar-B s.BracketNumber> ', ' <BracketsVar-E s.BracketNumber>;
}

/*
  Величина отступа также определяет режим работы. Отступ в 4 пробела --
  вне цикла по открытой e-переменной, отступ больше -- внутри оного цикла.
*/

GenCommand {
  (e.Indent) (CmdComment e.Text) = (e.Indent) (e.Indent '//' e.Text);

  (e.Indent) (CmdDeclareEVar e.VarInfo) =
    (e.Indent)
    (e.Indent 'static struct r05_Node *' <PrintEVar-B e.VarInfo> ';')
    (e.Indent 'static struct r05_Node *' <PrintEVar-E e.VarInfo> ';');

  (e.Indent) (CmdDeclareVar e.VarInfo) =
    (e.Indent)
    (e.Indent 'static struct r05_Node *' <PrintVar e.VarInfo> ';');

  (e.Indent) (CmdSymbol s.Direction s.BracketNumber s.Type e.Value) =
    (e.Indent)
    <PrintMatchSymbol (e.Indent) s.Direction s.BracketNumber s.Type e.Value>;

  (e.Indent) (CmdBrackets s.Direction s.BracketNumber s.InnerBrackets) =
    (e.Indent)
    (e.Indent 'struct r05_Node *' <BracketsVar-B s.InnerBrackets> ' = 0;')
    (e.Indent 'struct r05_Node *' <BracketsVar-E s.InnerBrackets> ' = 0;')
    <PrintMatchBrackets (e.Indent) s.Direction s.BracketNumber s.InnerBrackets>;

  (e.Indent) (CmdEmpty s.Direction s.BracketNumber) =
    (e.Indent)
    <PrintMatchEmpty (e.Indent) s.BracketNumber>;

  (e.Indent) (CmdVar s.Direction s.BracketNumber s.Mode e.Info) =
    (e.Indent)
    <PrintMatchSTVar (e.Indent) s.Direction s.BracketNumber s.Mode e.Info>;

  (e.Indent) (CmdRepeated s.Direction s.BracketNumber e.VarInfo) =
    (e.Indent)
    <PrintMatchRepeated (e.Indent) s.Direction s.BracketNumber e.VarInfo>;

  (e.Indent) (CmdClosedE AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Indent)
    (e.Indent
      <PrintEVar-B 1 'e' e.Index> ' = ' <BracketsVar-B s.BracketNumber> ';'
    )
    (e.Indent
      <PrintEVar-E 1 'e' e.Index> ' = ' <BracketsVar-E s.BracketNumber> ';'
    );

  (e.Indent)
  (CmdOpenedE-Start AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Indent '  ')
    (e.Indent <PrintEVar-B 1 'e' e.Index> ' = 0;')
    (e.Indent <PrintEVar-E 1 'e' e.Index> ' = 0;')
    (e.Indent 'refalrts::start_e_loop();')
    (e.Indent 'do {');

  (e.Indent '  ')
  (CmdOpenedE-End AlgLeft s.BracketNumber 'e' e.Index) =
    (e.Indent)
    (e.Indent
      '} while ( refalrts::open_evar_advance( '
      <PrintEVars 1 'e' e.Index> ', ' <BracketsVars s.BracketNumber>
      ' ) );'
    );

  (e.Indent) (CmdSave s.OldBracketNumber s.NewBracketNumber) =
    (e.Indent)
    (e.Indent
      'struct r05_Node *' <BracketsVar-B s.NewBracketNumber>
      ' = ' <BracketsVar-B s.OldBracketNumber> ';'
    )
    (e.Indent
      'struct r05_Node *' <BracketsVar-E s.NewBracketNumber>
      ' = ' <BracketsVar-E s.OldBracketNumber> ';'
    );

  (e.Indent) (CmdEmptyResult) =
    (e.Indent)
    ()
    (e.Indent 'refalrts::reset_allocator();')
    (e.Indent 'struct r05_Node *res = arg_begin;');

  (e.Indent) (CmdCopyEVar s.Usings 'e' e.Index) =
    (e.Indent)
    (e.Indent
      'if( ! refalrts::copy_evar( ' <PrintEVars s.Usings 'e' e.Index> ', '
      <PrintEVars <Dec s.Usings> 'e' e.Index> ' ) )'
    )
    (e.Indent '  return refalrts::cNoMemory;');

  (e.Indent) (CmdCopyVar s.Usings s.Mode e.Index) =
    (e.Indent)
    (e.Indent
      'if( ! refalrts::copy_stvar( ' <PrintVar s.Usings s.Mode e.Index> ', '
      <PrintVar <Dec s.Usings> s.Mode e.Index> ' ) )'
    )
    (e.Indent '  return refalrts::cNoMemory;');

  (e.Indent) (CmdAllocateElem s.StringNumber ElString s.Len e.String) =
    (e.Indent)
    (e.Indent 'struct r05_Node *' <PrintElemVar s.StringNumber> ' = 0;')
    (e.Indent 'struct r05_Node *' <PrintElemVar <Inc s.StringNumber>> ' = 0;')
    (e.Indent
      'if( ! refalrts::alloc_chars( ' <PrintStringVar s.StringNumber> ', '
      '"' <EscapeString e.String> '", ' <StrFromInt s.Len> ') )'
    )
    (e.Indent '  return refalrts::cNoMemory;');

  (e.Indent) (CmdAllocateElem s.ElemNumber e.ElemInfo) =
    (e.Indent)
    (e.Indent 'struct r05_Node *' <PrintElemVar s.ElemNumber> ' = 0;')
    <PrintAllocateElem (e.Indent) s.ElemNumber e.ElemInfo>;

  (e.Indent) (CmdLinkBrackets s.Left s.Right) =
    (e.Indent)
    (e.Indent
      'refalrts::link_brackets( '
      <PrintElemVar s.Left> ', ' <PrintElemVar s.Right>
      ' );'
    );

  (e.Indent) (CmdPushStack s.ElemNumber) =
    (e.Indent)
    (e.Indent 'refalrts::push_stack( ' <PrintElemVar s.ElemNumber> ' );');

  (e.Indent) (CmdInsertElem s.ElemNumber) =
    (e.Indent)
    (e.Indent
      'res = refalrts::splice_elem( res, ' <PrintElemVar s.ElemNumber> ' );'
    );

  (e.Indent) (CmdInsertVar s.Usings 'e' e.Index) =
    (e.Indent)
    (e.Indent
      'res = refalrts::splice_evar( res, '
      <PrintEVars s.Usings 'e' e.Index> ' );'
    );

  (e.Indent) (CmdInsertVar s.Usings s.Mode e.Index) =
    (e.Indent)
    (e.Indent
      'res = refalrts::splice_stvar( res, '
      <PrintVar s.Usings s.Mode e.Index> ' );'
    );

  (e.Indent) (CmdInsertString s.StringNumber) =
    (e.Indent)
    (e.Indent
      'res = refalrts::splice_evar( res, ' <PrintStringVar s.StringNumber> ' );'
    );

  (e.Indent) (CmdReturnResult) =
    (e.Indent)
    (e.Indent 'refalrts::use( res );')
    (e.Indent 'refalrts::splice_to_freelist( arg_begin, arg_end );')
    (e.Indent 'return r05_cSuccess;');
}

EscapeString {
  e.String = <Map EscapeChar e.String>;
}

PrintVar {
  s.Usings s.Mode e.Index =
    s.Mode e.Index '_' <StrFromInt s.Usings>;
}

PrintEVar-B {
  s.Usings s.Mode e.Index =
    s.Mode e.Index '_b_' <StrFromInt s.Usings>;
}

PrintEVar-E {
  s.Usings s.Mode e.Index =
    s.Mode e.Index '_e_' <StrFromInt s.Usings>;
}

PrintEVars {
  s.Usings s.Mode e.Index =
    <PrintEVar-B s.Usings s.Mode e.Index> ', '
    <PrintEVar-E s.Usings s.Mode e.Index>;
}

PrintMatchSymbol {
  (e.Indent) s.Direction s.BracketNumber s.Type e.Value =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      (<SymbolFunc s.Type>) <SymbolTextRep s.Type e.Value>
    >;
}

SymbolFunc {
  Char = 'char';
  Number = 'number';
  Name = 'function';
}

SymbolTextRep {
  Char s.Char = '\'' <EscapeChar s.Char> '\'';
  Number s.Number = <StrFromInt s.Number> 'UL';
  Name e.Name = e.Name;
}

PrintMatchBrackets {
  (e.Indent) s.Direction s.BracketNumber s.InnerNum =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      ('brackets')
      <BracketsVars s.InnerNum>
    >;
}

BreakerFromIndent {
  '    ' = 'break;';

  e.OtherIndent = 'continue;';
}

PrintMatchEmpty {
  (e.Indent) s.BracketNumber =
    (e.Indent
      'if( ! refalrts::empty_seq( ' <BracketsVars s.BracketNumber> ' ) )'
    )
    (e.Indent '  ' <BreakerFromIndent e.Indent>);
}

StrFromDirection {
  AlgLeft = 'left'; AlgRight = 'right';
}

VarMatchFunction { 's' = 'svar'; 't' = 'tvar'; }

PrintMatchSTVar {
  (e.Indent) s.Direction s.BracketNumber s.Mode e.Index =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      (<VarMatchFunction s.Mode>) <PrintVar 1 s.Mode e.Index>
    >;
}

PrintMatchRepeated {
  (e.Indent) s.Direction s.BracketNumber s.Usings 'e' e.Index =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      ('repeated_evar')
      <PrintEVars s.Usings 'e' e.Index> ', '
      <PrintEVars <Dec s.Usings> 'e' e.Index>
    >;

  (e.Indent) s.Direction s.BracketNumber s.Usings s.Mode e.Index =
    <PrintMatch
      (e.Indent) s.Direction s.BracketNumber
      ('repeated_stvar') <PrintVar s.Usings s.Mode e.Index>
      ', ' <PrintVar <Dec s.Usings> s.Mode e.Index>
    >;
}

PrintMatch {
  (e.Indent) s.Direction s.BracketNumber (e.Function) e.TextRep =
    (e.Indent
      'if( ! refalrts::' e.Function '_' <StrFromDirection s.Direction>
      '( ' e.TextRep ', ' <BracketsVars s.BracketNumber> ' ) )'
    )
    (e.Indent '  ' <BreakerFromIndent e.Indent>);
}

PrintElemVar {
  s.Number = 'n' <StrFromInt s.Number>;
}

PrintStringVar {
  s.Number = 'n' <StrFromInt s.Number> ', n' <StrFromInt <Inc s.Number>>;
}

PrintAllocateElem {
  (e.Indent) s.ElemNumber s.ElementType e.Info =
    <PrintAllocate-Aux
      (e.Indent) s.ElemNumber
      ( <SwAllocator s.ElementType e.Info> )
      ( <SwInfo s.ElementType e.Info> )
    >
    (e.Indent '  return refalrts::cNoMemory;');
}

PrintAllocate-Aux {
  (e.Indent) s.ElemNumber (e.Constructor) (e.Value) =
    (e.Indent
      'if( ! refalrts::' e.Constructor '( ' <PrintElemVar s.ElemNumber>
      e.Value ' ) )'
    );
}

SwAllocator {
  ElSymbol Char s.Char = 'alloc_char';
  ElSymbol Name e.Name = 'alloc_name';
  ElSymbol Number s.Number = 'alloc_number';

  ElOpenBracket = 'alloc_open_bracket';
  ElCloseBracket = 'alloc_close_bracket';

  ElOpenCall = 'alloc_open_call';
  ElCloseCall = 'alloc_close_call';
}

SwInfo {
  ElSymbol Name e.Name = ', ' e.Name ', "' e.Name '"';

  ElSymbol s.Type e.Value = ', ' <SymbolTextRep s.Type e.Value>;

  /* Остальное -- скобки */
  s.Other = ;
}

$ENUM BeginNative, EndNative;

$ENTRY GenNative {
  s.NativeLineNo e.Code = (BeginNative s.NativeLineNo) e.Code (EndNative);
}

$ENTRY GenPostprocess {
  (e.SrcName) (e.OutputName) e.Lines-B (EndNative) e.Lines-E =
    <DelAccumulator
      <MapReduce
        (EnumerateLines (e.SrcName) (e.OutputName))
        1
        <GenCommonHeaders>
        e.Lines-B (EndNative) e.Lines-E
        <GenCommonTailer>
      >
    >;

  (e.SrcName) (e.OutputName) e.Lines =
    <GenCommonHeaders>
    e.Lines
    <GenCommonTailer>;
}

EnumerateLines {
  (e.SrcName) (e.OutputName) s.LineNo (BeginNative s.NativeLineNo) =
    <Inc s.LineNo>
    <LineDirective s.NativeLineNo e.SrcName>;

  (e.SrcName) (e.OutputName) s.LineNo (EndNative) =
    <Inc s.LineNo>
    <LineDirective s.LineNo e.OutputName>;

  (e.SrcName) (e.OutputName) s.LineNo (e.Line) = <Inc s.LineNo> (e.Line);
}

LineDirective {
  s.LineNo e.FileName =
    ('#line ' <StrFromInt <Inc s.LineNo>> ' "' <EscapeString e.FileName> '"');
}
