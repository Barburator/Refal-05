*$FROM Refal5-Lexer
$EXTERN Scan, ScanString-FromPos;

*$FROM LibraryEx
$EXTERN MapAccum, Map, Reduce;
*$EXTERN Success, Fails

*$FROM Refal5-Tokens
*$EXTERN TkCompound, TkError, TkEOF, TkComma, TkName

*$FROM Refal5-Parser
$EXTERN Parse, TokName;

*$FROM Refal5-Transformer
$EXTERN Transform;
*$EXTERN NO-POS

*$FROM Refal5-AST
*$EXTERN Function, Extern, SpecialComment, RETURN, Symbol, Word, Number, Char
*$EXTERN Variable, Brackets, Call, Local, Entry, Condition, CALL-BLOCK

*$FROM Libarary
*$EXTERN True, False


/**
  <R05-PrepareAST e.AST>
    == Success e.R05-AST
    == Fails e.Errors

  Function expands specific pseudocomments, checks specific errors
  and transform to basic Refal
*/
$ENTRY R05-PrepareAST {
  e.AST = <CheckAST <RedudandExterns <ExpandComments e.AST>>>;
}

ExpandComments {
  e.AST = <MapAccum r05-parser_ExpandComment <EL-Create> e.AST>;
}

$ENTRY r05-parser_ExpandComment {
  t.ErrorList (SpecialComment t.SrcPos '*$' e.KeyWord s.Space e.Rest)
    , <IsKeyWord e.KeyWord> : s.Scope
    , <IsSpace s.Space> : True
    , <ParseSpecialComment
        s.Scope
        <ScanString-FromPos t.SrcPos <Spaces '*$' e.KeyWord> e.Rest>
        t.ErrorList
      >
    /* TODO: удалить после рефакторинга */
    : t.ErrorList1 e.Functions
    = t.ErrorList1 <AjustCommentFunction e.Functions>;

  t.ErrorList t.OtherNode = t.ErrorList t.OtherNode;
}

AjustCommentFunction {
  (Function t.SrcPos (e.Name) Extern) e.Functions
    = (Extern (t.SrcPos e.Name))
      <AjustCommentFunction e.Functions>;

  (Function t.SrcPos (e.Name) s.ScopeClass) e.Functions
    = (Function t.SrcPos (e.Name) s.ScopeClass)
      <AjustCommentFunction e.Functions>;

  /* empty */ = /* empty */;
}

IsKeyWord {
  'ENUM' = Local;
  'EENUM' = Entry;
  'EXTRN' = Extern;
  'EXTERN' = Extern;
  'EXTERNAL' = Extern;

  e.Other = /* пусто */;
}

IsSpace { ' ' = True; '\t' = True; s.Other = False }

Spaces {
  s.Char e.String = ' ' <Spaces e.String>;
  /* пусто */ = /* пусто */
}

RedudandExterns {
  t.ErrorList
  e.AST-B
  (Extern e.Names-B (t.SrcPos1 e.Name) e.Names-M (t.SrcPos2 e.Name) e.Names-E)
  e.AST-E
    = <RedudandExterns
        t.ErrorList
        e.AST-B
        (Extern e.Names-B (t.SrcPos1 e.Name) e.Names-M e.Names-E)
        e.AST-E
      >;

  t.ErrorList
  e.AST-B
  (Extern e.Names-B (t.SrcPos1 e.Name) e.Names-E)
  e.AST-M
  (Function t.SrcPos2 (e.Name) s.Scope e.Sentences)
  e.AST-E
    = <RedudandExterns
        t.ErrorList
        e.AST-B
        <FoldExtern e.Names-B e.Names-E>
        e.AST-M
        (Function t.SrcPos2 (e.Name) s.Scope e.Sentences)
        e.AST-E
      >;

  t.ErrorList
  e.AST-B
  (Function t.SrcPos1 (e.Name) s.Scope e.Sentences)
  e.AST-M
  (Extern e.Names-B (t.SrcPos2 e.Name) e.Names-E)
  e.AST-E
    = <RedudandExterns
        t.ErrorList
        e.AST-B
        (Function t.SrcPos1 (e.Name) s.Scope e.Sentences)
        e.AST-M
        <FoldExtern e.Names-B e.Names-E>
        e.AST-E
      >;

  t.ErrorList
  e.AST-B
  (Extern e.Names1-B (t.SrcPos1 e.Name) e.Names1-E)
  e.AST-M
  (Extern e.Names2-B (t.SrcPos2 e.Name) e.Names2-E)
  e.AST-E
    = <RedudandExterns
        t.ErrorList
        e.AST-B
        (Extern e.Names1-B (t.SrcPos1 e.Name) e.Names1-E)
        e.AST-M
        <FoldExtern e.Names2-B e.Names2-E>
        e.AST-E
      >;

  t.ErrorList e.AST = t.ErrorList e.AST;
}

FoldExtern {
  /* пусто */ = /* пусто */;
  e.Names = (Extern e.Names);
}

CheckAST {
  t.ErrorList e.AST
    , <CheckAST-FindEntry e.AST> : e.EntryError
    , <CheckAST-Redefinitions e.AST> : e.RedefinitionErrors
    = <CheckAST-SwErrors
        (<EL-Destroy t.ErrorList> e.EntryError e.RedefinitionErrors)
        <CheckAST-Functions <ExtractReferences e.AST>>
        (e.AST)
      >;
}

CheckAST-SwErrors {
  (/* no comment errors */) e.Builtins (/* no semantic errors */) (e.AST)
    = Success e.Builtins e.AST;

  (e.CommentErrors) e.Builtins (e.SemanticErrors) (e.AST)
    = Fails e.CommentErrors e.SemanticErrors;
}

CheckAST-FindEntry {
  e.AST-B (Function t.SrcPos (e.Name) Entry e.Sentences) e.AST-E
    = /* нет ошибок */;

  (Function t.SrcPos (e.Name) s.Scope e.Body) e.AST = <NoEntryError t.SrcPos>;
  (Extern (t.SrcPos e.Name) e.Externs) e.AST = <NoEntryError t.SrcPos>;
  (SpecialComment t.SrcPos e.Text) e.AST = <NoEntryError t.SrcPos>;

  /* нет дерева */ = <NoEntryError NO-POS>;
}

NoEntryError {
  (s.Row s.Col e.FileName) = ((1 1 e.FileName) 'No entry function in file');

  NO-POS = ((1 1 '<unknown>') 'No entry function in file');
}

CheckAST-Redefinitions {
  /*
    Ошибки в переопределениях могут быть только для пустых функций,
    поскольку на входе мы полагаем корректное синтаксическое дерево.
  */
  e.Items-B
  (Function t.SrcPos1 (e.Name) s.Scope1 e.Sentences)
  e.Items-M
  (Function t.SrcPos2 (e.Name) s.Scope2 /* пусто */)
  e.Items-E
    = (t.SrcPos2 'Empty function ' e.Name ' redefines other function')
      <CheckAST-Redefinitions
        e.Items-B
        (Function t.SrcPos1 (e.Name) s.Scope1 e.Sentences)
        e.Items-M e.Items-E
      >;

  e.Items-B
  (Function t.SrcPos1 (e.Name) s.Scope1 /* пусто */)
  e.Items-M
  (Function t.SrcPos2 (e.Name) s.Scope2 e.Sentences)
  e.Items-E
    = (t.SrcPos1 'Empty function ' e.Name ' redefines other function')
      <CheckAST-Redefinitions
        e.Items-B e.Items-M
        (Function t.SrcPos2 (e.Name) s.Scope2 e.Sentences)
        e.Items-E
      >;

  e.Items = /* пусто */;
}

CheckAST-Functions {
  e.ReferenceBags
    , <CheckAST-Functions-Calls
        <MapAccum r05-parser_PlainBags (/* func names */) e.ReferenceBags>
      >
    : e.UsedBuiltins (e.Errors)
    = e.UsedBuiltins
      (e.Errors <CheckAST-Functions-Unused e.ReferenceBags>);
}

$ENTRY r05-parser_PlainBags {
  (e.FuncNames) (t.SrcPos (e.FuncName) s.ScopeEx e.References)
    = (e.FuncNames (e.FuncName)) e.References;
}

CheckAST-Functions-Calls {
  (e.FuncNames) e.References
    = <CheckAST-Functions-DoCalls (e.FuncNames) <UniqReferences e.References>>;
}

CheckAST-Functions-DoCalls {
  ((e.Name) e.FuncNames) e.References-B ((e.Name) e.Positions) e.References-E
    = <CheckAST-Functions-DoCalls (e.FuncNames) e.References-B e.References-E>;

  ((e.Name) e.FuncNames) e.References
    = <CheckAST-Functions-DoCalls (e.FuncNames) e.References>;

  (/* no names */) e.References
    = <CheckAST-Functions-UsedBuiltins <LoadBuiltins> (e.References)>;
}

LoadBuiltins { = <Map r05-parser_BuiltinName <ListOfBuiltin>> }

$ENTRY r05-parser_BuiltinName { (s.Id s.Name s.Type) = (<Explode s.Name>) }

CheckAST-Functions-UsedBuiltins {
  (e.Builtin) e.Builtins (e.Refs-B ((e.Builtin) e.Pos) e.Refs-E)
    = (Extern (NO-POS e.Builtin))
      <CheckAST-Functions-UsedBuiltins e.Builtins (e.Refs-B e.Refs-E)>;

  (e.Builtin) e.Builtins (e.References)
    = <CheckAST-Functions-UsedBuiltins e.Builtins (e.References)>;

  /* кончились встроенные */ (e.UndefinedReferences)
    = (<Map r05-parser_UndefinedReferenceMessage e.UndefinedReferences>);
}

$ENTRY r05-parser_UndefinedReferenceMessage {
  ((e.Name) t.Pos e.PosList)
    = (t.Pos 'Function ' e.Name ' is not defined')
      <r05-parser_UndefinedReferenceMessage ((e.Name) e.PosList)>;

  ((e.Name) /* no pos */) = /* no errors */;
}

CheckAST-Functions-Unused {
  e.ReferenceBags
     = <EL-Destroy
          <FindUnusedFunctions-Aux
            <EL-Create>
            <PrepareFormat-FUF-A e.ReferenceBags>
          >
       >;
}

PrepareFormat-FUF-A {
  e.ReferenceBags
    = <MapAccum r05-parser_PrepareFormat-FUF-A-Bag () e.ReferenceBags>;
}

/* TODO */
$ENTRY r05-parser_PrepareFormat-FUF-A-Bag {
  (e.Entries) (t.SrcPos (e.Name) Entry e.References)
    = (e.Entries (t.SrcPos e.Name))
      ((e.Name) t.SrcPos Entry
        <Map r05-parser_PrepareFormat-FUF-A-Reference e.References>
      );

  (e.Entries) (t.SrcPos (e.Name) s.ScopeEx e.References)
    = (e.Entries)
      ((e.Name) t.SrcPos s.ScopeEx
        <Map r05-parser_PrepareFormat-FUF-A-Reference e.References>
      );
}

$ENTRY r05-parser_PrepareFormat-FUF-A-Reference {
  ((e.Name) t.Pos e.Poses) = (t.Pos e.Name);
}

/*
  <ExtractReferences e.AST> == e.ReferenceBag*

  e.ReferenceBag ::= (t.SrcPos (e.FuncName) s.ScopeEx t.Reference*)*
  s.ScopeEx ::= Entry | Local | Extern
  t.Reference ::= ((e.Name) t.SrcPos+)
*/
ExtractReferences {
  e.AST = <Map r05-parser_ExtractReferences-Functions e.AST>;
}

$ENTRY r05-parser_ExtractReferences-Functions {
  (Function t.SrcPos (e.Name) s.Scope e.Sentences)
    = (t.SrcPos (e.Name) s.Scope
        <UniqReferences <ExtractReferences-Sentences e.Sentences>>
      );

  (Extern e.Externs) = <Map r05-parser_ExternAsBag e.Externs>;

  (SpecialComment t.SrcPos e.Text) = /* нет мешков в комментарии */;
}

$ENTRY r05-parser_ExternAsBag {
  (t.SrcPos e.Name) = (t.SrcPos (e.Name) Extern /* no bags */);
}

ExtractReferences-Sentences {
  e.Sentences = <Map r05-parser_ExtractReferences-OneSentence e.Sentences>;
}

$ENTRY r05-parser_ExtractReferences-OneSentence {
  ((e.Pattern) e.Tail)
    = <ExtractReferences-Expr e.Pattern> <ExtractReferences-Tail e.Tail>;
}

ExtractReferences-Tail {
  (Condition (e.Result) (e.Pattern)) e.Tail
    = <ExtractReferences-Expr e.Result> <ExtractReferences-Expr e.Pattern>
      <ExtractReferences-Tail e.Tail>;

  RETURN (e.Result) = <ExtractReferences-Expr e.Result>;

  CALL-BLOCK (e.Result) e.Sentences
    = <ExtractReferences-Expr e.Result>
      <ExtractReferences-Sentences e.Sentences>;
}

ExtractReferences-Expr {
  e.Expr = <Map r05-parser_ExtractReferences-Term e.Expr>;
}

$ENTRY r05-parser_ExtractReferences-Term {
  (Symbol Word t.SrcPos e.Name) = ((e.Name) t.SrcPos);

  (Brackets e.Expr) = <ExtractReferences-Expr e.Expr>;

  (Call t.SrcPos (e.Name) e.Expr)
    = ((<DesugarName e.Name>) t.SrcPos) <ExtractReferences-Expr e.Expr>;

  t.Other = /* пусто */;
}

DesugarName {
  '%' = 'Mod';
  '*' = 'Mul';
  '+' = 'Add';
  '-' = 'Sub';
  '/' = 'Div';
  '?' = 'Residue';

  e.Name = e.Name;
}

UniqReferences {
  e.Unique ((e.Name) e.Pos1) e.Refs-B ((e.Name) e.Pos2) e.Refs-E
    = e.Unique <UniqReferences e.Refs-B ((e.Name) e.Pos1 e.Pos2) e.Refs-E>;

  e.Unique = e.Unique;
}

/**
  <R05-Parse-File e.SourceFile>
    == Success e.Tree
    == Fails e.Errors

  e.Errors ::= ((s.Row s.Col) e.Message)*
*/
$ENTRY R05-Parse-File {
  e.SourceFile = <Parse-CheckTokens <Scan e.SourceFile>>;
}

Parse-CheckTokens {
  e.Tokens
    = <Parse-CheckTokens-Aux
        <MapAccum r05-parser_AddCompoundErrors (/* errors */) e.Tokens>
      >;
}

$ENTRY r05-parser_AddCompoundErrors {
  (e.Errors) (TkCompound t.SrcPos e.Text)
    = (e.Errors (t.SrcPos 'Refal-05 don\'t support compounds in qoutes'));

  (e.Errors) (TkError t.SrcPos e.Message) = (e.Errors (t.SrcPos e.Message));

  (e.Errors) t.OtherToken = (e.Errors) t.OtherToken;
}

Parse-CheckTokens-Aux {
  (e.LexerErrors) e.Tokens
    , <Parse e.Tokens>
    : {
        Success e.AST
          , <R05-PrepareAST e.AST>
          : {
            Success e.PreparedAST
              = <R05-Parse-Aux
                  <SemanticCheck
                     <PrepareR05AST <EL-Create e.LexerErrors> e.PreparedAST>
                  >
                >;

            Fails e.SemanticErrors
              = Fails <SortErrors e.LexerErrors e.SemanticErrors>;
          };

        Fails e.ParserErrors = Fails <SortErrors e.LexerErrors e.ParserErrors>;
      };
}

R05-Parse-Aux {
  t.ErrorList e.Tree =
    <R05-Parse-SwErrors (<EL-Destroy t.ErrorList>) e.Tree>;
}

R05-Parse-SwErrors {
  (/* no errors */) e.Tree = Success e.Tree;

*  (e.Errors) e.Tree = Fails <SortErrors e.Errors>;
}

SortErrors {
  e.Errors = <DoSortErrors (/* sorted */) e.Errors>;
}

DoSortErrors {
  (e.Sorted) /* unsorted */ = e.Sorted;

  (e.Sorted) t.Next e.Unsorted =
    <DoSortErrors
      (<SortErrors-Insert e.Sorted t.Next>)
      e.Unsorted
    >;
}

SortErrors-Insert {
  /* пусто */ t.Next = t.Next;

  e.Sorted t.Great t.Next =
    <SortErrors-Insert-Compare
      e.Sorted t.Great t.Next <CompareError t.Great t.Next>
    >;
}

SortErrors-Insert-Compare {
  e.Sorted t.Great t.Next '+' = <SortErrors-Insert e.Sorted t.Next> t.Great;
  e.Sorted t.Great t.Next s.Other = e.Sorted t.Great t.Next;
}

CompareError {
  ((s.Row s.Col1 e.File1) e.Message1) ((s.Row s.Col2 e.File2) e.Message2) =
    <Compare s.Col1 s.Col2>;

  ((s.Row1 s.Col1 e.File1) e.Message1) ((s.Row2 s.Col2 e.File2) e.Message2) =
    <Compare s.Row1 s.Row2>;
}


PrepareR05AST {
  t.ErrorList e.AST
    = <MapAccum r05-parser_PrepareUnit t.ErrorList <Transform e.AST>>;
}

$ENTRY r05-parser_PrepareUnit {
  t.ErrorList (Function t.SrcPos (e.Name) s.Scope e.Sentences)
    = t.ErrorList
      (Function
        t.SrcPos (e.Name) s.Scope
        <Map r05-parser_PrepareSentence e.Sentences>
      );

  t.ErrorList (Extern e.Names)
    = t.ErrorList <Map r05-parser_PrepareExterns e.Names>;

  t.ErrorList (SpecialComment t.SrcPos e.Text)
    = <PrepareSpecialComment t.ErrorList t.SrcPos e.Text>;
}

$ENTRY r05-parser_PrepareSentence {
  ((e.Pattern) RETURN (e.Result)) =
    ((<PrepareExpression e.Pattern>) (<PrepareExpression e.Result>))
}

PrepareExpression {
  e.Expression = <Map r05-parser_PrepareTerm e.Expression>;
}

$ENTRY r05-parser_PrepareTerm {
  (Symbol Word t.SrcPos e.Name) = (Symbol Word t.SrcPos <Normalize e.Name>);
  (Symbol Number s.Number) = (Symbol Number s.Number);
  (Symbol Char s.Char) = (Symbol Char s.Char);

  (Variable t.SrcPos s.Type e.Index) = (Variable s.Type e.Index);
  (Brackets e.Expression) = (Brackets <PrepareExpression e.Expression>);
  (Call t.SrcPos (e.Name) e.Expression)
    = (Call t.SrcPos (<Normalize e.Name>) <PrepareExpression e.Expression>);
}

$ENTRY r05-parser_PrepareExterns {
  (t.SrcPos e.Name) = (Function t.SrcPos (e.Name) Extern /* пусто */);
}

PrepareSpecialComment {
  t.ErrorList t.Pos '*$' e.KeyWord s.Space e.Rest
    , <IsKeyWord e.KeyWord> : s.Scope
    , <IsSpace s.Space> : True
    = <ParseSpecialComment
        s.Scope
        <ScanString-FromPos t.Pos <Spaces '*$' e.KeyWord> e.Rest>
        t.ErrorList
      >;

* пропускаем любые другие специальные комментарии
  t.ErrorList t.Pos e.OtherComment = t.ErrorList;
}


ParseSpecialComment {
  s.Scope e.Tokens t.ErrorList
    , <ParseList (ListKeyWord s.Scope) e.Tokens t.ErrorList>
    : (List s.ScopeClass e.Names) e.UnexpectedTokens (TkEOF t.SrcPos)
      t.ErrorList2
    = <AddUnexpectedTokens t.ErrorList2 e.UnexpectedTokens>
      <Map (parser_MakeListFunction s.ScopeClass) e.Names>;
}

AddUnexpectedTokens {
  t.ErrorList /* пусто */ = t.ErrorList;

  t.ErrorList t.Unexpected e.Tokens
    = <AddUnexpectedTokens
        <EL-AddUnexpected t.ErrorList t.Unexpected 'comma or name'>
        e.Tokens
      >;
}

*$ENUM List

$ENTRY parser_MakeListFunction {
  s.ScopeClass (t.SrcPos e.Name) =
    (Function t.SrcPos (e.Name) s.ScopeClass /* пусто */);
}


*$ENUM ListKeyWord

/*
  List ::= List ',' NAME | ListKeyWord NAME.

  <ParseList e.Stack e.Tokens t.ErrorList>
    == (List s.ScopeClass (t.SrcPos e.Name)*) e.Tokens t.ErrorList
*/
ParseList {
  /* List ::= List ',' NAME */
  (List s.ScopeClass e.Names)
  (TkComma t.CommaSrcPos) (TkName t.NameSrcPos e.Name) e.Tokens t.ErrorList =
    <ParseList
      (List s.ScopeClass e.Names (t.NameSrcPos e.Name)) e.Tokens t.ErrorList
    >;

  (List s.ScopeClass e.Names) (TkName t.SrcPos e.Name) e.Tokens t.ErrorList =
    <ParseList
      (List s.ScopeClass e.Names (t.SrcPos e.Name))
      e.Tokens
      <EL-AddErrorAt t.ErrorList t.SrcPos 'expected comma'>
    >;

  (List s.ScopeClass e.Names) (TkComma t.SrcPos) e.Tokens t.ErrorList =
    <ParseList
      (List s.ScopeClass e.Names) e.Tokens
      <EL-AddErrorAt t.ErrorList t.SrcPos 'missed function name'>
    >;

  (List s.ScopeClass e.Names) e.Tokens t.ErrorList =
    (List s.ScopeClass e.Names) e.Tokens t.ErrorList;

  /* List ::= ListKeyWord NAME */
  (ListKeyWord s.ScopeClass) (TkName t.SrcPos e.Name) e.Tokens t.ErrorList =
    <ParseList (List s.ScopeClass (t.SrcPos e.Name)) e.Tokens t.ErrorList>;

  (ListKeyWord s.ScopeClass) t.Unexpected e.Tokens t.ErrorList =
    (List s.ScopeClass) t.Unexpected e.Tokens
    <EL-AddUnexpected t.ErrorList t.Unexpected 'function name'>;
}


SemanticCheck {
  t.ErrorList e.Tree =
    <FindOneEntry
      t.ErrorList (<ExtractReferences-Old e.Tree>) <LoadBuiltins-Old> e.Tree
    >;
}

ExtractReferences-Old {
  e.Tree = <Map parser_ExtractReferences e.Tree>;
}

$ENTRY parser_ExtractReferences {
  (Function t.SrcPos (e.Name) s.ScopeClass e.Sentences) =
    <ExtractReferences-Old-Sentences e.Sentences>;
}

ExtractReferences-Old-Sentences {
  e.Sentences = <Map parser_ExtractReferences-Sentences e.Sentences>;
}

$ENTRY parser_ExtractReferences-Sentences {
  ((e.Pattern) (e.Result)) =
    <ExtractReferences-Old-Expr e.Pattern>
    <ExtractReferences-Old-Expr e.Result>;
}

ExtractReferences-Old-Expr {
  e.Expr = <Map parser_ExtractReferences-Expr e.Expr>;
}

$ENTRY parser_ExtractReferences-Expr {
  (Symbol Word t.SrcPos e.Name) = (t.SrcPos e.Name);
  (Symbol s.Type e.Value) = /* это не имя функции */;

  (Variable s.Mode e.Index) = /* это не имя функции */;

  (Brackets e.Expr) = <ExtractReferences-Old-Expr e.Expr>;
  (Call t.SrcPos (e.Name) e.Expr)
     = (t.SrcPos e.Name) <ExtractReferences-Old-Expr e.Expr>;
}

FindOneEntry {
  t.ErrorList (e.References)
  e.Tree-B (Function t.SrcPos (e.Name) Entry e.Body) e.Tree-E =
    <FindUnusedFunctions
      t.ErrorList (e.References)
      e.Tree-B (Function t.SrcPos (e.Name) Entry e.Body) e.Tree-E
    >;

  t.ErrorList (e.References) e.Tree =
    <FindUnusedFunctions
      <EL-AddErrorAt t.ErrorList (1 1) 'No entry functions in file'>
      (e.References) e.Tree
    >;
}


FindUnusedFunctions {
  t.ErrorList (e.References) e.AST
    = <CheckRepeatedDefinitions
        <FindUnusedFunctions-Aux
          t.ErrorList
          <MapAccum r05-parser_PrepareCrossRefs () e.AST>
        >
        (e.References) e.AST
      >;
}

$ENTRY r05-parser_PrepareCrossRefs {
  (e.Entries) (Function t.SrcPos (e.Name) Entry e.Sentences)
    = (e.Entries (t.SrcPos e.Name))
      ((e.Name) t.SrcPos Entry <ExtractReferences-Old-Sentences e.Sentences>);

  (e.Entries) (Function t.SrcPos (e.Name) s.Scope e.Sentences)
    = (e.Entries)
      ((e.Name) t.SrcPos s.Scope <ExtractReferences-Old-Sentences e.Sentences>);
}

FindUnusedFunctions-Aux {
  t.ErrorList (e.UsedReferences) /* все функции вызваны */ = t.ErrorList;

  t.ErrorList ((t.RefPos e.NextName) e.UsedReferences)
  e.Functions-B ((e.NextName) t.FunctionPos s.Scope e.References) e.Functions-E
    = <FindUnusedFunctions-Aux
        t.ErrorList (e.UsedReferences e.References) e.Functions-B e.Functions-E
      >;


  t.ErrorList ((t.RefPos e.NextName) e.UsedReferences) e.Functions
    = <FindUnusedFunctions-Aux t.ErrorList (e.UsedReferences) e.Functions>;

  t.ErrorList (/* пусто */) e.UnusedFunctions
    = <FindUnusedRoot t.ErrorList (e.UnusedFunctions) e.UnusedFunctions>;
}

FindUnusedRoot {
  t.ErrorList (((e.Root) t.RootPos s.Scope e.RootRefs)) e.AllFunctions
    = <FindUnusedFunctions-Aux
        <AddUnusedMessage t.ErrorList t.RootPos s.Scope e.Root>
        ((t.RootPos e.Root)) e.AllFunctions
      >;

  t.ErrorList
  (((e.NotARoot) t.NotARootPos s.NotARootScope e.Body) e.Unuseds)
  e.Users-B
  ((e.User) t.UserPos s.Scope e.Refs-B (t.RefPos e.NotARoot) e.Refs-E)
  e.Users-E
    = <FindUnusedRoot
        t.ErrorList (e.Unuseds)
        e.Users-B
        ((e.User) t.UserPos s.Scope e.Refs-B (t.RefPos e.NotARoot) e.Refs-E)
        e.Users-E
      >;

  t.ErrorList (((e.Root) t.RootPos s.Scope e.RootRefs) e.Unuseds) e.AllFunctions
    = <FindUnusedFunctions-Aux
        <AddUnusedMessage t.ErrorList t.RootPos s.Scope e.Root>
        ((t.RootPos e.Root)) e.AllFunctions
      >;

  t.ErrorList (/* кончились неиспользуемые функции */) e.AllFunctions
    = t.ErrorList;
}

AddUnusedMessage {
  t.ErrorList t.Pos Local e.Name
     = <EL-AddErrorAt t.ErrorList t.Pos 'Unused local function ' e.Name>;

  t.ErrorList NO-POS Extern e.Name = t.ErrorList;

  t.ErrorList t.Pos Extern e.Name
     = <EL-AddErrorAt t.ErrorList t.Pos 'Unused external declaration ' e.Name>;
}


LoadBuiltins-Old {
  = <Map parser_BuiltinDeclaration <ListOfBuiltin>>;
}

$ENTRY parser_BuiltinDeclaration {
  (s.Number s.Name s.Type)
    , <Explode s.Name>
    : {
        /* пусто */ = /* пропускаем */;
        e.Name '$' = /* пропускаем */;

        e.Name = (Function NO-POS (<Normalize e.Name>) Extern /* пусто */);
      }
}

Normalize {
  '%' = 'Mod';
  '*' = 'Mul';
  '+' = 'Add';
  '-' = 'Sub';
  '/' = 'Div';
  '?' = 'Residue';

  e.Name = e.Name;
}

CheckRepeatedDefinitions {
  t.ErrorList (e.References)
  e.Tree-B (Function t.SrcPos1 (e.Name) s.ScopeClass e.Body) e.Tree-E
  (Function t.SrcPos2 (e.Name) Extern) =
    /* $EXTERN для уже существующей функции */
    <CheckRepeatedDefinitions
      t.ErrorList (e.References)
      e.Tree-B (Function t.SrcPos1 (e.Name) s.ScopeClass e.Body) e.Tree-E
    >;

  t.ErrorList (e.References-B (t.SrcPosRef e.Name) e.References-E)
  e.Tree (Function t.SrcPos (e.Name) Extern) =
    /* $EXTERN используется */
    <CheckRepeatedDefinitions
      t.ErrorList (e.References-B <RemoveReference (e.Name) e.References-E>)
      e.Tree
    >
    (Extern (t.SrcPos e.Name));

  t.ErrorList (e.References)
  e.Tree (Function t.SrcPos (e.Name) Extern) =
    /* $EXTERN не используется */
    <CheckRepeatedDefinitions t.ErrorList (e.References) e.Tree>;

  t.ErrorList (e.References)
  e.Tree-B (Function t.SrcPos1 (e.Name) Extern) e.Tree-E
  (Function t.SrcPos2 (e.Name) s.ScopeClass e.Body) =
    /* $EXTERN для уже существующей функции */
    <CheckRepeatedDefinitions
      t.ErrorList (e.References)
      e.Tree-B e.Tree-E (Function t.SrcPos2 (e.Name) s.ScopeClass e.Body)
    >;

  t.ErrorList (e.References)
  e.Tree-B (Function t.SrcPos1 (e.Name) s.ScopeClass1 e.Body1) e.Tree-E
  (Function t.SrcPos2 (e.Name) s.ScopeClass2 e.Body2) =
    /* Повторное определение функции */
    <CheckRepeatedDefinitions
      <EL-AddErrorAt
        t.ErrorList t.SrcPos2 'Function ' e.Name ' already defined'
      >
      (e.References)
      e.Tree-B (Function t.SrcPos1 (e.Name) s.ScopeClass1 e.Body1) e.Tree-E
    >;

  t.ErrorList (e.References)
  e.Tree (Function t.SrcPos (e.Name) s.Scope e.Body) =
    <CheckRepeatedDefinitions
      t.ErrorList (<RemoveReference (e.Name) e.References>) e.Tree
    >
    (Function t.SrcPos (e.Name) s.Scope e.Body);

  t.ErrorList (e.References) /* пусто */ =
    <Reduce parser_AddUnresolved t.ErrorList e.References>;
}

RemoveReference {
  (e.Name) e.References-B (t.SrcPos e.Name) e.References-E =
    e.References-B <RemoveReference (e.Name) e.References-E>;

  (e.Name) e.References = e.References;
}

$ENTRY parser_AddUnresolved {
  t.ErrorList (t.SrcPos e.Name) =
    <EL-AddErrorAt t.ErrorList t.SrcPos 'Function ' e.Name ' is not defined'>;
}


*$ENUM ErrorList

EL-Create {
  e.Errors = (ErrorList e.Errors);
}

EL-AddErrorAt {
  (ErrorList e.Errors) t.SrcPos e.Message =
    (ErrorList e.Errors (t.SrcPos e.Message));
}

EL-AddUnexpected {
  t.ErrorList (TkError t.SrcPos e.Message) e.Expected =
    <EL-AddErrorAt
      t.ErrorList t.SrcPos e.Message
    >;

  t.ErrorList (s.Unexpected t.SrcPos e.Info) e.Expected =
    <EL-AddErrorAt
      t.ErrorList t.SrcPos
      'Unexpected ' <TokName s.Unexpected> ', expected ' e.Expected
    >;
}

EL-Destroy {
  (ErrorList e.Errors) = e.Errors;
}
